[
  {
    "id": "shell-injection-string-concat",
    "title": "Shell injection via string concatenation",
    "severity": "critical",
    "scope": "scheme",
    "pattern": "(##shell-command|shell-command)\\s.*?(string-append|string-concatenate|format\\s)",
    "message": "Shell command constructed via string concatenation. User-controlled input may allow arbitrary command execution.",
    "remediation": "Use a safe process API (e.g., run-process with explicit argument lists) instead of shell-command with concatenated strings.",
    "tags": [
      "shell",
      "injection",
      "command",
      "string-append",
      "rce"
    ]
  },
  {
    "id": "ffi-pointer-void-u8vector",
    "title": "FFI (pointer void) likely passed a u8vector",
    "severity": "high",
    "scope": "ffi-boundary",
    "pattern": "c-lambda\\s+\\([^)]*pointer\\s+void[^)]*\\)",
    "message": "c-lambda uses (pointer void) parameter type. If callers pass u8vector values, Gambit will pass the raw Scheme object address (including header) instead of the data bytes, causing data corruption.",
    "remediation": "Use scheme-object parameter type and access data bytes via ___BODY(arg) or U8_DATA() macro in the C body.",
    "related_recipe": "ffi-scheme-object-u8vector-data",
    "tags": [
      "ffi",
      "pointer",
      "void",
      "u8vector",
      "type-mismatch",
      "data-corruption"
    ]
  },
  {
    "id": "alloc-scmobj-no-fixnump-check",
    "title": "___alloc_scmobj without ___FIXNUMP failure check",
    "severity": "high",
    "scope": "c-shim",
    "pattern": "___alloc_scmobj",
    "message": "___alloc_scmobj can return a fixnum error code on allocation failure. Without a ___FIXNUMP check, the code will dereference a non-pointer, causing a crash.",
    "remediation": "Check the return value with: if (___FIXNUMP(result)) { /* handle allocation failure */ }",
    "tags": [
      "alloc",
      "scmobj",
      "fixnump",
      "oom",
      "crash",
      "gambit",
      "c"
    ]
  },
  {
    "id": "port-open-no-unwind-protect",
    "title": "Port opened without unwind-protect resource guard",
    "severity": "medium",
    "scope": "scheme",
    "pattern": "(open-input-file|open-output-file|open-input-string|open-output-string|open-tcp-client|open-tcp-server|open-process)",
    "message": "File/network port opened without unwind-protect or call-with-* guard. If an exception occurs before close-port, the port leaks.",
    "remediation": "Wrap in (call-with-input-file path proc) or (unwind-protect (begin ... (close-port p)) (close-port p)).",
    "tags": [
      "port",
      "file",
      "resource-leak",
      "unwind-protect",
      "exception"
    ]
  },
  {
    "id": "c-buffer-silent-truncation",
    "title": "C buffer memcpy with clamped size (silent truncation)",
    "severity": "medium",
    "scope": "c-shim",
    "pattern": "memcpy\\s*\\([^;]*\\bmin\\b[^;]*\\)",
    "message": "memcpy with min/clamp on size silently truncates data without reporting the truncation to the caller. This can cause data corruption or incomplete operations.",
    "remediation": "Return the actual bytes copied or an error code when the buffer is too small, rather than silently truncating.",
    "tags": [
      "memcpy",
      "truncation",
      "buffer",
      "silent",
      "c"
    ]
  },
  {
    "id": "static-global-buffer-thread-safety",
    "title": "Static global buffer in C shim (thread safety)",
    "severity": "medium",
    "scope": "c-shim",
    "pattern": "static\\s+(char|uint8_t|unsigned\\s+char)\\s+\\w+\\s*\\[",
    "message": "Static buffer in C shim is shared across all threads. Concurrent calls from multiple Gerbil threads will cause data races.",
    "remediation": "Use thread-local storage (__thread or pthread_key), allocate on the heap, or pass a caller-provided buffer.",
    "tags": [
      "static",
      "buffer",
      "thread",
      "race",
      "c",
      "global"
    ]
  },
  {
    "id": "unused-security-parameter",
    "title": "Unused security-relevant function parameter",
    "severity": "low",
    "scope": "scheme",
    "pattern": "\\(def\\s+\\([^)]*\\b(mode|mask|perm|permission|auth|token|secret|credential|password)\\b",
    "message": "Function parameter with a security-relevant name (mode, mask, perm, etc.) may be intentionally ignored. Verify the parameter is actually used in the function body.",
    "remediation": "Ensure the security-relevant parameter is used. If intentionally unused, prefix with underscore (_mode) to document the intent.",
    "tags": [
      "unused",
      "parameter",
      "permission",
      "mode",
      "heuristic"
    ]
  },
  {
    "id": "ffi-void-return-on-init",
    "title": "FFI init/initialize function declared as void instead of int",
    "severity": "medium",
    "scope": "ffi-boundary",
    "pattern": "define-c-lambda\\s+\\S*_?[iI]nitialize\\s+\\([^)]*\\)\\s+void",
    "message": "C library initialization functions typically return an error code (int), but this FFI binding declares void return type. If initialization fails (e.g., out of memory), the failure is silently ignored, leading to undefined behavior or crashes in subsequent calls.",
    "remediation": "Change return type from void to int, and check the return value in the Scheme caller: (let ((r (lib_initialize obj))) (when (zero? r) (error \\\"Failed to initialize\\\")))",
    "related_recipe": "ffi-initialize-return-check",
    "tags": [
      "ffi",
      "initialize",
      "void",
      "return-type",
      "error-check",
      "init"
    ]
  },
  {
    "id": "ffi-null-pointer-dereference",
    "title": "FFI c-lambda dereferences pointer argument without null check",
    "severity": "high",
    "scope": "ffi-boundary",
    "pattern": "___arg\\d+\\)\\s*->",
    "message": "C code in c-lambda dereferences a pointer argument (___argN->field) without checking for NULL. If the Gambit pointer type allows NULL (which it does by default), this causes a segfault when NULL is passed. Common in FFI accessor functions for linked list traversal (next, children, properties, ns fields).",
    "remediation": "Add a NULL check before dereferencing: '___return(___arg1 ? ((xmlNodePtr)___arg1)->field : ___FAL);' or ensure all call sites in the .ss wrapper guard with a truthy check before calling the accessor.",
    "tags": [
      "ffi",
      "null",
      "pointer",
      "dereference",
      "segfault",
      "c-lambda",
      "accessor"
    ]
  },
  {
    "id": "ffi-mutex-no-unwind-protect",
    "title": "Port mutex lock without unwind-protect risks deadlock on exception",
    "severity": "medium",
    "scope": "scheme",
    "pattern": "macro-port-mutex-lock!",
    "message": "Code acquires a port mutex via macro-port-mutex-lock! but may not release it if an exception occurs between lock and unlock. This causes a permanent deadlock on the port.",
    "remediation": "Wrap the critical section between lock and unlock with unwind-protect or dynamic-wind to ensure the mutex is always released. See recipe: mutex-unwind-protect-deadlock-prevention.",
    "related_recipe": "mutex-unwind-protect-deadlock-prevention",
    "tags": [
      "mutex",
      "port",
      "deadlock",
      "unwind-protect",
      "exception",
      "lock"
    ]
  },
  {
    "id": "ffi-scheme-object-stored-in-c-struct",
    "title": "Scheme object stored in C struct without GC protection",
    "severity": "high",
    "scope": "c-shim",
    "pattern": "___SCMOBJ\\s+\\w+;|->data\\s*=\\s*___arg",
    "message": "A raw ___SCMOBJ (Scheme object handle) is stored in a C struct field. If this struct is used across GC safe points or in multithreaded code, the GC may relocate the object, making the stored handle point to stale memory. This causes silent data corruption or segfaults.",
    "remediation": "Either: (1) copy the Scheme data to a C-allocated buffer before storing, (2) use ##still-copy to pin the object, or (3) ensure the code path is single-threaded and contains no GC safe points (no Scheme allocations).",
    "related_recipe": "ffi-scheme-object-gc-safety-long-running",
    "tags": [
      "ffi",
      "gc",
      "scheme-object",
      "SCMOBJ",
      "struct",
      "stale",
      "multithreaded"
    ]
  }
]
