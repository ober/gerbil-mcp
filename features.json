[
  {
    "id": "ffi-null-safety-audit",
    "title": "FFI null-pointer safety audit for .scm files",
    "description": "A tool that statically analyzes .scm FFI files to find c-lambda declarations that dereference pointer arguments (___arg1->field) without null checks. Reports each accessor that could segfault on NULL input, cross-referenced with call sites in .ss wrapper files to check whether the wrapper guards the call with a null/truthy check. This catches the common pattern where FFI accessors blindly dereference pointers that can legitimately be NULL (e.g. xmlNode-children, xmlNode-ns, xmlNode-content returning NULL).",
    "impact": "medium",
    "tags": [
      "ffi",
      "null",
      "pointer",
      "safety",
      "audit",
      "c-lambda",
      "dereference",
      "segfault"
    ],
    "use_case": "When auditing FFI bindings to C libraries that use NULL to represent absence (linked list terminators, optional fields). Common in libxml2, libyaml, SQLite, and most C APIs.",
    "example_scenario": "Auditing gerbil-libxml: 15+ c-lambda accessors like xmlNode-content, xmlNode-name, xmlNs-href blindly dereference ___arg1->field. Some are guarded by null checks in the .ss wrapper (xmlNode-children via `if node`), but others are not (xmlNode-content on TEXT nodes, xmlNs-href). Manual cross-referencing took multiple tool calls to Read both files and trace each call path. A dedicated tool could report: 'xmlNode-content (line 163): dereferences ___arg1->content, called unguarded at libxml.ss:151'.",
    "estimated_token_reduction": "~2000 tokens per audit — eliminates manual cross-referencing of .scm accessors with .ss call sites, currently requires 2 Read calls + manual analysis",
    "votes": 2
  },
  {
    "id": "method-dispatch-audit",
    "title": "Detect method dispatch calls on objects that lack the method",
    "description": "A static analysis tool that checks `{method-name obj}` calls against the actual methods defined on the object's type. Reports cases where method dispatch will fail at runtime because the struct/class doesn't have the method defined (either directly or inherited). This catches the common bug pattern where code assumes an interface method exists (like `{close conn}`) but the struct's type hierarchy doesn't define it, leading to silent failures or contract violations at runtime.",
    "impact": "medium",
    "tags": [
      "method",
      "dispatch",
      "close",
      "interface",
      "struct",
      "static-analysis"
    ],
    "use_case": "When writing code that uses method dispatch on structs from external modules. Common in persistence layers, database wrappers, and any code using Gerbil's OOP features where multiple struct types implement similar interfaces.",
    "example_scenario": "In gerbil-persist, `{close Kvs}` called `{close (Kvs-connection self)}` where the connection is a DBI `connection` struct. DBI connections have NO `close` method — they use the plain function `sql-close`. This bug meant SQLite connections were never actually closed, causing 'database is locked' errors. The bug existed undetected because `{close}` dispatch failure was caught silently. A method-dispatch-audit tool would have flagged: '{close} called on connection::t at kvs.ss:26 — no close method found in type hierarchy'.",
    "estimated_token_reduction": "~1500 tokens per audit — eliminates manual tracing of method dispatch targets through struct hierarchies, currently requires gerbil_class_info + gerbil_module_exports + gerbil_eval to verify",
    "votes": 0
  },
  {
    "id": "ffi-buffer-size-audit",
    "title": "FFI buffer size audit — detect C functions writing more bytes than Scheme buffers allocate",
    "description": "A static analysis tool that cross-references c-declare C function output buffer sizes (from known API signatures or annotated array sizes like `byte out[96]`) against the Scheme-side make-u8vector allocations that provide those buffers. Detects cases where a C function writes N bytes but the Scheme wrapper allocates fewer than N bytes — a buffer overflow. Could parse #include headers for function signatures or accept size annotations. Reports: 'blst_p2_affine_serialize writes 192 bytes, but bytes<-blst-signature allocates 96-byte u8vector (line 250) — buffer overflow'.",
    "impact": "high",
    "tags": [
      "ffi",
      "buffer",
      "overflow",
      "size",
      "audit",
      "security",
      "u8vector",
      "make-u8vector"
    ],
    "use_case": "When reviewing FFI bindings for crypto libraries (blst, libsodium, libsecp256k1) or any C library that writes into caller-provided buffers. Buffer overflows in FFI are invisible at compile time and cause memory corruption at runtime.",
    "example_scenario": "In gerbil-crypto, blst_p1_affine_serialize writes 96 bytes (uncompressed G1) but the Scheme wrapper allocates a 48-byte u8vector. blst_p2_affine_serialize writes 192 bytes but gets a 96-byte buffer. These buffer overflows existed undetected because there were no BLS tests. Manual review required reading both the C header (blst.h) and the FFI shim to catch the mismatch. A dedicated tool could flag this instantly.",
    "estimated_token_reduction": "~3000 tokens per FFI module audit — eliminates manual cross-referencing of C API docs, c-declare shims, and Scheme buffer allocations across 3+ files",
    "votes": 0
  },
  {
    "id": "run-tests-clean-stale-artifacts",
    "title": "gerbil_run_tests should detect/clean stale compiled artifacts that conflict with source loading",
    "description": "When using gerbil_run_tests with file_path mode and GERBIL_LOADPATH pointing to source, stale compiled artifacts in .gerbil/lib/ or ~/.gerbil/lib/ can shadow the source files. This is especially problematic when a module exports `main` (for exe builds) — the compiled artifact's `(declare ...)` forms cause the test runner to invoke `main` instead of loading the test suite. The tool should either: (1) detect stale artifacts and warn, (2) offer a `clean` parameter to remove them before running, or (3) automatically check with gerbil_stale_static logic before test execution.",
    "impact": "medium",
    "tags": [
      "test",
      "stale",
      "artifacts",
      "clean",
      "compiled",
      "loadpath",
      "main"
    ],
    "use_case": "When running tests on a project that also builds executables. The exe module exports `main` and gets compiled with `(declare ...)` forms. Running gerbil_run_tests after a build picks up the compiled artifact, which triggers `main` invocation instead of test loading.",
    "example_scenario": "Project has es-proxy.ss (exports main for exe) and es-proxy-test.ss. After `gerbil build`, running gerbil_run_tests on es-proxy-test.ss with loadpath=[project-dir] fails with 'Missing argument remote-host' because it loads compiled es-proxy instead of source. Workaround: manually rm -rf .gerbil/lib/es-proxy ~/.gerbil/lib/es-proxy before testing. The Makefile does this, but gerbil_run_tests doesn't.",
    "estimated_token_reduction": "~500 tokens per failed test attempt — eliminates a round-trip of failure diagnosis + manual cleanup + retry",
    "votes": 0
  }
]
