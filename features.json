[
  {
    "id": "build-linkage-diagnostic",
    "title": "Diagnose silent linkage failures in defbuild-script exe targets",
    "description": "A tool that analyzes a build.ss defbuild-script and checks whether exe: targets have all required link dependencies. It would: (1) trace imports from the exe's main module transitively, (2) identify which modules use FFI (begin-foreign, c-lambda, etc.), (3) check if the exe's ld-options include the static libraries those FFI modules need, (4) verify pkg-config packages are discoverable (PKG_CONFIG_PATH), (5) report missing transitive deps. This would catch the exact class of bug where a Qt exe silently produces a broken binary because it's missing scintilla/termbox static libs from transitive imports.",
    "impact": "high",
    "tags": [
      "build",
      "linkage",
      "diagnostic",
      "transitive",
      "ffi",
      "exe",
      "defbuild-script"
    ],
    "use_case": "When building a multi-backend project where exe targets transitively depend on FFI libraries through shared modules. Currently requires manual tracing of import chains to find missing -L/-l flags.",
    "example_scenario": "gerbil-emacs Qt binary linked without scintilla/termbox/lexilla static libs because editor.ss (shared core) transitively imports them. The binary was produced as a 'data' file instead of ELF, with no error from the build system. Diagnosing this required manually running pkg-config, nm, and tracing imports — took ~30 minutes and many tool calls.",
    "estimated_token_reduction": "~2000 tokens per diagnosis — eliminates 8-10 tool calls (module_deps, ffi_inspect, eval for pkg-config, nm lookups, file reads of build.ss)",
    "votes": 3
  },
  {
    "id": "cross-module-symbol-dependency-check",
    "title": "Detect cross-module unbound symbol references before compilation",
    "description": "A tool that takes a list of Gerbil source files and detects cross-file symbol dependencies — which symbols each file references that are defined in other files but not imported. This is critical when splitting a large module into sub-modules: the original file had all definitions in scope, but after splitting, forward references become unbound identifiers. The tool would: (1) extract all top-level definitions from each file, (2) extract all symbol references in each file, (3) resolve imports to see which symbols are available, (4) report unresolved symbols with the file that defines them. This replaces the current workflow of compile → fix error → compile → fix next error, which takes many round-trips.",
    "impact": "high",
    "tags": [
      "cross-module",
      "dependency",
      "unbound",
      "split",
      "refactor",
      "symbol"
    ],
    "use_case": "When splitting a large Gerbil module (e.g. 10,000+ lines) into multiple sub-modules. The split creates forward references that become unbound identifier errors, but you only discover them one at a time during compilation. With 10+ such errors, this wastes many build cycles.",
    "example_scenario": "Splitting editor.ss (11,402 lines) into 7 sub-modules. After extraction, editor-core.ss references dired-open-directory! (in editor-ui.ss), cmd-repl-send (in editor-ui.ss), push-mark-ring! (in editor-text.ss), and *auto-pair-mode* (in editor-cmds-a.ss). Each was discovered via a separate compile-fail cycle. A pre-check would have identified all 4 in one pass.",
    "estimated_token_reduction": "~3000 tokens per split operation — eliminates 4-8 compile-fix cycles (each ~400 tokens for build output + grep + edit)",
    "votes": 1
  },
  {
    "id": "detect-ifdef-stubs-in-c-declare",
    "title": "Detect #ifdef/#else stubs in c-declare blocks that return NULL",
    "description": "A static analysis tool that scans Gerbil source files for c-declare blocks containing #ifdef/#else/#endif patterns where the #else branch returns NULL, 0, (void*)0, or similar sentinel values. These stubs are a common source of segfaults in cross-project exe builds because Gambit's exe builder doesn't propagate per-module cc-options, so the #else branch compiles instead of the real implementation. The tool would: (1) parse c-declare blocks, (2) identify #ifdef/#else patterns, (3) flag stubs that return NULL/0, (4) suggest removing the stubs and using build-time detection instead.",
    "impact": "high",
    "tags": [
      "ifdef",
      "c-declare",
      "stubs",
      "NULL",
      "segfault",
      "cross-project",
      "static-analysis"
    ],
    "use_case": "When writing or reviewing FFI code that uses conditional compilation in c-declare blocks. Especially important for library modules that will be consumed by downstream projects building exe targets.",
    "example_scenario": "gerbil-qt's libqt.ss had #ifdef QT_SCINTILLA_AVAILABLE / #else stubs returning (void*)0 in its c-declare block. When gerbil-emacs built its exe, Gambit compiled the .c without -DQT_SCINTILLA_AVAILABLE, so the stubs won, qt_scintilla_create returned NULL, and the binary segfaulted. Debugging this took ~2 hours and 50+ tool calls across GDB, nm, grep, and file reads.",
    "estimated_token_reduction": "~5000 tokens per occurrence — eliminates the entire debugging cycle of GDB breakpoints, nm symbol checks, and .c file inspection",
    "votes": 1
  },
  {
    "id": "qt-test-runner",
    "title": "Build and run Qt FFI test executables in one step",
    "description": "A tool that builds a Qt FFI test module as a compiled exe, applies patchelf for rpath, and runs it with QT_QPA_PLATFORM=offscreen — all in one call. Currently testing Qt FFI code requires: (1) adding an exe: entry to build.ss, (2) running gerbil build, (3) running patchelf to fix rpath for OpenSSL and Qt shim, (4) running with QT_QPA_PLATFORM=offscreen. This is 4 separate steps that must happen in order, each requiring knowledge of project-specific paths.",
    "impact": "medium",
    "tags": [
      "qt",
      "ffi",
      "test",
      "exe",
      "patchelf",
      "offscreen"
    ],
    "use_case": "When writing or debugging Qt FFI tests that need to run headless. The multi-step build-patchelf-run workflow is error-prone and requires remembering project-specific rpath values.",
    "example_scenario": "Writing qt-highlight-test.ss to verify QScintilla lexer activation. Had to: add exe: target to build.ss, run make build, patchelf the binary, run with QT_QPA_PLATFORM=offscreen. Each step was a separate tool call with project-specific paths. Took 5+ tool calls just for the build-run cycle, repeated multiple times during debugging.",
    "estimated_token_reduction": "~800 tokens per test cycle — eliminates 4 sequential tool calls and path lookups",
    "votes": 0
  },
  {
    "id": "pkg-link-sync-artifacts",
    "title": "Detect and sync stale linked-package artifacts (.ssi, .so, .scm)",
    "description": "A tool that checks if a `gerbil pkg link`-ed package has newer local build artifacts than the global ~/.gerbil/lib/ copies, and optionally syncs them. It would: (1) find linked packages via ~/.gerbil/pkg/ symlinks, (2) compare timestamps of .ssi, .scm, and .so files between local .gerbil/lib/ and global ~/.gerbil/lib/, (3) report which files are stale, (4) optionally copy them with dry_run support. This covers the common case where `make build` in a linked package updates local artifacts but the global path still has old copies — causing 'unbound identifier' or 'undefined symbol' errors in downstream projects.",
    "impact": "medium",
    "tags": [
      "pkg",
      "link",
      "stale",
      "ssi",
      "sync",
      "artifact",
      "rebuild"
    ],
    "use_case": "After adding new exports to a linked dependency package (e.g. gerbil-qt), rebuilding the dependency, and then finding that the downstream project (e.g. gerbil-emacs) fails with 'Reference to unbound identifier' for the new export.",
    "example_scenario": "Added qt-widget-set-focus! to gerbil-qt, ran `make clean && make build` in gerbil-qt/, then `make build` in gerbil-emacs/ — got 'Reference to unbound identifier: qt-widget-set-focus!' because ~/.gerbil/lib/gerbil-qt/qt.ssi was stale. Required manually grepping to find the right files and copying 3 artifacts (qt.ssi, libqt.ssi, libqt_shim.so). Took ~10 tool calls and 5 minutes.",
    "estimated_token_reduction": "~800 tokens per occurrence — eliminates 6-8 diagnostic tool calls (grep .ssi, find .so, cp commands)",
    "votes": 0
  }
]
