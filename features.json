[
  {
    "id": "gerbil-aws-namespace-validator",
    "title": "Tool to check gerbil-aws client namespace configuration",
    "description": "A tool that takes a gerbil-aws client expression (e.g., AWSClient or AWSJsonClient creation code) and validates that the namespace configuration will produce correct key names in parsed responses. It would check if the service's known namespace URI is mapped, and warn if strip-ns would produce incorrect results. Could also test a live API call and show the actual response keys vs expected keys.",
    "impact": "medium",
    "tags": [
      "gerbil-aws",
      "namespace",
      "XML",
      "validation",
      "strip-ns"
    ],
    "use_case": "When setting up a new gerbil-aws client for a Query API service (STS, RDS, ELBv2, etc.), validate that namespace mappings are correct before writing code that depends on specific response key names.",
    "example_scenario": "User creates an STSClient without namespace mappings. Tool warns that STS namespace URI 'https://sts.amazonaws.com/doc/2011-06-15/' is not mapped, and strip-ns will produce broken keys like '//sts.amazonaws.com/doc/2011-06-15/:Account instead of 'Account.",
    "estimated_token_reduction": "~500-1000 tokens per debugging session. Eliminates multi-step diagnosis: eval call → inspect response → trace through strip-ns → identify namespace issue."
  },
  {
    "id": "test-affected-by-signature-change",
    "title": "Detect test files affected by function signature changes",
    "description": "A tool that, given a function name and its module path, finds all test files that directly call that function and reports whether their call sites match the current arity. When a function's parameter list changes (e.g., adding a new required parameter), all test call sites break silently — they compile fine but fail at runtime with \"Wrong number of arguments\". This tool would scan test/*.ss files for calls to the function and compare call-site arity against the module's current exported signature.",
    "impact": "medium",
    "tags": [
      "test",
      "arity",
      "signature",
      "refactor",
      "breaking-change"
    ],
    "use_case": "After modifying a function signature (adding/removing parameters), quickly find which test files need updating before running the full test suite.",
    "example_scenario": "User adds a 'regions' parameter to find-edits-in-line. The function compiles fine, but test/rename-test.ss calls it with the old 7-arg signature. Running all tests fails at runtime with 'Wrong number of arguments'. This tool would immediately flag: 'test/rename-test.ss:15 calls find-edits-in-line with 7 args, expected 8'.",
    "estimated_token_reduction": "~300-500 tokens per refactoring. Eliminates the round-trip of running tests, reading error output, finding the test file, reading it, and updating call sites."
  },
  {
    "id": "lsp-message-validator",
    "title": "Validate LSP JSON-RPC messages against protocol spec",
    "description": "A tool that parses LSP JSON-RPC messages and validates them against the Language Server Protocol specification. Would check: required fields present, correct types for each field, valid method names, proper Content-Length framing. Could work on raw message strings or hash tables representing messages. Would report specific violations with the LSP spec reference.",
    "impact": "medium",
    "tags": [
      "lsp",
      "json-rpc",
      "validation",
      "protocol",
      "debug"
    ],
    "use_case": "When implementing or debugging an LSP server, validating that generated responses conform to the protocol spec without needing to test with a real editor client.",
    "example_scenario": "User implements a new LSP handler and wants to verify the response structure is correct. Currently they must manually compare against the LSP spec or wait for editor errors. This tool would immediately flag: 'textDocument/completion response missing required field: isIncomplete'.",
    "estimated_token_reduction": "~300-500 tokens per handler implementation. Eliminates back-and-forth with editor clients to debug protocol issues."
  },
  {
    "id": "module-exports-declare-workaround",
    "title": "gerbil_module_exports should handle modules with (declare ...) forms",
    "description": "gerbil_module_exports fails on modules that use Gambit's (declare (block) (standard-bindings) (extended-bindings) ...) form. The error is a Syntax Error: \"Bad syntax; illegal expression\" during expansion. This affects modules like :ober/oberlib and likely other packages that use Gambit performance declarations. The tool should either handle these declarations gracefully or fall back to scanning the compiled .scm files for exported symbols.",
    "impact": "medium",
    "tags": [
      "module",
      "exports",
      "declare",
      "gambit",
      "introspection"
    ],
    "use_case": "When trying to introspect third-party modules (like oberlib) that use Gambit-specific (declare ...) forms to check what functions they export.",
    "example_scenario": "User calls gerbil_module_exports with module_path ':ober/oberlib'. The tool fails with: Syntax Error: Bad syntax; illegal expression — (declare (block) (standard-bindings) (extended-bindings) (inlining-limit 200)). The user must fall back to manually grepping compiled .scm files in .gerbil/lib/static/ to find exported symbols, which is tedious and error-prone.",
    "estimated_token_reduction": "~500-1000 tokens per session where a (declare)-using module needs introspection. Eliminates manual grep + read of compiled artifacts."
  },
  {
    "id": "swagger-to-gerbil-scaffold",
    "title": "Generate Gerbil REST API client from Swagger/OpenAPI spec",
    "description": "A tool that reads a Swagger/OpenAPI JSON spec and generates Gerbil Scheme source code for a REST API client. For each endpoint, it would generate a function with the correct path, HTTP method, path parameters, query parameters, and request body structure. This would dramatically accelerate building API clients like gerbil-jira, where the Jira API has 597 endpoints across 97 groups. Currently, each endpoint must be manually translated from the spec to Scheme code, which is tedious and error-prone.",
    "impact": "high",
    "tags": [
      "swagger",
      "openapi",
      "api",
      "client",
      "scaffold",
      "generate",
      "rest"
    ],
    "use_case": "When building a Gerbil REST API client for a service that publishes a Swagger/OpenAPI spec (Jira, GitHub, AWS, etc.), generate the boilerplate API functions automatically instead of hand-coding each endpoint.",
    "example_scenario": "User has a swagger-v3.json with 597 Jira endpoints. They call gerbil_swagger_scaffold with the spec path and output directory. The tool generates Gerbil source files grouped by API tag (issues.ss, projects.ss, etc.) with a function per endpoint, correct parameter names, and proper HTTP method calls. The user then just needs to add formatting/CLI logic on top.",
    "estimated_token_reduction": "~10000+ tokens per API client project. Eliminates manually reading the spec and translating hundreds of endpoints to Scheme functions."
  }
]
