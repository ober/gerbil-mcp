[
  {
    "id": "crypto-digest-sha256-md5",
    "title": "Compute SHA256 or MD5 hash of data",
    "tags": [
      "sha256",
      "md5",
      "hash",
      "digest",
      "crypto",
      "checksum",
      "bytes"
    ],
    "imports": [
      ":std/crypto/digest"
    ],
    "code": "(import :std/crypto/digest)\\n\\n;; SHA256 of a u8vector — returns u8vector\\n(def hash256 (sha256 #u8(104 101 108 108 111)))\\n\\n;; SHA256 of a string (convert to bytes first)\\n(def hash256-str (sha256 (string->bytes \\\"hello\\\")))\\n\\n;; MD5 of bytes — returns u8vector\\n(def hash-md5 (md5 (string->bytes \\\"hello\\\")))\\n\\n;; To get hex string, combine with :std/text/hex\\n(import :std/text/hex)\\n(hex-encode (sha256 (string->bytes \\\"hello\\\")))\\n;; => \\\"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\\\"",
    "notes": "sha256 and md5 each take a single u8vector argument and return a u8vector. Other available digests: sha1, sha384, sha512, ripemd160, blake2s256, blake2b512. All from :std/crypto/digest.",
    "related": [
      "base64-encode-decode"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "base64-encode-decode",
    "title": "Base64 encode and decode data",
    "tags": [
      "base64",
      "encode",
      "decode",
      "bytes",
      "string",
      "u8vector",
      "binary"
    ],
    "imports": [
      ":std/text/base64"
    ],
    "code": "(import :std/text/base64)\\n\\n;; Encode u8vector to base64 string\\n(u8vector->base64-string (string->bytes \\\"hello\\\"))\\n;; => \\\"aGVsbG8=\\\"\\n\\n;; Decode base64 string to u8vector\\n(base64-string->u8vector \\\"aGVsbG8=\\\")\\n;; => #u8(104 101 108 108 111)\\n\\n;; Encode/decode raw strings\\n(base64-encode \\\"hello\\\")\\n;; => \\\"aGVsbG8=\\\"\\n(base64-decode \\\"aGVsbG8=\\\")\\n;; => \\\"hello\\\"",
    "notes": "u8vector->base64-string and base64-string->u8vector work with binary data. base64-encode and base64-decode work with strings. Useful for HTTP headers like Content-MD5 which require base64-encoded digests.",
    "related": [
      "crypto-digest-sha256-md5"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "deferror-class-defraise",
    "title": "Define error class with deferror-class and defraise/context",
    "tags": [
      "error",
      "exception",
      "deferror",
      "defraise",
      "custom",
      "raise",
      "class",
      "context"
    ],
    "imports": [
      ":std/error"
    ],
    "code": "(import :std/error)\\n\\n;; Define an error class (creates predicate automatically)\\n(deferror-class (MyServiceError Error) () my-service-error?)\\n\\n;; Define a raise helper with automatic 'where' context\\n(defraise/context (raise-my-error where message irritants ...)\\n  (MyServiceError message irritants: [irritants ...]))\\n\\n;; Usage — 'where' is automatically set to the calling function name\\n(def (connect host port)\\n  (unless host\\n    (raise-my-error connect \\\"host is required\\\" \\\"host\\\"))\\n  ...)\\n\\n;; Catch it\\n(try (connect #f 80)\\n  (catch (my-service-error? e)\\n    (displayln \\\"Service error: \\\" (error-message e))))",
    "notes": "deferror-class is more concise than defstruct for error types — it automatically inherits Error fields (message, irritants, where). defraise/context auto-fills the 'where' field. The first arg to defraise/context after 'where' becomes the error message, rest become irritants.",
    "related": [
      "error-handling"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "cli-getopt-subcommands",
    "title": "Build CLI with getopt (v0.19+ API)",
    "tags": [
      "getopt",
      "CLI",
      "command",
      "option",
      "flag",
      "argument",
      "subcommand"
    ],
    "imports": [
      ":std/cli/getopt",
      ":std/sugar"
    ],
    "code": "(import :std/cli/getopt :std/sugar)\n\n;; Simple CLI with options (no subcommands) — handler takes ONE arg:\n(def (main . args)\n  (call-with-getopt\n    (lambda (opt)\n      (let-hash opt\n        (when .?verbose (displayln \"verbose mode\"))\n        (displayln \"output: \" (or .?output \"default.txt\"))))\n    args\n    program: \"my-tool\"\n    help: \"My CLI tool\"\n    (flag 'verbose \"--verbose\" \"-v\"\n      help: \"Verbose output\")\n    (option 'output \"--output\" \"-o\"\n      help: \"Output file\"\n      default: #f)))\n\n;; CLI with subcommands — handler takes TWO args (cmd opt):\n(def list-cmd\n  (command 'list\n    help: \"List items\"\n    (option 'filter \"--filter\" \"-f\" default: #f help: \"Filter\")))\n\n(def create-cmd\n  (command 'create\n    help: \"Create an item\"\n    (argument 'name help: \"Item name\")))\n\n(def (main . args)\n  (call-with-getopt\n    (lambda (cmd opt)\n      (case cmd\n        ((list)\n         (let-hash opt\n           (displayln \"listing with filter: \" .?filter)))\n        ((create)\n         (let-hash opt\n           (displayln \"creating: \" .name)))))\n    args\n    program: \"my-tool\"\n    help: \"My CLI tool\"\n    list-cmd create-cmd))",
    "notes": "IMPORTANT: In Gerbil v0.19+, call-with-getopt handler signature DIFFERS based on whether subcommands are used. WITHOUT subcommands: handler takes ONE arg (lambda (opt) ...). WITH subcommands (command forms): handler takes TWO args (lambda (cmd opt) ...) where cmd is the command symbol and opt is the options hash. Using (lambda (opt) ...) with subcommands causes \"Wrong number of arguments\" error. For exe builds, the main module MUST have (export main).",
    "related": [
      "let-hash-destructure",
      "getopt-subcommand-handler-two-args"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "srfi19-date-time-format",
    "title": "Date/time formatting with SRFI-19",
    "tags": [
      "date",
      "time",
      "srfi",
      "srfi-19",
      "format",
      "timestamp",
      "iso8601",
      "utc",
      "current"
    ],
    "imports": [
      ":std/srfi/19"
    ],
    "code": "(import :std/srfi/19)\\n\\n;; Current date/time (UTC)\\n(def now (current-date))\\n\\n;; Format as ISO 8601 timestamp\\n(date->string now \\\"~Y~m~dT~H~M~SZ\\\")\\n;; => \\\"20250115T143052Z\\\"\\n\\n;; Format date portion only\\n(date->string now \\\"~Y~m~d\\\")\\n;; => \\\"20250115\\\"\\n\\n;; Format human-readable\\n(date->string now \\\"~Y-~m-~d ~H:~M:~S\\\")\\n;; => \\\"2025-01-15 14:30:52\\\"\\n\\n;; Common format directives:\\n;;   ~Y  4-digit year    ~m  2-digit month   ~d  2-digit day\\n;;   ~H  24-hour hour    ~M  minute          ~S  second\\n;;   ~Z  timezone offset  ~A  weekday name    ~B  month name",
    "notes": "current-date returns UTC. date->string uses SRFI-19 format directives (tilde-based, not strftime). Commonly needed for AWS signature timestamps (yyyyMMddTHHmmssZ format) and date-scoped signing keys (yyyyMMdd).",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "xml-parse-sxml",
    "title": "Parse XML string to SXML",
    "tags": [
      "xml",
      "parse",
      "sxml",
      "markup",
      "html",
      "response",
      "api"
    ],
    "imports": [
      ":std/markup/xml"
    ],
    "code": "(import :std/markup/xml)\\n\\n;; Parse XML string to SXML tree\\n(def sxml\\n  (call-with-input-string\\n    \\\"<root><item>hello</item><item>world</item></root>\\\"\\n    read-xml))\\n;; => (*TOP* (root (item \\\"hello\\\") (item \\\"world\\\")))\\n\\n;; GOTCHA: XML with <?xml ...?> declaration produces a *PI* node\\n(def sxml-with-pi\\n  (call-with-input-string\\n    \\\"<?xml version=\\\\\\\"1.0\\\\\\\" encoding=\\\\\\\"UTF-8\\\\\\\"?><root><item>hello</item></root>\\\"\\n    read-xml))\\n;; => (*TOP* (*PI* xml \\\"version=...\\\") (root (item \\\"hello\\\")))\\n;; Note the *PI* node — you must skip it when searching for the root element!\\n\\n;; Navigate SXML — it's just nested lists\\n;; (tag child1 child2 ...) where children are strings or nested tags\\n(def root (cadr sxml))    ;; skip *TOP*, get (root ...)\\n(def items (cdr root))    ;; get children: ((item \\\"hello\\\") (item \\\"world\\\"))\\n(def first-text (cadar items))  ;; => \\\"hello\\\"",
    "notes": "read-xml from :std/markup/xml returns SXML (S-expression XML). It takes a single port argument. The result is always wrapped in (*TOP* ...). IMPORTANT: When the XML source has a <?xml ...?> processing instruction, a (*PI* xml ...) node appears in the SXML tree — you must skip it (along with @ and *NAMESPACES*) when traversing to find the root element, or it will be mistaken for the content root. See the sxml-skip-pi-nodes recipe for a correct traversal pattern. Use cadr to skip *TOP*, then navigate with car/cdr/assoc.",
    "related": [
      "sxml-skip-pi-nodes"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "using-typed-struct-access",
    "title": "Typed struct field access with using macro",
    "tags": [
      "using",
      "struct",
      "typed",
      "access",
      "field",
      "slot",
      "dot",
      "optimize",
      "defstruct"
    ],
    "imports": [],
    "code": "(defstruct point (x y) final: #t)\\n(defstruct (point3d point) (z) final: #t)\\n\\n;; using gives typed access — dot notation without dynamic dispatch\\n(def (distance p1 p2)\\n  (using ((p1 :- point) (p2 :- point))\\n    (sqrt (+ (expt (- p1.x p2.x) 2)\\n             (expt (- p1.y p2.y) 2)))))\\n\\n(distance (make-point 0 0) (make-point 3 4))  ;; => 5.0\\n\\n;; Single binding form\\n(def (describe-point p)\\n  (using (p :- point)\\n    (format \\\"(~a, ~a)\\\" p.x p.y)))\\n\\n;; Works with mutation too\\n(def (move-point! p dx dy)\\n  (using (p :- point)\\n    (set! p.x (+ p.x dx))\\n    (set! p.y (+ p.y dy))))",
    "notes": "using provides typed struct access that compiles to direct field access (no hash-table lookup). Use with defstruct types. The :- annotation is a type declaration. Pair with final: #t on defstruct for best optimization. Unlike (@ obj slot), using is compile-time checked.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "let-hash-destructure",
    "title": "Destructure hash tables with let-hash",
    "tags": [
      "let-hash",
      "hash",
      "destructure",
      "sugar",
      "optional",
      "field",
      "config",
      "options"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": "(import :std/sugar)\\n\\n(def config (hash (name \\\"app\\\") (port 8080) (debug #f)))\\n\\n(let-hash config\\n  ;; .field — required (hash-ref with symbol key, error if missing)\\n  (displayln \\\"name: \\\" .name)\\n\\n  ;; .?field — optional (hash-get, returns #f if missing)\\n  (when .?debug\\n    (displayln \\\"debug mode\\\"))\\n\\n  ;; Use .?field with defaults via 'or'\\n  (def timeout (or .?timeout 30))\\n  (displayln \\\"port: \\\" .port \\\" timeout: \\\" timeout))\\n\\n;; With string keys, use .$field\\n(def headers (hash (\\\"Content-Type\\\" \\\"text/html\\\") (\\\"X-Custom\\\" \\\"val\\\")))\\n(let-hash headers\\n  (displayln .$Content-Type))  ;; uses string key \\\"Content-Type\\\"",
    "notes": "let-hash is from :std/sugar. Three accessor forms: .field (symbol key, required — errors if missing), .?field (symbol key, optional — returns #f), .$field (string key, optional). Very useful for CLI option hashes from getopt and API response hashes. Nests well — (let-hash outer (let-hash .inner-hash ...)).",
    "related": [
      "cli-getopt-subcommands"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "parse-ini-file",
    "title": "Parse INI/config file into nested hash tables",
    "tags": [
      "ini",
      "config",
      "parse",
      "file",
      "section",
      "profile",
      "aws",
      "credentials",
      "settings"
    ],
    "imports": [
      ":std/sugar",
      ":std/srfi/13"
    ],
    "code": "(import :std/sugar (only-in :std/srfi/13 string-trim-both string-prefix? string-index))\\n\\n;; Parse INI file into hash of sections, each section is a hash of key=value\\n(def (parse-ini-file path)\\n  (let ((result (make-hash-table))\\n        (current-section #f))\\n    (when (file-exists? path)\\n      (call-with-input-file path\\n        (lambda (port)\\n          (let loop ()\\n            (let (line (read-line port))\\n              (unless (eof-object? line)\\n                (let (trimmed (string-trim-both line))\\n                  (cond\\n                    ((or (equal? trimmed \\\"\\\") (string-prefix? \\\"#\\\" trimmed)\\n                         (string-prefix? \\\";\\\" trimmed))\\n                     (void))  ;; skip blank/comment lines\\n                    ((and (string-prefix? \\\"[\\\" trimmed))\\n                     (let (end (string-index trimmed #\\\\]))\\n                       (when end\\n                         (set! current-section (substring trimmed 1 end))\\n                         (unless (hash-key? result current-section)\\n                           (hash-put! result current-section (make-hash-table))))))\\n                    (else\\n                     (when current-section\\n                       (let (eq-pos (string-index trimmed #\\\\=))\\n                         (when eq-pos\\n                           (let ((key (string-trim-both (substring trimmed 0 eq-pos)))\\n                                 (val (string-trim-both (substring trimmed (+ eq-pos 1)\\n                                                          (string-length trimmed)))))\\n                             (hash-put! (hash-ref result current-section) key val))))))))\\n                (loop)))))))\\n    result))\\n\\n;; Usage:\\n;; (def config (parse-ini-file \\\"~/.aws/credentials\\\"))\\n;; (hash-ref (hash-ref config \\\"default\\\") \\\"aws_access_key_id\\\")",
    "notes": "Handles [section] headers, key=value pairs, blank lines, and # or ; comments. Returns a hash of hashes: outer keys are section names, inner keys are setting names. Useful for parsing AWS credentials/config files, .gitconfig, and similar INI-style configs. Uses string-trim-both and string-index from :std/srfi/13.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "http-post-form-encoded",
    "title": "HTTP POST with form-url-encoded body",
    "tags": [
      "http",
      "post",
      "form",
      "urlencoded",
      "uri",
      "encode",
      "request",
      "api",
      "query"
    ],
    "imports": [
      ":std/net/request",
      ":std/net/uri"
    ],
    "code": "(import :std/net/request :std/net/uri)\\n\\n;; Build form-encoded body from alist of (key . value) pairs\\n(def params '((\\\"Action\\\" . \\\"DescribeInstances\\\")\\n              (\\\"Version\\\" . \\\"2016-11-15\\\")\\n              (\\\"MaxResults\\\" . \\\"10\\\")))\\n\\n(def body (form-url-encode params))\\n;; => \\\"Action=DescribeInstances&Version=2016-11-15&MaxResults=10\\\"\\n\\n;; POST with form-encoded body\\n(def resp (http-post \\\"https://api.example.com/\\\"\\n            data: body\\n            headers: '((\\\"Content-Type\\\" . \\\"application/x-www-form-urlencoded\\\"))))\\n\\n(request-status resp)   ;; HTTP status code\\n(request-text resp)     ;; response body as string\\n(request-close resp)    ;; release connection",
    "notes": "form-url-encode from :std/net/uri takes an alist of (key . value) string pairs and produces a URL-encoded query string. This is the standard format for AWS Query API services (EC2, STS, IAM, SNS, CloudFormation). Always call request-close after reading the response to release the connection.",
    "related": [
      "http-get",
      "http-post-json"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "sigv4-aws-request-signing",
    "title": "AWS SigV4 request signing",
    "tags": [
      "aws",
      "sigv4",
      "signing",
      "signature",
      "authentication",
      "s3",
      "ec2",
      "request",
      "api"
    ],
    "imports": [
      ":std/net/s3/sigv4",
      ":std/crypto/digest",
      ":std/text/hex",
      ":std/srfi/19",
      ":std/net/request"
    ],
    "code": "(import :std/net/s3/sigv4 :std/crypto/digest :std/text/hex\\n        :std/srfi/19 :std/net/request)\\n\\n;; Prepare timestamp and scope\\n(def now (current-date))\\n(def ts (date->string now \\\"~Y~m~dT~H~M~SZ\\\"))     ;; e.g. \\\"20250115T143052Z\\\"\\n(def scopets (date->string now \\\"~Y~m~d\\\"))           ;; e.g. \\\"20250115\\\"\\n(def scope (string-append scopets \\\"/us-east-1/sts\\\")) ;; date/region/service\\n\\n;; Build headers list as alist with :: syntax\\n(def body-bytes (string->bytes \\\"Action=GetCallerIdentity&Version=2011-06-15\\\"))\\n(def body-hash (sha256 body-bytes))\\n(def host \\\"sts.amazonaws.com\\\")\\n(def headers [[\\\"Host\\\" :: host]\\n              [\\\"x-amz-date\\\" :: ts]\\n              [\\\"Content-Type\\\" :: \\\"application/x-www-form-urlencoded\\\"]])\\n\\n;; Create canonical request\\n(def creq (aws4-canonical-request\\n             verb: 'POST uri: \\\"/\\\" query: #f\\n             headers: headers hash: body-hash))\\n\\n;; Generate Authorization header\\n(def auth (aws4-auth scope creq ts headers\\n                     \\\"SECRET_KEY\\\" \\\"ACCESS_KEY\\\"))\\n\\n;; Make the signed request\\n(def signed-headers (cons [\\\"Authorization\\\" :: auth] headers))\\n(def resp (http-post (string-append \\\"https://\\\" host \\\"/\\\")\\n            headers: signed-headers\\n            data: (bytes->string body-bytes)))",
    "notes": "aws4-canonical-request and aws4-auth are from :std/net/s3/sigv4 (works for ALL AWS services, not just S3). The scope format is \\\"YYYYMMDD/region/service\\\". Headers must be an alist with [key :: value] pairs. body-hash is the SHA256 of the request body as a u8vector. For GET requests with no body, use (sha256 #u8()) for the hash.",
    "related": [
      "http-post-form-encoded",
      "crypto-digest-sha256-md5",
      "srfi19-date-time-format"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "hash-table-basics",
    "title": "Hash table operations",
    "tags": [
      "hash",
      "table",
      "get",
      "ref",
      "put",
      "key",
      "remove",
      "lookup",
      "default"
    ],
    "imports": [],
    "code": "(def ht (hash (\"name\" \"alice\") (\"age\" 30)))   ;; literal syntax\n(hash-ref ht \"name\")          ;; => \"alice\" (error if missing)\n(hash-ref ht \"missing\" 42)    ;; => 42 (hash-ref takes optional 3rd arg default)\n(hash-get ht \"name\")          ;; => \"alice\" (returns #f if missing)\n;; IMPORTANT: hash-get takes EXACTLY 2 args (table, key). Returns #f if missing.\n;; For a default value, use hash-ref with 3 args: (hash-ref ht key default)\n(hash-put! ht \"email\" \"a@b\")  ;; mutate\n(hash-key? ht \"name\")         ;; => #t\n(hash-remove! ht \"age\")\n(hash->list ht)               ;; => ((\"name\" . \"alice\") ...)\n\n;; Multi-arity wrapper if you want hash-get with defaults:\n(def* hget\n  ((ht key) (hash-get ht key))\n  ((ht key default) (hash-ref ht key default)))",
    "notes": "CRITICAL: hash-get is STRICTLY 2-arity in Gerbil. (hash-get ht key default) is WRONG and will error. Use hash-ref for 3-arg lookups with a default. The hget wrapper pattern (using def*) provides a convenient multi-arity alternative. Use (hash ...) for string keys, (hash-eq ...) for symbol keys.",
    "related": [
      "iterate-hash",
      "hash-table-merge"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "exe-build-static-modules",
    "title": "Build statically-linked executable with dependencies",
    "tags": [
      "exe",
      "build",
      "static",
      "link",
      "binary",
      "executable",
      "release",
      "defbuild-script"
    ],
    "imports": [
      ":std/build-script"
    ],
    "code": ";; build.ss — with exe target\n#!/usr/bin/env gxi\n(import :std/build-script)\n(defbuild-script\n  '(\"module-a\"\n    \"module-b\"\n    (exe: \"main\" bin: \"my-app\")))\n\n;; REQUIREMENTS for exe linking:\n;; 1. The main module MUST export its main function:\n;;    (export main)\n;;\n;; 2. All dependencies must have static modules (.scm files in static/ dir).\n;;    Build dependencies with --release:\n;;      cd /path/to/dependency && gerbil build --release\n;;\n;; 3. GERBIL_LOADPATH must include the dependency's .gerbil/lib/ directory\n;;    so the linker can find static modules:\n;;      GERBIL_LOADPATH=/path/to/dep/.gerbil/lib gerbil build --release\n;;\n;; 4. Build YOUR project with --release too:\n;;      gerbil build --release",
    "notes": "Common errors: (1) \"cannot find static module foo__bar.scm\" — the dependency wasn't built with --release, or its .gerbil/lib/ isn't in GERBIL_LOADPATH. (2) \"module does not export symbol: main\" — add (export main) to the main module. (3) Linker warnings about dlopen/getaddrinfo are harmless for static Gambit binaries. The resulting binary is fully self-contained and doesn't need Gerbil installed to run.",
    "related": [
      "cli-getopt-subcommands"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "export-t-does-not-reexport-imports",
    "title": "(export #t) does NOT re-export imported symbols",
    "tags": [
      "export",
      "import",
      "re-export",
      "module",
      "gotcha",
      "transitive"
    ],
    "imports": [],
    "code": ";; Module A (a.ss) — imports and re-exports\n(import :some-library/foo)  ;; provides make-foo\n(export #t)\n\n(def (helper x) (make-foo x))  ;; make-foo is usable here\n\n;; Module B (b.ss) — imports Module A\n(import ./a)\n\n;; (make-foo 42)  ;; ERROR: make-foo is NOT available!\n;; (export #t) only exports symbols DEFINED in the module,\n;; not symbols imported from other modules.\n\n;; WORKAROUND 1: Import the library directly in Module B\n(import :some-library/foo)  ;; now make-foo is available\n\n;; WORKAROUND 2: Explicitly re-export in Module A\n;; (export (import: :some-library/foo))  ;; re-exports foo's bindings",
    "notes": "In Gerbil, (export #t) exports all bindings DEFINED in the current module's scope, but does NOT transitively re-export symbols imported from other modules. If module A imports :lib/foo and uses (export #t), module B importing A will NOT get :lib/foo's symbols. Module B must import :lib/foo directly, or module A must use (export (import: :lib/foo)) for explicit re-export. This is a common source of \"Reference to unbound identifier\" errors when refactoring.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "cons-pair-in-bracket-list-gotcha",
    "title": "Dotted pair syntax inside [] is a function call, not a cons pair",
    "tags": [
      "cons",
      "pair",
      "list",
      "bracket",
      "dotted",
      "gotcha",
      "alist",
      "dimensions"
    ],
    "imports": [],
    "code": ";; WRONG: Dotted pair syntax with a variable inside [] list sugar\n;; This is interpreted as calling \"Key\" as a function with value as arg!\n(def key-name \"MyKey\")\n;; [(\"Key\" . key-name)]  ;; ERROR: Bad syntax; invalid match target\n;; Expands to (@list (\"Key\" . key-name)) where (\"Key\" . key-name)\n;; is treated as (%%app \"Key\" . key-name) — a function application.\n\n;; CORRECT: Use (cons ...) to build pairs with variables\n[(cons \"Key\" key-name)]        ;; => ((\"Key\" . \"MyKey\"))\n\n;; Literal dotted pairs (both sides are constants) work inside quote:\n'((\"Key\" . \"literal-value\"))   ;; OK — quoted datum\n\n;; Common use case: building alists for AWS API dimensions\n(def instance-id \"i-abc123\")\n;; Wrong:  dimensions: [(\"InstanceId\" . instance-id)]\n;; Right:  dimensions: [(cons \"InstanceId\" instance-id)]\n\n;; Multiple pairs:\n(def name \"my-func\")\n(def dims [(cons \"FunctionName\" name)\n           (cons \"Resource\" \"my-resource\")])\n;; => ((\"FunctionName\" . \"my-func\") (\"Resource\" . \"my-resource\"))",
    "notes": "In Gerbil, [x y z] is sugar for (@list x y z). Each element is an expression. The syntax (\"Key\" . var) in expression position is NOT a cons pair — it's a function application where \"Key\" is the operator. This causes \"Bad syntax; invalid match target\" or similar errors. Use (cons \"Key\" var) instead. Literal pairs work fine inside quote: '((\"k\" . \"v\")). This commonly bites when building alists (e.g., AWS API dimension parameters) where keys are string literals but values are variables.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gerbil-build-loadpath-for-packages",
    "title": "gerbil build needs GERBIL_LOADPATH to find installed packages",
    "tags": [
      "build",
      "GERBIL_LOADPATH",
      "package",
      "import",
      "cannot find",
      "library module",
      "Makefile"
    ],
    "imports": [],
    "code": ";; If your project imports a third-party package installed via gerbil pkg:\n;; (import :my-library/module)\n;;\n;; Running bare `gerbil build` may fail with:\n;;   Syntax Error: cannot find library module\n;;   form: :my-library/module\n;;\n;; The fix: set GERBIL_LOADPATH to include ~/.gerbil/lib\n;;\n;; Option 1: Shell environment variable\n;; $ GERBIL_LOADPATH=~/.gerbil/lib gerbil build\n;;\n;; Option 2: Makefile (recommended for projects)\n;; ------- Makefile -------\n;; GERBIL_PATH = $(HOME)/.gerbil\n;; export GERBIL_LOADPATH = $(GERBIL_PATH)/lib\n;;\n;; build:\n;; \tgerbil build\n;;\n;; clean:\n;; \tgerbil clean\n;; ------- end -------\n;;\n;; Note: gxi (the REPL) finds packages without GERBIL_LOADPATH,\n;; but the build subprocess spawned by `gerbil build` does not.\n;; This is a common source of confusion when imports work in gxi\n;; but fail during compilation.",
    "notes": "The gerbil build command spawns a subprocess to compile, and that subprocess does not inherit the default package search paths that gxi uses. You must explicitly set GERBIL_LOADPATH=$HOME/.gerbil/lib (or wherever packages are installed). A Makefile with `export GERBIL_LOADPATH` is the standard pattern. This explains why `gxi -e '(import :pkg/mod)'` works but `gerbil build` fails with \"cannot find library module\".",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gerbil-aws-query-vs-json-response-keys",
    "title": "gerbil-aws Query API vs JSON API response key differences",
    "tags": [
      "gerbil-aws",
      "query",
      "json",
      "XML",
      "symbol",
      "string",
      "keys",
      "AWS",
      "migration",
      "CloudWatch",
      "RDS",
      "ELBv2"
    ],
    "imports": [],
    "code": ";; gerbil-aws has two API protocols with DIFFERENT response formats:\n;;\n;; 1. Query API (XML): EC2, STS, IAM, CloudWatch, RDS, ELBv2, SNS, SQS, CloudFormation\n;;    - Keys are SYMBOLS: 'Average, 'InstanceId, 'DBInstanceIdentifier\n;;    - Values are STRINGS (from XML text): \"30.5\", \"true\", \"i-abc123\"\n;;    - Lists use {member: [...]} wrapper from XML <member> elements\n;;    - Booleans are strings: \"true\" / \"false\"\n;;\n;; 2. JSON API: Lambda, CloudWatch Logs, DynamoDB, Compute Optimizer, Cost Optimization Hub\n;;    - Keys are STRINGS: \"Average\", \"instanceId\", \"functionName\"\n;;    - Values are TYPED: 30.5 (number), #t (boolean), \"i-abc123\" (string)\n;;    - Lists are plain lists (JSON arrays)\n;;    - Booleans are #t / #f\n;;\n;; When migrating from AWS CLI (JSON output) to native Query API:\n;;   (hget resp \"Datapoints\")          ;; CLI: string key, list value\n;;   ;; becomes:\n;;   ;; get-metric-statistics returns the list directly (no wrapper key)\n;;\n;;   (hget dp \"Average\")               ;; CLI: string key, number value\n;;   ;; becomes:\n;;   (safe-number (hash-ref dp 'Average #f) 0)  ;; Query: symbol key, STRING value\n;;\n;; When migrating from AWS CLI to native JSON API:\n;;   (hget resp \"Functions\")           ;; CLI: string key, list value\n;;   ;; stays the same — JSON API matches CLI output format\n;;\n;; IMPORTANT: Query API numeric values MUST be converted with string->number\n;; or a safe-number wrapper. They come back as strings like \"30.5\" not 30.5.",
    "notes": "This is the most common source of bugs when migrating from AWS CLI calls to native gerbil-aws. Query API services return symbol keys and string values from XML parsing, while JSON API services return string keys and typed values (matching CLI output). Always use hash-ref with symbol keys ('Key) for Query API responses, and convert numeric strings with string->number or a safe wrapper.",
    "related": [
      "http-post-form-encoded",
      "parse-xml-to-sxml"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "extract-member-list-xml-normalization",
    "title": "Normalize XML member-list structures from gerbil-aws Query API",
    "tags": [
      "gerbil-aws",
      "XML",
      "member",
      "list",
      "normalize",
      "query",
      "API",
      "dimensions",
      "CloudWatch"
    ],
    "imports": [],
    "code": ";; AWS Query API XML uses <member> elements for lists:\n;;   <Dimensions>\n;;     <member><Name>InstanceId</Name><Value>i-abc</Value></member>\n;;     <member><Name>ImageId</Name><Value>ami-xyz</Value></member>\n;;   </Dimensions>\n;;\n;; After sxml->hash parsing, this becomes different structures depending\n;; on the number of <member> elements:\n;;\n;;   Single member:  {member: {Name: \"InstanceId\", Value: \"i-abc\"}}\n;;   Multiple:       {member: [{Name: \"InstanceId\", ...}, {Name: \"ImageId\", ...}]}\n;;   Empty:          #f or missing key\n;;\n;; Use this helper to normalize to a plain list in all cases:\n\n(def (extract-member-list raw)\n  \"Normalize XML member-list to a plain list.\n   Handles: #f -> [], list -> list, {member: list} -> list,\n            {member: hash} -> [hash], string -> [string]\"\n  (cond\n    ((not raw) [])\n    ((list? raw) raw)\n    ((hash-table? raw)\n     (let ((m (hash-get raw 'member)))\n       (cond\n         ((list? m) m)\n         ((not m) [])\n         (else [m]))))          ;; single member: wrap in list\n    (else [])))\n\n;; Example: extracting CloudWatch dimensions from list-metrics response\n;; (def metric (car (list-metrics cw metric-name: \"CPUUtilization\" ...)))\n;; (def dims-raw (hash-ref metric 'Dimensions #f))\n;; (def dims (extract-member-list dims-raw))\n;; ;; dims is now always a list of hashes with 'Name and 'Value keys\n;; (def dims-alist\n;;   (map (lambda (d) (cons (hash-ref d 'Name \"\") (hash-ref d 'Value \"\")))\n;;        dims))",
    "notes": "The gerbil-aws Query API functions like cw-action/items extract the outer member list, but inner nested member-list structures (e.g., Dimensions within a Metric) remain in raw XML-parsed form. This helper normalizes the three possible shapes (single hash, list of hashes, or #f) into a consistent list. Essential when processing CloudWatch list-metrics dimensions, IAM policy documents, or any Query API response with nested lists.",
    "related": [
      "gerbil-aws-query-vs-json-response-keys"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "sxml-skip-pi-nodes",
    "title": "Skip *PI* processing instruction nodes when traversing SXML",
    "tags": [
      "sxml",
      "xml",
      "parsing",
      "processing-instruction",
      "PI",
      "read-xml",
      "traverse",
      "gotcha",
      "*PI*",
      "*TOP*"
    ],
    "imports": [
      ":std/markup/xml"
    ],
    "code": "\n(import :std/markup/xml)\n\n;; XML responses often start with <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n;; read-xml parses this into a *PI* (Processing Instruction) SXML node:\n;;\n;;   (*TOP*\n;;     (@ (*NAMESPACES* ...))\n;;     (*PI* xml \"version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"\")   ;; <-- gotcha!\n;;     (ns:RootElement ...))\n;;\n;; When traversing SXML to find the root element, you MUST skip *PI* nodes\n;; along with @, *NAMESPACES*, and *TOP*. Otherwise *PI* gets mistakenly\n;; treated as the root element.\n\n;; WRONG — misses *PI*, returns wrong node:\n(def (find-root-BAD xml)\n  (let find ((node xml))\n    (cond\n      ((not (pair? node)) #f)\n      ((memq (car node) '(@ *NAMESPACES*)) #f)        ;; missing *PI*!\n      ((not (eq? (car node) '*TOP*)) node)\n      (else (ormap find (cdr node))))))\n\n;; CORRECT — skips *PI* nodes:\n(def (find-root-GOOD xml)\n  (let find ((node xml))\n    (cond\n      ((not (pair? node)) #f)\n      ((memq (car node) '(@ *NAMESPACES* *PI*)) #f)   ;; includes *PI*\n      ((not (eq? (car node) '*TOP*)) node)\n      (else (ormap find (cdr node))))))\n\n;; Example: parsing an S3 response with XML declaration\n(def xml (read-xml\n           \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><Root><Item>hello</Item></Root>\"\n           namespaces: '()))\n\n(find-root-BAD xml)   ;; => (*PI* xml \"version=\\\"1.0\\\" ...\") — WRONG!\n(find-root-GOOD xml)  ;; => (Root (Item \"hello\")) — correct\n",
    "notes": "The *PI* node appears in SXML when the source XML contains processing instructions like <?xml ...?>. Most real-world XML APIs (AWS S3, etc.) include this declaration. The SXML metadata nodes to always skip when searching for content elements are: *TOP* (document root wrapper), @ (attributes), *NAMESPACES* (namespace declarations), and *PI* (processing instructions). Forgetting *PI* causes silent data loss — the PI node gets processed as if it were the root element, typically producing an empty string or #f instead of the expected parsed data.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "stale-global-static-files-segfault",
    "title": "Stale global static files cause segfaults in compiled binaries",
    "tags": [
      "segfault",
      "static",
      "linking",
      "build",
      "stale",
      "global",
      "GERBIL_LOADPATH",
      "ABI",
      "mismatch",
      "crash",
      "exe"
    ],
    "imports": [],
    "code": ";; PROBLEM: Compiled binary segfaults but code works fine in gxi REPL.\n;;\n;; ROOT CAUSE: Stale static files (.scm, .c, .o) in ~/.gerbil/lib/static/\n;; shadow locally compiled versions. When GERBIL_LOADPATH includes\n;; ~/.gerbil/lib BEFORE the local project path, the exe linker picks up\n;; the old global .o files instead of the current local ones.\n;;\n;; This causes ABI mismatches: e.g., cost-explorer calls\n;;   aws-billing/aws#first-of-month-string__%  (new split variant)\n;; but the stale global aws module only defines\n;;   aws-billing/aws#first-of-month-string     (old monolithic variant)\n;; Calling an undefined symbol → SIGSEGV.\n;;\n;; HOW STALE FILES GET THERE:\n;; - Running `gerbil build` or `gxpkg build` from within a project\n;;   that has its .gerbil/lib/ in GERBIL_LOADPATH\n;; - A previous `gerbil pkg install` of the package\n;; - Manually copying build artifacts\n;;\n;; DIAGNOSIS:\n;; 1. Check for duplicate static files:\n;;    find ~/.gerbil/lib -name 'YOURPKG__*.scm' -o -name 'YOURPKG__*.o'\n;;\n;; 2. Compare with local project files:\n;;    ls -la ~/.gerbil/lib/static/YOURPKG__module.scm   # stale (old timestamp)\n;;    ls -la ./project/.gerbil/lib/static/YOURPKG__module.scm  # current\n;;\n;; 3. Check build output: if BOTH paths appear during exe compilation,\n;;    the global one may win.\n;;\n;; FIX:\n;; Remove ALL stale global artifacts (.scm, .c, .o, .ssi):\n;;   rm -rf ~/.gerbil/lib/YOURPKG/\n;;   rm -f  ~/.gerbil/lib/static/YOURPKG__*.scm\n;;   rm -f  ~/.gerbil/lib/static/YOURPKG__*.c\n;;   rm -f  ~/.gerbil/lib/static/YOURPKG__*.o\n;;\n;; Then clean rebuild:\n;;   make clean && make build\n;;\n;; IMPORTANT: `gerbil clean` only removes LOCAL .gerbil/ artifacts.\n;; It does NOT clean ~/.gerbil/lib/. You must manually remove stale\n;; global files. Also note: removing just .scm files is NOT enough —\n;; the linker uses the .o files directly if they exist.",
    "notes": "The Gerbil compiler may change how optional-arg functions are compiled across versions (monolithic closure vs split __%/__0 variants). If global static files are from an older compilation, the ABI won't match modules compiled with the current compiler. The segfault typically occurs at the call site in `(declare (not safe))` blocks where the undefined function symbol resolves to null/garbage. The `strings` command won't find Gerbil string literals in compiled binaries (they're stored as Gambit string objects, not C strings), so use `grep` on the `.scm` static files to verify which version the linker uses.",
    "related": [
      "static-exe-with-deps",
      "gerbil-build-loadpath"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "debug-compiled-only-segfault",
    "title": "Debug segfaults that only occur in compiled binaries (not REPL)",
    "tags": [
      "debug",
      "segfault",
      "compiled",
      "binary",
      "REPL",
      "gdb",
      "static",
      "linking",
      "crash"
    ],
    "imports": [],
    "code": ";; When code works in gxi but segfaults as a compiled binary:\n;;\n;; STEP 1: Test in REPL to confirm the logic is correct\n;;   echo '(import :mymodule) (my-function args)' | \\\n;;     GERBIL_LOADPATH=... gxi\n;;\n;; STEP 2: Add debug displayln/force-output INSIDE the crashing function\n;;   (def (my-function arg)\n;;     (displayln \"[dbg] entering\") (force-output)\n;;     (let ((x (step-1)))\n;;       (displayln \"[dbg] step-1 ok\") (force-output)\n;;       ...))\n;;\n;; STEP 3: Rebuild and check if debug output appears in binary\n;;   ;; Gerbil string literals are NOT plain C strings in the binary.\n;;   ;; Check the static .scm file instead:\n;;   grep 'dbg' .gerbil/lib/static/YOURPKG__module.scm\n;;\n;; STEP 4: If debug strings are in .scm but NOT in behavior,\n;;   check for stale global copies shadowing local files:\n;;   find ~/.gerbil/lib -name 'YOURPKG__*' -type f\n;;\n;; STEP 5: Compare compiled function signatures between versions\n;;   ;; Old compilation style (monolithic optional-arg function):\n;;   ;;   (define pkg#my-fn (let ((opt-lambda ...)) (lambda _g_ ...)))\n;;   ;;\n;;   ;; New compilation style (split variants):\n;;   ;;   (define pkg#my-fn__% (lambda (arg) ...))    ; implementation\n;;   ;;   (define pkg#my-fn__0 (lambda () ...))        ; zero-arg wrapper\n;;   ;;   (define pkg#my-fn (lambda _g_ (cond ...)))   ; dispatch\n;;   ;;\n;;   ;; If caller uses my-fn__% but linked module only defines my-fn,\n;;   ;; the symbol is undefined → segfault in (declare (not safe)) context.\n;;\n;; STEP 6: GDB can identify the hosting function but not the exact line:\n;;   ;; ___H_pkg____module is Gambit's C hosting function for the module.\n;;   ;; All compiled Scheme code for that module lives inside this one\n;;   ;; C function, so the crash address isn't very informative.\n;;   ;; Use debug displayln to narrow down instead.",
    "notes": "Key insight: in compiled Gerbil binaries with (declare (not safe)), calling an undefined/unresolved symbol doesn't raise a Scheme exception — it causes a raw SIGSEGV because the null function pointer is called without any safety checks. The REPL doesn't have this problem because it resolves symbols dynamically. Also: `gerbil clean` does NOT remove ~/.gerbil/lib/ artifacts — only local .gerbil/ files.",
    "related": [
      "stale-global-static-files-segfault",
      "static-exe-with-deps"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "srfi-19-current-time-shadows-gambit",
    "title": "SRFI-19 current-time shadows Gambit's current-time (causes time->seconds crash)",
    "tags": [
      "srfi-19",
      "current-time",
      "time",
      "gambit",
      "shadow",
      "time->seconds",
      "mutex",
      "rate-limit",
      "gotcha"
    ],
    "imports": [
      ":std/srfi/19"
    ],
    "code": ";; PROBLEM: Importing :std/srfi/19 shadows Gambit's built-in (current-time).\n;;\n;; Gambit's (current-time) returns a Gambit time object (##type #2 time).\n;; SRFI-19's (current-time) returns an SRFI-19 time object (different type).\n;; Gambit's (time->seconds) only accepts Gambit time objects.\n;;\n;; If you import :std/srfi/19 and then call:\n;;   (time->seconds (current-time))\n;; You get: \"Instance of #<type #2 time> expected\"\n;; because (current-time) now returns SRFI-19 time, but (time->seconds)\n;; expects Gambit time.\n;;\n;; This commonly bites in rate-limiting code, mutex timing, or anywhere\n;; you mix SRFI-19 date formatting with Gambit timing primitives.\n\n;; WRONG — crashes at runtime:\n;; (import :std/srfi/19)\n;; (def (rate-limit!)\n;;   (let ((now (time->seconds (current-time))))  ;; BOOM\n;;     ...))\n\n;; FIX: Use ##current-time to bypass the SRFI-19 shadow:\n(import :std/srfi/19)\n(def (rate-limit!)\n  (let ((now (exact->inexact (time->seconds (##current-time)))))\n    ;; ##current-time always returns Gambit's native time object\n    ;; time->seconds works correctly on it\n    now))\n\n;; ALTERNATIVE: Use SRFI-19's own time conversion instead:\n;; (import :std/srfi/19)\n;; (def (current-seconds)\n;;   (let ((t (current-time)))  ;; SRFI-19 time\n;;     (+ (time-second t)       ;; SRFI-19 accessor\n;;        (/ (time-nanosecond t) 1e9))))",
    "notes": "The ## prefix accesses Gambit's raw (unshadowed) primitives. ##current-time is safe to use even when SRFI-19 is imported. This issue only manifests at runtime — compilation succeeds because both versions of current-time have the same arity. The error message \"Instance of #<type #2 time> expected\" is the key diagnostic clue. Also note: exact->inexact is needed because time->seconds may return an exact rational.",
    "related": [
      "date-time-formatting-srfi-19"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "mutex-unwind-protect-deadlock-prevention",
    "title": "Always wrap mutex-lock!/unlock! with unwind-protect to prevent deadlocks",
    "tags": [
      "mutex",
      "unwind-protect",
      "deadlock",
      "thread",
      "lock",
      "concurrency",
      "exception",
      "safety"
    ],
    "imports": [],
    "code": ";; PROBLEM: If an exception occurs between mutex-lock! and mutex-unlock!,\n;; the mutex stays locked forever, deadlocking all subsequent callers.\n;;\n;; WRONG — deadlocks after first exception:\n;; (def my-lock (make-mutex 'my-lock))\n;; (def (unsafe-operation!)\n;;   (mutex-lock! my-lock)\n;;   (do-something-that-might-throw)  ;; if this throws...\n;;   (mutex-unlock! my-lock))         ;; ...this never runs → deadlock\n\n;; CORRECT — always unlocks, even on exception:\n(def my-lock (make-mutex 'my-lock))\n\n(def (safe-operation!)\n  (mutex-lock! my-lock)\n  (unwind-protect\n    (do-something-that-might-throw)\n    (mutex-unlock! my-lock)))\n\n;; PATTERN: Rate limiter with mutex + timing\n(def _api-lock (make-mutex 'api-lock))\n(def _last-call-time 0.0)\n(defconst API-DELAY 0.1)  ;; 100ms between calls\n\n(def (rate-limit!)\n  (mutex-lock! _api-lock)\n  (unwind-protect\n    (let* ((now (exact->inexact (time->seconds (##current-time))))\n           (elapsed (fl- now _last-call-time)))\n      (when (fl< elapsed API-DELAY)\n        (thread-sleep! (fl- API-DELAY elapsed)))\n      (set! _last-call-time\n        (exact->inexact (time->seconds (##current-time)))))\n    (mutex-unlock! _api-lock)))\n\n;; DIAGNOSTIC: Deadlock symptoms in Gerbil:\n;; - Program hangs after first API error\n;; - GDB backtrace shows ##mutex-lock-out-of-line!\n;; - Error log shows \"Deadlock detected\" with mutex name",
    "notes": "unwind-protect guarantees the cleanup form (mutex-unlock!) runs regardless of whether the body completes normally or throws an exception. This is analogous to try/finally in other languages. Without it, any exception between lock and unlock permanently locks the mutex. This is especially critical in rate-limiting code where API calls may throw network exceptions, timeout errors, or AWS service errors. The deadlock typically manifests on the SECOND call after the first exception.",
    "related": [
      "srfi-19-current-time-shadows-gambit",
      "error-handling"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "error-message-returns-false-for-non-error",
    "title": "error-message returns #f for non-Gerbil-Error exceptions — use display-exception",
    "tags": [
      "error-message",
      "exception",
      "display-exception",
      "error",
      "catch",
      "non-error",
      "gambit",
      "gotcha",
      "exception->string"
    ],
    "imports": [
      ":std/error"
    ],
    "code": ";; PROBLEM: (error-message e) only works for Gerbil Error objects.\n;; For Gambit exceptions, AWS errors, or other non-Error exceptions,\n;; it returns #f — making error messages invisible.\n;;\n;; WRONG — loses error information for non-Error exceptions:\n;; (try (some-operation)\n;;   (catch (e)\n;;     (displayln \"Error: \" (error-message e))))\n;; ;; Prints: \"Error: #f\" for Gambit/AWS exceptions\n\n;; CORRECT — use display-exception which handles ALL exception types:\n(def (exception->string e)\n  \"Convert any exception to a readable string.\"\n  (with-output-to-string (lambda () (display-exception e))))\n\n;; Usage in catch blocks:\n(try (some-operation)\n  (catch (e)\n    (displayln \"Error: \" (exception->string e))))\n\n;; WHY: Gerbil has multiple exception types:\n;; - (Error message irritants where) — Gerbil's own error type\n;;   → (error-message e) works, returns the message string\n;;\n;; - Gambit exceptions (error-exception, type-exception, etc.)\n;;   → (error-message e) returns #f\n;;   → (display-exception e port) works for all types\n;;\n;; - AWS service errors (from gerbil-aws)\n;;   → Usually Gambit error-exception objects\n;;   → (error-message e) returns #f\n;;\n;; display-exception is Gambit's universal exception printer.\n;; It knows how to format ALL exception types including stack traces.",
    "notes": "This is a common gotcha when writing generic error handlers. error-message is defined on the Gerbil Error struct and returns the 'message' slot. But catch (e) catches ALL exceptions, not just Gerbil Errors. Gambit runtime exceptions (type errors, arity errors, I/O errors, network errors) are NOT Gerbil Error objects. The exception->string helper using display-exception is the universal solution. Also: (object->string e) sometimes works but may not include the full formatted error message that display-exception provides.",
    "related": [
      "error-handling",
      "custom-error",
      "deferror-class"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gerbil-json-arrays-are-lists-not-vectors",
    "title": "Gerbil JSON arrays are lists, not vectors — never use (vector? x) to check",
    "tags": [
      "json",
      "vector",
      "list",
      "array",
      "vector?",
      "read-json",
      "gerbil-aws",
      "ensure-list",
      "gotcha",
      "silent-failure"
    ],
    "imports": [
      ":std/text/json"
    ],
    "code": ";; PROBLEM: Gerbil's read-json (and gerbil-aws JSON API responses) return\n;; JSON arrays as Scheme LISTS, not vectors. Code that checks (vector? x)\n;; silently drops all data because (vector? '(1 2 3)) => #f.\n;;\n;; This is a SILENT FAILURE — no error, no exception, just empty results.\n\n;; WRONG — silently discards all JSON array data:\n;; (let ((results (hget resp \"ResultsByTime\")))\n;;   (if (vector? results)          ;; ALWAYS #f for JSON arrays!\n;;     (vector->list results)       ;; never reached\n;;     []))                         ;; always returns empty list\n\n;; WRONG — silently skips processing:\n;; (let ((groups (hget resp \"Groups\")))\n;;   (when (vector? groups)         ;; ALWAYS #f!\n;;     (for-each process groups)))  ;; never runs\n\n;; CORRECT — use a defensive ensure-list helper:\n(def (ensure-list v)\n  \"Coerce a vector, list, or other value to a list.\"\n  (cond ((list? v) v)\n        ((vector? v) (vector->list v))  ;; handles the rare vector case\n        (else [])))\n\n;; Usage:\n(let ((results (ensure-list (hget resp \"ResultsByTime\"))))\n  (for-each process results))\n\n;; For extracting the first element of a \"Keys\" array:\n;; WRONG:\n;; (if (vector? keys) (vector-ref keys 0) \"Unknown\")\n;; CORRECT:\n(let ((ks (ensure-list keys)))\n  (if (pair? ks) (car ks) \"Unknown\"))\n\n;; WHY THIS HAPPENS:\n;; - Gerbil's :std/text/json read-json maps JSON arrays to Scheme lists\n;; - gerbil-aws JSON API (Cost Explorer, Lambda, etc.) uses read-json\n;; - Many AWS SDK examples in other languages use arrays/vectors,\n;;   so it's natural to write (vector? ...) but WRONG in Gerbil\n;; - The gerbil-aws Query API (EC2, RDS, etc.) also returns lists\n;;   (from XML member parsing), never vectors",
    "notes": "This is one of the most insidious bugs because it causes SILENT data loss — no exceptions, no errors, just empty results everywhere. The code appears to run successfully but produces no output. Diagnosis: add (displayln (object-type results)) to see that results is a list, not a vector. Prevention: never use (vector? x) to guard JSON array processing — use (list? x) or the ensure-list helper instead. This applies to ALL gerbil-aws responses (both Query API and JSON API) and to any data parsed by Gerbil's read-json.",
    "related": [
      "gerbil-aws-query-vs-json-response-keys",
      "json-parse"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ec2-xml-lowercase-camelcase-keys",
    "title": "EC2 Query API XML uses lowercase camelCase keys, not PascalCase",
    "tags": [
      "ec2",
      "query-api",
      "xml",
      "camelCase",
      "lowercase",
      "regionName",
      "instanceId",
      "symbol",
      "key",
      "gotcha"
    ],
    "imports": [],
    "code": ";; PROBLEM: AWS API documentation shows PascalCase names like\n;; \"RegionName\", \"InstanceId\", \"VolumeId\". But the EC2 Query API\n;; XML response uses lowercase camelCase: <regionName>, <instanceId>.\n;;\n;; After XML parsing in gerbil-aws, these become lowercase symbols:\n;;   'regionName  NOT 'RegionName\n;;   'instanceId  NOT 'InstanceId\n;;   'volumeId    NOT 'VolumeId\n;;   'vpcId       NOT 'VpcId\n;;\n;; WRONG — throws UnboundKeyError:\n;; (hash-ref region-hash 'RegionName)   ;; key not found!\n;; (hash-ref instance 'InstanceId)      ;; key not found!\n;;\n;; CORRECT — use lowercase camelCase:\n;; (hash-ref region-hash 'regionName)   ;; works\n;; (hash-ref instance 'instanceId)      ;; works\n;;\n;; This applies to ALL ec2-action/items responses in gerbil-aws:\n;;   describe-regions     → 'regionName, 'regionEndpoint\n;;   describe-instances   → 'instanceId, 'instanceType, 'imageId\n;;   describe-volumes     → 'volumeId, 'size, 'volumeType\n;;   describe-snapshots   → 'snapshotId, 'volumeId, 'startTime\n;;   describe-addresses   → 'publicIp, 'allocationId\n;;   describe-nat-gateways → 'natGatewayId, 'vpcId, 'subnetId\n;;   describe-images      → 'imageId, 'name, 'creationDate\n;;\n;; But OTHER Query API services may use different casing:\n;;   CloudWatch  → 'MetricName, 'Namespace (PascalCase)\n;;   RDS         → 'DBInstanceIdentifier (PascalCase)\n;;   ELBv2       → 'LoadBalancerArn (PascalCase)\n;;\n;; The casing matches the actual XML element names in each service's\n;; API response, which varies by service. EC2 happens to use lowercase.",
    "notes": "The AWS documentation and CLI both show PascalCase (RegionName, InstanceId), but EC2's actual XML response uses lowercase camelCase. Other Query API services like CloudWatch and RDS use PascalCase in their XML. There's no universal rule — you must check the actual XML element names for each service. When in doubt, add a debug line: (displayln (hash->list my-hash)) to see the actual keys.",
    "related": [
      "gerbil-aws-query-vs-json-response-keys"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "write-json-cannot-serialize-cons-pairs",
    "title": "write-json cannot serialize cons pairs from hash->list — convert to hashes first",
    "tags": [
      "write-json",
      "hash->list",
      "cons",
      "pair",
      "alist",
      "serialize",
      "json",
      "Missing method",
      "gotcha"
    ],
    "imports": [
      ":std/text/json"
    ],
    "code": ";; PROBLEM: (hash->list ht) returns alist pairs: ((\"key1\" . val1) (\"key2\" . val2) ...)\n;; write-json does NOT know how to serialize cons pairs (dotted pairs).\n;; It throws: \"Missing method --- irritants: (\"key\" . value) :json\"\n;;\n;; This commonly happens when you sort a hash table and embed the\n;; sorted result in a data structure that later gets written to JSON.\n\n;; WRONG — crashes at JSON serialization time:\n;; (def sorted-services\n;;   (sort (hash->list service-totals)\n;;         (lambda (a b) (> (cdr a) (cdr b)))))\n;; (hash-put! data \"top_services\" sorted-services)\n;; ;; Later: (write-json data port)\n;; ;; ERROR: Missing method (\"EC2 - Other\" . 1073969.83) :json\n\n;; CORRECT — convert cons pairs to hashes before storing:\n(import :std/text/json)\n(def sorted-services\n  (sort (hash->list service-totals)\n        (lambda (a b) (> (cdr a) (cdr b)))))\n\n;; Convert alist pairs to list of hashes for JSON serialization:\n(def json-safe-services\n  (map (lambda (p) (hash (\"service\" (car p)) (\"cost\" (cdr p))))\n       sorted-services))\n\n(hash-put! data \"top_services\" json-safe-services)\n;; Now write-json works: [{\"service\":\"EC2\",\"cost\":1073969.83}, ...]\n\n;; write-json handles these types:\n;;   hash-table  → JSON object {\"key\": value}\n;;   list        → JSON array [...]\n;;   string      → JSON string \"...\"\n;;   number      → JSON number\n;;   #t / #f     → true / false\n;;   void / #!void → null\n;;\n;; It does NOT handle:\n;;   cons pair (\"k\" . v) → ERROR: Missing method :json\n;;   struct             → ERROR (unless has :json method)\n;;   symbol             → ERROR",
    "notes": "This error only surfaces at JSON write time, not when building the data structure. It's easy to miss during development if you only test the markdown output (which uses car/cdr on pairs directly). The fix is to convert alist pairs to hashes at the point where they're stored in the data structure, before they reach write-json. An alternative is to define a recursive sanitizer that walks the data tree and converts all cons pairs to hashes, but it's cleaner to convert at the source.",
    "related": [
      "gerbil-json-arrays-are-lists-not-vectors",
      "json-generate"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gerbil-aws-sts-nested-response",
    "title": "STS GetCallerIdentity returns nested hash — Account is under GetCallerIdentityResult",
    "tags": [
      "sts",
      "get-caller-identity",
      "account-id",
      "nested",
      "gerbil-aws",
      "query-api"
    ],
    "imports": [
      ":gerbil-aws/sts/api",
      ":gerbil-aws/sts/operations"
    ],
    "code": ";; gerbil-aws STS uses the Query API (XML). The GetCallerIdentity\n;; response XML is:\n;;   <GetCallerIdentityResponse>\n;;     <GetCallerIdentityResult>\n;;       <Account>123456789012</Account>\n;;       <Arn>arn:aws:iam::123456789012:user/me</Arn>\n;;       <UserId>AIDAXXXXXXX</UserId>\n;;     </GetCallerIdentityResult>\n;;     <ResponseMetadata>...</ResponseMetadata>\n;;   </GetCallerIdentityResponse>\n;;\n;; After aws-response->hash, the result is a NESTED hash:\n;;   {GetCallerIdentityResult: {Account: \"123456789012\", Arn: \"...\", UserId: \"...\"},\n;;    ResponseMetadata: {RequestId: \"...\"}}\n\n;; WRONG — 'Account is NOT at the top level:\n;; (def identity (get-caller-identity sts))\n;; (hash-ref identity 'Account \"\")  ;; => \"\" (always!)\n\n;; CORRECT — navigate to GetCallerIdentityResult first:\n(def sts (STSClient))\n(def identity (get-caller-identity sts))\n(def result (hash-ref identity 'GetCallerIdentityResult identity))\n(def account-id (hash-ref result 'Account \"\"))\n;; account-id => \"123456789012\"\n\n;; The same pattern applies to other STS operations:\n;; - AssumeRole → 'AssumeRoleResult → 'Credentials, 'AssumedRoleUser\n;; - GetSessionToken → 'GetSessionTokenResult → 'Credentials",
    "notes": "This is because gerbil-aws's aws-response->hash (in aws/xml.ss) converts the entire XML response to a nested hash, including the *Result wrapper element. The Query API always wraps the actual data in an ActionNameResult element. Using (hash-ref identity 'GetCallerIdentityResult identity) as a fallback ensures forward compatibility if the library ever changes to unwrap automatically.",
    "related": [
      "gerbil-aws-query-vs-json-response-keys",
      "ec2-lowercase-camelcase-keys"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gerbil-aws-empty-xml-tagset-string",
    "title": "Empty XML elements like tagSet become \"\" not [] — guard with list? before iterating",
    "tags": [
      "xml",
      "sxml",
      "tagSet",
      "empty-element",
      "type-exception",
      "gerbil-aws",
      "ec2"
    ],
    "imports": [],
    "code": ";; PROBLEM: In gerbil-aws EC2 responses, empty XML elements like <tagSet/>\n;; are parsed by sxml->hash as \"\" (empty string), not [] (empty list).\n;;\n;; This happens because of this clause in sxml->hash:\n;;   ((null? (cdr element)) \"\")  ;; Empty element: (tag) → \"\"\n;;\n;; So when a resource has no tags:\n;;   <tagSet/>  →  \"\" in the hash table\n;;\n;; And (hash-ref resource 'tagSet []) returns \"\" (key exists with value \"\"),\n;; NOT the default [].\n\n;; WRONG — crashes with type-exception: PAIR expected from (car \"\")\n;; (def (get-name tags)\n;;   (let loop ((ts (or tags [])))  ;; (or \"\" []) => \"\" (truthy!)\n;;     (if (null? ts) \"\"            ;; (null? \"\") => #f\n;;       (let ((t (car ts)))        ;; (car \"\") => TYPE EXCEPTION!\n;;         ...))))\n\n;; CORRECT — check (list? tags) before iterating:\n(def (get-name tags)\n  (let ((ts (if (list? tags) tags [])))\n    (let loop ((ts ts))\n      (if (null? ts) \"\"\n        (let ((t (car ts)))\n          (if (and (hash-table? t)\n                   (string=? (hash-ref t 'key \"\") \"Name\"))\n            (hash-ref t 'value \"\")\n            (loop (cdr ts))))))))\n\n;; This affects ANY EC2 field that can be an empty XML element:\n;;   tagSet, blockDeviceMapping, networkInterfaceSet,\n;;   securityGroupSet, natGatewayAddressSet, etc.\n;;\n;; General rule: always use (list? x) not (or x []) when the\n;; value might be \"\" from empty XML elements.",
    "notes": "This is a silent type-exception that only manifests when a resource happens to have no tags (or other empty set elements). Resources with at least one tag work fine because tagSet gets parsed as a list of items. The bug is intermittent — it depends on whether specific resources in specific regions have tags. Use (if (list? val) val []) instead of (or val []) for XML-parsed set fields.",
    "related": [
      "ec2-lowercase-camelcase-keys",
      "gerbil-aws-query-vs-json-response-keys"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "aws-pricing-api-endpoint",
    "title": "AWS Pricing API endpoint is api.pricing not pricing — CloudFront 403 on wrong endpoint",
    "tags": [
      "aws",
      "pricing",
      "endpoint",
      "api.pricing",
      "cloudfront",
      "403",
      "gerbil-aws",
      "json-api"
    ],
    "imports": [
      ":gerbil-aws/aws/json-api"
    ],
    "code": ";; PROBLEM: The AWS Pricing API uses a DIFFERENT endpoint pattern\n;; than most AWS services. The standard pattern is:\n;;   service.region.amazonaws.com\n;;\n;; But the Pricing API uses:\n;;   api.pricing.region.amazonaws.com\n;;\n;; Using the standard pattern (pricing.us-east-1.amazonaws.com) hits\n;; a CloudFront distribution that only serves GET requests for the\n;; pricing website. POST requests get:\n;;   403 ERROR: \"This distribution is not configured to allow the\n;;   HTTP request method that was used for this request.\"\n\n;; WRONG — hits CloudFront, gets 403:\n;; (AWSJsonClient service: \"pricing\"\n;;               target-prefix: \"AWSPriceListService\"\n;;               region: \"us-east-1\")\n;; ;; Constructs endpoint: pricing.us-east-1.amazonaws.com\n\n;; CORRECT — explicitly set the api.pricing endpoint:\n(def pricing-client\n  (AWSJsonClient service: \"pricing\"\n                 target-prefix: \"AWSPriceListService\"\n                 endpoint: \"api.pricing.us-east-1.amazonaws.com\"\n                 region: \"us-east-1\"))\n\n;; For a configurable region:\n(def (make-pricing-client (region \"us-east-1\"))\n  (AWSJsonClient service: \"pricing\"\n                 target-prefix: \"AWSPriceListService\"\n                 endpoint: (string-append \"api.pricing.\" region \".amazonaws.com\")\n                 region: region))\n\n;; Other AWS services with non-standard endpoints:\n;;   Cost Explorer: ce.us-east-1.amazonaws.com (standard pattern, works)\n;;   S3: s3.region.amazonaws.com or s3.amazonaws.com (path-style)\n;;   STS: sts.amazonaws.com (global) or sts.region.amazonaws.com (regional)",
    "notes": "The AWS Pricing API is only available in us-east-1 and ap-south-1. Always pass the endpoint explicitly when creating the client. The AWSJsonClient default endpoint construction (service.region.amazonaws.com) does NOT work for the Pricing API. This manifests as a confusing CloudFront 403 error rather than an obvious endpoint error.",
    "related": [
      "gerbil-aws-query-vs-json-response-keys"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "aws-pricing-api-content-type-1-1",
    "title": "AWS Pricing API requires content-type application/x-amz-json-1.1, not 1.0",
    "tags": [
      "pricing",
      "aws",
      "content-type",
      "json",
      "1.1",
      "AWSJsonClient",
      "UnknownOperationException",
      "404"
    ],
    "imports": [
      ":gerbil-aws/aws/json-api"
    ],
    "code": ";; PROBLEM: The AWS Pricing API requires content-type \"application/x-amz-json-1.1\"\n;; but AWSJsonClient defaults to \"application/x-amz-json-1.0\".\n;;\n;; Without the correct content-type, ALL Pricing API calls fail with:\n;;   HTTP 404: <UnknownOperationException/>\n;;\n;; This is a SILENT CASCADING FAILURE — pricing lookups return #f,\n;; causing downstream code to skip hundreds of resources.\n\n;; WRONG — uses default content-type 1.0, gets 404 on every call:\n;; (def (make-pricing-client (region \"us-east-1\"))\n;;   (AWSJsonClient service: \"pricing\"\n;;                  target-prefix: \"AWSPriceListService\"\n;;                  endpoint: (string-append \"api.pricing.\" region \".amazonaws.com\")\n;;                  region: region))\n\n;; CORRECT — explicitly set content-type to 1.1:\n(def (make-pricing-client (region \"us-east-1\"))\n  (AWSJsonClient service: \"pricing\"\n                 target-prefix: \"AWSPriceListService\"\n                 endpoint: (string-append \"api.pricing.\" region \".amazonaws.com\")\n                 content-type: \"application/x-amz-json-1.1\"\n                 region: region))\n\n;; AWS services and their JSON protocol versions:\n;;   application/x-amz-json-1.1:\n;;     Pricing, Lambda, CloudWatch Logs, ECS, SSM, Secrets Manager\n;;   application/x-amz-json-1.0:\n;;     DynamoDB, Compute Optimizer, Cost Optimization Hub, SWF\n;;\n;; Check the AWS service's API reference for the correct version.\n;; The version is listed in the \"Common Headers\" section of each API doc.",
    "notes": "The AWSJsonClient in gerbil-aws defaults content-type to \"application/x-amz-json-1.0\" (set in json-api.ss line 45). AWS services that require 1.1 will reject ALL requests with HTTP 404 UnknownOperationException. This is extremely hard to debug because: (1) the error is XML even though it's a JSON API, (2) 404 suggests a wrong URL, not a wrong content-type, (3) the endpoint IS correct (api.pricing.region.amazonaws.com). Combined with the endpoint issue (see aws-pricing-api-endpoint recipe), there are TWO things you must get right for the Pricing API: the api.pricing prefix AND the 1.1 content-type.",
    "related": [
      "aws-pricing-api-endpoint"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gerbil-aws-strip-ns-uri-namespace-bug",
    "title": "gerbil-aws strip-ns breaks on full URI namespace prefixes — finds first colon not last",
    "tags": [
      "strip-ns",
      "namespace",
      "XML",
      "SXML",
      "URI",
      "gerbil-aws",
      "STS",
      "RDS",
      "ELBv2"
    ],
    "imports": [],
    "code": ";; PROBLEM: gerbil-aws's strip-ns function in aws/xml.ss finds the FIRST\n;; colon in a symbol name, but URI namespace prefixes contain multiple colons.\n;;\n;; The function is:\n;;   (def (strip-ns sym)\n;;     (let (s (symbol->string sym))\n;;       (let (pos (string-contains s \":\"))   ;; finds FIRST \":\"\n;;         (if pos\n;;           (string->symbol (substring s (+ pos 1) (string-length s)))\n;;           sym))))\n;;\n;; For EC2, namespaces are mapped to short prefixes like \"ec2:\",\n;; so strip-ns works: 'ec2:instanceId → 'instanceId\n;;\n;; But for services WITHOUT namespace mappings (STS, RDS, ELBv2, CloudWatch),\n;; the XML parser produces full URI prefixes:\n;;   '//sts.amazonaws.com/doc/2011-06-15/:Account\n;;   '//rds.amazonaws.com/doc/2014-10-31/:DBInstances\n;;\n;; strip-ns finds the first \":\" in \"//sts.amazonaws.com/doc/2011-06-15/:Account\"\n;; which is in \"http:\" — producing '//sts.amazonaws.com/doc/2011-06-15/:Account\n;; (unchanged!) instead of 'Account.\n;;\n;; WORKAROUND: Add namespace mappings to your client, like EC2 does:\n;; (AWSClient ...\n;;   namespaces: '((\"https://sts.amazonaws.com/doc/2011-06-15/\" . \"sts\")))\n;;\n;; Or fix strip-ns to find the LAST colon:\n(def (strip-ns sym)\n  (let* ((s (symbol->string sym))\n         (len (string-length s)))\n    (let loop ((i (- len 1)))\n      (cond\n        ((< i 0) sym)\n        ((char=? (string-ref s i) #\\:)\n         (string->symbol (substring s (+ i 1) len)))\n        (else (loop (- i 1)))))))\n\n;; Test:\n;; (strip-ns '//sts.amazonaws.com/doc/2011-06-15/:Account) => 'Account\n;; (strip-ns 'ec2:instanceId) => 'instanceId\n;; (strip-ns 'noNamespace) => 'noNamespace\n\n;; AFFECTED SERVICES (no namespace mappings by default):\n;;   STS  — get-caller-identity returns empty account-id\n;;   RDS  — describe-db-instances returns 0 items\n;;   ELBv2 — describe-load-balancers returns 0 items\n;;   CloudWatch — some responses may be affected\n;;\n;; EC2 WORKS because it has explicit namespace mappings in ec2/xml.ss:\n;;   '((\"http://ec2.amazonaws.com/doc/2016-11-15/\" . \"ec2\"))",
    "notes": "This is a bug in gerbil-aws/aws/xml.ss. The proper fix is to change strip-ns to find the LAST colon instead of the first. The workaround is to add namespace mappings to each client (like EC2 does), but this requires knowing the exact namespace URI for each AWS service version. The bug causes SILENT DATA LOSS — API calls succeed (HTTP 200) but the response parsing can't match expected keys, so functions return empty lists or empty strings. Symptoms: get-account-id returns \"\", describe-db-instances returns 0 items, describe-load-balancers returns 0 items.",
    "related": [
      "aws-pricing-api-endpoint",
      "gerbil-aws-query-vs-json-response-keys",
      "ec2-lowercase-camelcase-keys"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "force-gc-gambit",
    "title": "Force garbage collection with ##gc in Gambit/Gerbil",
    "tags": [
      "gc",
      "garbage collection",
      "memory",
      "gambit",
      "heap",
      "oom"
    ],
    "imports": [],
    "code": ";; Force a full garbage collection using Gambit's ##gc primitive.\n;; Useful between memory-intensive sections to prevent heap from\n;; growing unboundedly when processing large datasets.\n\n;; Basic usage:\n(##gc)\n\n;; Pattern: Insert between heavy processing sections\n(def (process-large-dataset)\n  ;; Section 1: fetch and process data\n  (let ((data1 (fetch-large-data-1)))\n    (process data1)\n    (store-results data1))\n\n  ;; Force GC to reclaim temporary data from section 1\n  ;; before starting section 2\n  (##gc)\n\n  ;; Section 2: fetch more data\n  (let ((data2 (fetch-large-data-2)))\n    (process data2)\n    (store-results data2))\n\n  (##gc))\n\n;; Real-world example: AWS report data collection\n;; Without ##gc, parsed JSON from API responses accumulates\n;; until Gambit decides to collect, which may be too late\n;; on memory-constrained systems.\n;;\n;; (displayln \"  Fetching snapshots...\")\n;; (fetch-snapshots)\n;; (##gc)  ;; reclaim parsed API responses\n;; (displayln \"  Analyzing rightsizing...\")\n;; (analyze-rightsizing)  ;; another memory-heavy operation\n;; (##gc)\n",
    "notes": "##gc is a Gambit primitive (double-hash prefix). It triggers a full GC cycle synchronously. Returns void. Safe to call at any time. Particularly important in multi-threaded applications where many short-lived objects are created rapidly (e.g., parsing large JSON API responses) and the GC can't keep up with allocation pressure. Also useful in long-running batch programs that process data in phases. Note: calling ##gc too frequently adds overhead; use it between major processing phases, not in tight loops.",
    "related": [
      "srfi-19-current-time-shadows-gambit"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "thread-safe-list-accumulation",
    "title": "Thread-safe list accumulation — avoid O(n²) append anti-pattern",
    "tags": [
      "append",
      "cons",
      "thread",
      "parallel",
      "mutex",
      "performance",
      "memory",
      "accumulate"
    ],
    "imports": [],
    "code": ";; PROBLEM: When accumulating results from parallel threads, using\n;; (append accumulated new-items) copies the ENTIRE accumulated list\n;; on every call, creating O(n²) memory and time behavior.\n;;\n;; With large result sets across many threads, this wastes gigabytes\n;; of memory on redundant list copies before GC can reclaim them.\n\n;; WRONG — O(n²) memory, copies all-results on every append:\n;; (def result-mx (make-mutex 'result-mx))\n;; (def all-results [])\n;; ;; ... in each thread:\n;; (mutex-lock! result-mx)\n;; (set! all-results (append all-results new-results))  ;; BAD\n;; (mutex-unlock! result-mx)\n;; ;; append copies its FIRST argument, so (append big-list small-list)\n;; ;; copies big-list entirely. This grows quadratically.\n\n;; CORRECT — O(n) total, only copies the small new-results list:\n(def result-mx (make-mutex 'result-mx))\n(def all-results [])\n;; ... in each thread:\n(mutex-lock! result-mx)\n(set! all-results (append new-results all-results))  ;; GOOD\n(mutex-unlock! result-mx)\n;; append copies its first arg (small new-results) and links to second\n;; arg (large all-results) without copying it. O(k) per call where\n;; k = length of new-results.\n\n;; ALTERNATIVE — cons individual items (best for single results):\n(mutex-lock! result-mx)\n(set! all-results (cons single-result all-results))\n(mutex-unlock! result-mx)\n\n;; NOTE: Both correct approaches prepend, so results are in reverse\n;; order. Use (reverse all-results) at the end if order matters.\n;; But for many use cases (sorting results anyway), order doesn't matter.\n",
    "notes": "Scheme's append copies all cons cells of every argument except the last. So (append big-list small-list) copies big-list entirely. In a parallel accumulation loop, the accumulated list grows on each iteration, making the copy cost grow linearly and total cost quadratic. Swapping argument order — (append small-list big-list) — means only the small per-thread result is copied, keeping total cost linear. This matters when accumulating thousands of results across many threads: the O(n²) version can waste gigabytes of memory on intermediate copies that become garbage.",
    "related": [
      "mutex-unwind-protect"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gerbil-function-signature-keyword-args-arity",
    "title": "gerbil_function_signature reports arity:1 for functions with keyword args",
    "tags": [
      "function-signature",
      "arity",
      "keyword",
      "args",
      "misleading",
      "gerbil-mcp"
    ],
    "imports": [],
    "code": ";; GOTCHA: gerbil_function_signature (and gerbil_doc) reports arity:1\n;; for functions that accept keyword arguments. This is technically correct\n;; (the compiled lambda takes 1 positional arg — the client/object) but\n;; misleading because the function actually accepts many keyword params.\n;;\n;; Example from gerbil-aws:\n;;   gerbil_function_signature for describe-alarms reports:\n;;     arity:1  (gerbil-aws/cloudwatch/operations#describe-alarms)\n;;\n;;   But the ACTUAL signature (from reading source) is:\n;;     (describe-alarms client\n;;       alarm-names: (alarm-names #f)\n;;       state-value: (state-value #f)\n;;       next-token: (next-token #f)\n;;       max-records: (max-records #f))\n;;\n;;   Similarly, describe-instances reports arity:1 but actually accepts:\n;;     (describe-instances client\n;;       instance-ids: (instance-ids [])\n;;       filters: (filters [])\n;;       max-results: (max-results #f)\n;;       next-token: (next-token #f))\n;;\n;; WORKAROUND: When gerbil_function_signature shows arity:1, ALWAYS\n;; read the actual source code (via gerbil_find_definition with\n;; source_preview: true, or by reading the .ss file directly) to\n;; discover keyword arguments.\n;;\n;; This is especially important for gerbil-aws library functions where\n;; most API operations accept keyword args for optional parameters like\n;; filters:, max-results:, next-token:, etc.",
    "notes": "Gambit compiles keyword arguments into a rest-args list internally, so the arity reflects only positional parameters. The gerbil_function_signature tool cannot currently extract keyword parameter names from compiled modules. Always verify by reading source when arity seems too low for an API wrapper function.",
    "related": [
      "optional-keyword-arguments"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ec2-monitoring-state-filter",
    "title": "Filter EC2 instances by monitoring state instead of running state",
    "tags": [
      "EC2",
      "describe-instances",
      "filter",
      "monitoring",
      "detailed-monitoring",
      "gerbil-aws"
    ],
    "imports": [
      ":gerbil-aws/ec2/instances",
      ":gerbil-aws/ec2/api"
    ],
    "code": ";; To count instances with detailed monitoring enabled, use the\n;; \"monitoring-state\" filter instead of fetching ALL running instances.\n;;\n;; BAD — fetches every running instance (5-20KB each, thousands possible):\n;; (describe-instances ec2 filters: '((\"instance-state-name\" \"running\")))\n;; ;; Then manually check each instance's monitoring.state field\n;;\n;; GOOD — fetches only instances with detailed monitoring (typically few):\n(import :gerbil-aws/ec2/instances :gerbil-aws/ec2/api)\n(let* ((ec2 (EC2Client region: \"us-east-1\"))\n       (reservations (describe-instances ec2\n                       filters: '((\"monitoring-state\" \"enabled\")))))\n  ;; Count instances directly — no need to check monitoring.state\n  (let ((count 0))\n    (for-each\n     (lambda (res)\n       (let ((instances (hash-ref res 'instancesSet [])))\n         (set! count (+ count (if (list? instances) (length instances) 0)))))\n     reservations)\n    count))\n;; This avoids loading full instance metadata for potentially thousands\n;; of running instances when you only need the few with detailed monitoring.",
    "notes": "The \"monitoring-state\" filter is a standard EC2 DescribeInstances filter that returns only instances matching the given monitoring state (\"enabled\" or \"disabled\"). Using this instead of \"instance-state-name\" + manual filtering reduces API response size from potentially hundreds of MBs (all running instances with full metadata) to KBs (just the few with detailed monitoring). Remember that instancesSet may be \"\" (empty string) instead of [] for empty XML elements — always guard with (list? ...) check.",
    "related": [
      "ec2-lowercase-camelcase-keys",
      "ec2-empty-tagset-string"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ec2-paginated-query-with-action-hash",
    "title": "Paginate EC2 API calls using ec2-action/hash to avoid OOM",
    "tags": [
      "ec2",
      "pagination",
      "nextToken",
      "ec2-action/hash",
      "memory",
      "describe-instances",
      "MaxResults"
    ],
    "imports": [
      ":gerbil-aws/ec2/api"
    ],
    "code": ";; PROBLEM: gerbil-aws high-level functions like describe-instances use\n;; ec2-action/items, which returns only the extracted items list and\n;; DISCARDS the NextToken from the response. This means ALL results\n;; are fetched in a single API call with no pagination.\n;;\n;; For large accounts (thousands of instances), this loads hundreds of\n;; MB of instance metadata into memory at once, causing OOM.\n;;\n;; SOLUTION: Use ec2-action/hash directly to get the full response\n;; hash including nextToken, and paginate manually.\n\n(import :gerbil-aws/ec2/api)\n\n;; Example: count instances with detailed monitoring, paginated\n(def (count-detailed-monitoring ec2)\n  (let loop ((next-token #f) (count 0))\n    (let* ((result (ec2-action/hash ec2 \"DescribeInstances\"\n                     (append\n                       [[\"MaxResults\" :: \"50\"]\n                        [\"Filter.1.Name\" :: \"monitoring-state\"]\n                        [\"Filter.1.Value.1\" :: \"enabled\"]]\n                       (if next-token [[\"NextToken\" :: next-token]] []))))\n           ;; reservationSet is a list of reservation hashes (EC2 uses lowercase)\n           (reservations (let ((rs (hash-get result 'reservationSet)))\n                           (if (list? rs) rs [])))\n           ;; Count instances across all reservations in this page\n           (page-count (let pc ((res reservations) (n 0))\n                         (if (null? res) n\n                           (let ((is (hash-get (car res) 'instancesSet)))\n                             (pc (cdr res) (+ n (if (list? is) (length is) 0)))))))\n           (new-count (+ count page-count))\n           ;; EC2 uses lowercase 'nextToken (not 'NextToken)\n           (nt (hash-get result 'nextToken)))\n      (if (and (string? nt) (> (string-length nt) 0))\n        (loop nt new-count)\n        new-count))))\n\n;; KEY POINTS:\n;; - ec2-action/hash returns the FULL response as a hash, including nextToken\n;; - EC2 uses lowercase camelCase keys: 'nextToken, 'reservationSet, 'instancesSet\n;; - MaxResults limits items per page (5-1000 for DescribeInstances)\n;; - Filter params use dot notation: Filter.N.Name, Filter.N.Value.M\n;; - Always check (list? ...) for set fields — empty XML elements become \"\"\n;; - Only accumulate what you need (counts, IDs) — let each page be GC'd",
    "notes": "The high-level describe-instances function uses ec2-action/items which extracts items from a specific XML tag but discards the rest of the response (including nextToken). This makes pagination impossible through the high-level API. You MUST drop down to ec2-action/hash for paginated queries. The same pattern applies to all EC2 Describe* operations. Remember EC2 uses lowercase camelCase keys (nextToken not NextToken), unlike CloudWatch which uses PascalCase.",
    "related": [
      "ec2-lowercase-camelcase-keys",
      "ec2-empty-tagset-string",
      "ec2-monitoring-state-filter"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "cloudwatch-paginated-describe-alarms",
    "title": "Paginate CloudWatch DescribeAlarms using cw-action/hash",
    "tags": [
      "cloudwatch",
      "pagination",
      "NextToken",
      "cw-action/hash",
      "describe-alarms",
      "MaxRecords",
      "memory"
    ],
    "imports": [
      ":gerbil-aws/cloudwatch/api"
    ],
    "code": ";; PROBLEM: The describe-alarms function in :gerbil-aws/cloudwatch/operations\n;; uses cw-action/hash internally but only returns MetricAlarms and\n;; CompositeAlarms — it DISCARDS the NextToken. No pagination possible.\n;;\n;; SOLUTION: Use cw-action/hash directly to paginate.\n\n(import :gerbil-aws/cloudwatch/api)\n\n;; Helper to unwrap CloudWatch member-list structures\n(def (cw-member-list raw)\n  (cond\n    ((not raw) [])\n    ((list? raw) raw)\n    ((hash-table? raw)\n     (let ((m (hash-get raw 'member)))\n       (cond ((list? m) m) ((not m) []) (else [m]))))\n    (else [])))\n\n;; Example: count alarms by type across all pages\n(def (count-alarms-by-type cw)\n  (let loop ((next-token #f) (std 0) (hires 0) (comp 0))\n    (let* ((full-hash (cw-action/hash cw \"DescribeAlarms\"\n                        (append\n                          [[\"MaxRecords\" :: \"100\"]]\n                          (if next-token [[\"NextToken\" :: next-token]] []))))\n           ;; CloudWatch wraps response in DescribeAlarmsResult\n           (result (or (hash-get full-hash 'DescribeAlarmsResult) full-hash))\n           (result (if (hash-table? result) result (hash)))\n           (metric-alarms (cw-member-list (hash-get result 'MetricAlarms)))\n           (composite-alarms (cw-member-list (hash-get result 'CompositeAlarms)))\n           ;; Count standard vs high-resolution metric alarms\n           (page-std 0) (page-hires 0))\n      (for-each\n       (lambda (a)\n         (if (and (hash-table? a)\n                  (< (string->number (hash-ref a 'Period \"60\")) 60))\n           (set! page-hires (+ page-hires 1))\n           (set! page-std (+ page-std 1))))\n       metric-alarms)\n      (let ((new-std (+ std page-std))\n            (new-hires (+ hires page-hires))\n            (new-comp (+ comp (length composite-alarms)))\n            ;; CloudWatch uses PascalCase 'NextToken (not lowercase)\n            (nt (hash-get result 'NextToken)))\n        (if (and (string? nt) (> (string-length nt) 0))\n          (loop nt new-std new-hires new-comp)\n          (values new-std new-hires new-comp))))))\n\n;; KEY POINTS:\n;; - cw-action/hash returns full response; navigate to 'DescribeAlarmsResult\n;; - CloudWatch uses PascalCase: 'NextToken, 'MetricAlarms, 'Period\n;; - MetricAlarms/CompositeAlarms use &lt;member&gt; tags — use cw-member-list helper\n;; - MaxRecords limits alarms per page (1-100, default 50)",
    "notes": "CloudWatch Query API uses PascalCase keys (NextToken, MetricAlarms) unlike EC2 which uses lowercase camelCase (nextToken, reservationSet). The DescribeAlarmsResult wrapper must be navigated to before accessing alarms. The member-list extraction is needed because CloudWatch XML uses member elements instead of item elements, and sxml->hash only auto-unwraps item elements.",
    "related": [
      "normalize-xml-member-list",
      "ec2-paginated-query-with-action-hash",
      "ec2-lowercase-camelcase-keys"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "aws-sxml-lightweight-counting",
    "title": "Use raw SXML (cw-action/ec2-action) instead of hash conversion for memory-efficient counting",
    "tags": [
      "sxml",
      "memory",
      "optimization",
      "cw-action",
      "ec2-action",
      "cloudwatch",
      "ec2",
      "hash-table",
      "count",
      "strip-ns"
    ],
    "imports": [
      ":gerbil-aws/cloudwatch/api",
      ":gerbil-aws/ec2/api",
      ":gerbil-aws/aws/xml"
    ],
    "code": ";; PROBLEM: cw-action/hash and ec2-action/hash parse the ENTIRE XML response\n;; into deeply nested hash tables via sxml->hash. For DescribeAlarms with\n;; 100 alarms (each with 25+ fields), this creates thousands of hash table\n;; entries per page — but you may only need a count or one field.\n;;\n;; SOLUTION: Use cw-action / ec2-action (raw SXML) and navigate the tree\n;; directly with strip-ns + sxml-items + sxml-text from :gerbil-aws/aws/xml.\n;; No hash tables are allocated per-object.\n\n(import :gerbil-aws/cloudwatch/api\n        :gerbil-aws/ec2/api\n        (only-in :gerbil-aws/aws/xml strip-ns sxml-items sxml-text))\n\n;; Helper: navigate past *TOP* to the response element\n(def (sxml-unwrap-top sxml)\n  (if (and (pair? sxml) (eq? (car sxml) '*TOP*))\n    (let loop ((children (cdr sxml)))\n      (cond\n        ((null? children) sxml)\n        ((and (pair? (car children))\n              (symbol? (caar children))\n              (not (memq (caar children) '(@ *NAMESPACES* *PI*))))\n         (car children))\n        (else (loop (cdr children)))))\n    sxml))\n\n;; Helper: find first direct child by tag (handles namespace prefixes)\n(def (sxml-child node tag)\n  (and (pair? node)\n       (let loop ((children (cdr node)))\n         (cond\n           ((null? children) #f)\n           ((and (pair? (car children))\n                 (symbol? (caar children))\n                 (eq? (strip-ns (caar children)) tag))\n            (car children))\n           (else (loop (cdr children)))))))\n\n;; Helper: get text of a named child\n(def (sxml-child-text node tag)\n  (let ((child (sxml-child node tag)))\n    (and child (sxml-text child))))\n\n;; Example: count CloudWatch alarms by type from raw SXML\n;; (cw-action returns SXML, NOT hash tables)\n(def (count-alarms-page cw next-token)\n  (let* ((sxml (cw-action cw \"DescribeAlarms\"\n                 (append [[\"MaxRecords\" :: \"100\"]]\n                         (if next-token [[\"NextToken\" :: next-token]] []))))\n         (resp (sxml-unwrap-top sxml))\n         (result (or (sxml-child resp 'DescribeAlarmsResult) resp))\n         ;; sxml-items finds <member> children (CW uses member, EC2 uses item)\n         (ma (sxml-child result 'MetricAlarms))\n         (members (if ma (sxml-items ma 'member) []))\n         (ca (sxml-child result 'CompositeAlarms))\n         (composites (if ca (sxml-items ca 'member) [])))\n    ;; Only extract Period — no hash tables built for each alarm\n    (let ((std 0) (hires 0))\n      (for-each (lambda (m)\n                  (let ((p (sxml-child-text m 'Period)))\n                    (if (and p (< (string->number p) 60))\n                      (set! hires (+ hires 1))\n                      (set! std (+ std 1)))))\n                members)\n      (values std hires (length composites)\n              (sxml-child-text result 'NextToken)))))\n\n;; Example: count EC2 instances from raw SXML\n;; (ec2-action returns SXML; EC2 uses 'item not 'member)\n(def (count-instances-page ec2 next-token)\n  (let* ((sxml (ec2-action ec2 \"DescribeInstances\"\n                 (append [[\"MaxResults\" :: \"50\"]\n                          [\"Filter.1.Name\" :: \"monitoring-state\"]\n                          [\"Filter.1.Value.1\" :: \"enabled\"]]\n                         (if next-token [[\"NextToken\" :: next-token]] []))))\n         (resp (sxml-unwrap-top sxml))\n         (res-set (sxml-child resp 'reservationSet))\n         ;; sxml-items default tag is 'item (EC2 convention)\n         (reservations (if res-set (sxml-items res-set) [])))\n    (let ((count (let loop ((res reservations) (n 0))\n                   (if (null? res) n\n                     (let ((is (sxml-child (car res) 'instancesSet)))\n                       (loop (cdr res)\n                             (+ n (if is (length (sxml-items is)) 0))))))))\n      (values count (sxml-child-text resp 'nextToken)))))",
    "notes": "Key insight: cw-action/hash and ec2-action/hash call sxml->hash which recursively creates make-hash-table + hash-put! for EVERY XML element. For responses with 100+ objects (alarms, instances), this is the dominant memory cost. Using the raw SXML APIs (cw-action, ec2-action) and navigating with strip-ns/sxml-items/sxml-text avoids all hash allocation.\n\nImportant details:\n- CloudWatch XML uses <member> elements: (sxml-items container 'member)\n- EC2 XML uses <item> elements: (sxml-items container) — default tag is 'item\n- CloudWatch uses PascalCase tags: 'DescribeAlarmsResult, 'NextToken, 'Period\n- EC2 uses lowercase camelCase: 'reservationSet, 'instancesSet, 'nextToken\n- strip-ns handles both full URI namespaces (CloudWatch) and short prefixes (ec2:)\n- sxml-text only works for (tag \"text\") leaf elements — exactly 2 elements\n- sxml-items uses strip-ns internally, so namespace handling is automatic\n- Semaphore concurrency should be reduced when using this pattern (less memory headroom needed but still good practice)",
    "related": [
      "paginate-ec2-action-hash",
      "sxml-skip-pi-nodes",
      "parse-xml-to-sxml",
      "ec2-lowercase-camelcase-keys"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "serialize-regions-gc-bound-memory",
    "title": "Serialize multi-region AWS calls with GC to bound peak memory",
    "tags": [
      "memory",
      "GC",
      "sequential",
      "region",
      "OOM",
      "serialize",
      "paginate",
      "page-size",
      "aws"
    ],
    "imports": [],
    "code": ";; PROBLEM: Processing all AWS regions concurrently with semaphore/threads\n;; causes OOM when each region produces large SXML trees (e.g., DescribeAlarms\n;; with 100 records/page, DescribeInstances with 50 full instance records).\n;; Even with raw SXML (no hash conversion), 2+ concurrent regions parsing\n;; large XML responses can exhaust memory before GC runs.\n;;\n;; SOLUTION: Three combined techniques:\n;; 1. Process regions sequentially (for-each, no threads/semaphore)\n;; 2. Use small page sizes (MaxRecords 25, MaxResults 10)\n;; 3. Force GC between phases and after each region\n\n;; BEFORE (OOM-prone):\n;; (let ((sem (make-semaphore 2)))\n;;   (for-each\n;;    (lambda (region)\n;;      (semaphore-wait! sem)\n;;      (spawn (lambda ()\n;;        (try\n;;          (do-alarms region)       ;; large SXML\n;;          (do-dashboards region)   ;; more SXML\n;;          (do-instances region)    ;; huge SXML (full instance details)\n;;          (finally (semaphore-post! sem))))))\n;;    regions))\n\n;; AFTER (memory-bounded):\n(def (process-all-regions regions)\n  (let ((total-count 0))\n    (for-each\n     (lambda (region)\n       (try\n        ;; Phase 1: alarms (small pages)\n        (let loop ((next-token #f))\n          (let* ((sxml (api-call region \"DescribeAlarms\"\n                         [[\"MaxRecords\" :: \"25\"]]))  ;; was 100\n                 (count (count-items sxml))\n                 (nt (extract-next-token sxml)))\n            (set! total-count (+ total-count count))\n            (when nt (loop nt))))\n        (##gc)  ;; free alarm SXML before next phase\n\n        ;; Phase 2: instances (very small pages — response includes\n        ;; ALL instance attributes: security groups, network interfaces,\n        ;; block devices, tags, etc.)\n        (let loop ((next-token #f))\n          (let* ((sxml (api-call region \"DescribeInstances\"\n                         [[\"MaxResults\" :: \"10\"]]))  ;; was 50\n                 (count (count-items sxml))\n                 (nt (extract-next-token sxml)))\n            (set! total-count (+ total-count count))\n            (when nt (loop nt))))\n\n        (catch (e) (handle-error region e))\n        (finally (##gc))))  ;; free everything before next region\n     regions)\n    total-count))\n\n;; WHY SMALL PAGES MATTER:\n;; - DescribeInstances returns FULL instance details for each instance\n;;   (security groups, network interfaces, block devices, tags, etc.)\n;;   A single instance can be 50+ SXML elements.\n;; - MaxResults=50 → ~2500 SXML elements per page\n;; - MaxResults=10 → ~500 SXML elements per page (5x less peak memory)\n;; - More API calls, but each page is GC-friendly\n;;\n;; TRADEOFF: Sequential is slower than concurrent, but won't OOM.\n;; For counting/aggregation tasks, correctness > speed.",
    "notes": "This pattern applies when you only need aggregated results (counts, sums) from AWS API responses, not the full data. The key insight is that DescribeInstances responses are disproportionately large because they include ALL instance attributes even when you only need a count. Reducing MaxResults from 50 to 10 cuts peak SXML memory ~5x per page. Combined with sequential processing and GC between phases, this bounds memory to roughly one small page worth of SXML at a time. If you need the actual data (not just counts), consider processing each page immediately and discarding the SXML before fetching the next page.",
    "related": [
      "force-gc-gambit",
      "sxml-counting-raw",
      "paginate-ec2-action-hash"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "memory-snapshot-profiling",
    "title": "Memory snapshot profiling with RSS + GC heap stats",
    "tags": [
      "memory",
      "profiling",
      "debug",
      "heap",
      "RSS",
      "VmRSS",
      "gc",
      "leak",
      "snapshot"
    ],
    "imports": [
      ":std/debug/heap",
      ":std/format"
    ],
    "code": ";; Complete memory profiling utility that combines:\n;; 1. OS-level RSS from /proc/self/status (actual process memory)\n;; 2. GC heap stats from :std/debug/heap memory-usage\n;;\n;; Returns an alist: ((gc-heap-size . N) (gc-alloc . N) (gc-live . N)\n;;                    (gc-movable . N) (gc-still . N))\n\n(import :std/debug/heap :std/format)\n\n;; Get VmRSS from /proc/self/status (Linux only)\n(def (get-rss-kb)\n  (try\n    (call-with-input-file \"/proc/self/status\"\n      (lambda (port)\n        (let loop ((line (read-line port)))\n          (if (eof-object? line) 0\n            (if (and (>= (string-length line) 6)\n                     (string=? \"VmRSS:\" (substring line 0 6)))\n              ;; Parse the number from \"VmRSS:   12345 kB\"\n              (let find-num ((i 6))\n                (cond\n                  ((>= i (string-length line)) 0)\n                  ((char-numeric? (string-ref line i))\n                   (let end-num ((j (+ i 1)))\n                     (if (or (>= j (string-length line))\n                             (not (char-numeric? (string-ref line j))))\n                       (string->number (substring line i j))\n                       (end-num (+ j 1)))))\n                  (else (find-num (+ i 1)))))\n              (loop (read-line port)))))))\n    (catch (e) 0)))\n\n;; Print + return memory snapshot\n(def (mem-snapshot label)\n  (let* ((rss-kb (get-rss-kb))\n         (rss-mb (/ rss-kb 1024.0))\n         (heap (memory-usage))\n         (gc-heap-mb (/ (cdr (assoc 'gc-heap-size heap)) (* 1024.0 1024.0)))\n         (gc-live-mb (/ (cdr (assoc 'gc-live heap)) (* 1024.0 1024.0))))\n    (fprintf (current-error-port)\n             \"[MEM ~a] RSS=~aMB | GC-heap=~aMB live=~aMB~n\"\n             label\n             (number->string (inexact->exact (round rss-mb)))\n             (number->string (inexact->exact (round gc-heap-mb)))\n             (number->string (inexact->exact (round gc-live-mb))))\n    (force-output (current-error-port))\n    (list (cons 'rss-kb rss-kb) (cons 'rss-mb rss-mb)\n          (cons 'gc-heap-mb gc-heap-mb) (cons 'gc-live-mb gc-live-mb))))\n\n;; Print delta from previous snapshot\n(def (mem-delta label prev)\n  (let* ((snap (mem-snapshot label))\n         (d-rss (- (cdr (assoc 'rss-mb snap)) (cdr (assoc 'rss-mb prev))))\n         (d-live (- (cdr (assoc 'gc-live-mb snap)) (cdr (assoc 'gc-live-mb prev)))))\n    (fprintf (current-error-port)\n             \"[MEM-DELTA ~a] RSS=~a~aMB live=~a~aMB~n\"\n             label\n             (if (>= d-rss 0) \"+\" \"-\") (number->string (inexact->exact (round (abs d-rss))))\n             (if (>= d-live 0) \"+\" \"-\") (number->string (inexact->exact (round (abs d-live)))))\n    (force-output (current-error-port))\n    snap))\n\n;; Usage: wrap suspect sections\n;; (let ((s (mem-snapshot \"before-heavy-work\")))\n;;   (heavy-work)\n;;   (mem-delta \"after-heavy-work\" s)\n;;   (##gc)\n;;   (mem-delta \"after-gc\" s))",
    "notes": "memory-usage from :std/debug/heap returns an alist with keys: gc-heap-size, gc-alloc, gc-live, gc-movable, gc-still (all in bytes). The gc-live value shows how much memory is actually retained after GC. RSS from /proc/self/status shows the OS-level resident set — this includes memory that Gambit has allocated from the OS but may not have returned yet (the GC heap can grow but rarely shrinks). Output goes to stderr via current-error-port so it doesn't pollute stdout. The :std/debug/heap import triggers some Gambit warnings about undefined variables (macro-slot, macro-will-action, macro-will-testator) — these are harmless and can be ignored.",
    "related": [
      "force-gc-gambit",
      "serialize-multi-region-gc"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "run-standalone-script-with-project-imports",
    "title": "Run standalone gxi script that imports project modules",
    "tags": [
      "gxi",
      "script",
      "standalone",
      "import",
      "GERBIL_LOADPATH",
      "package",
      "relative",
      "module context"
    ],
    "imports": [],
    "code": ";; PROBLEM: You have a standalone test/utility script that needs to\n;; import modules from your project. Relative imports fail:\n;;\n;;   ;; test-script.ss\n;;   (import ./aws ./resources)  ;; FAILS!\n;;   ;; Error: \"cannot resolve relative module path; not in module context\"\n;;\n;; Relative imports (./module) only work inside a module being compiled\n;; as part of a build. When running a .ss file directly with `gxi`,\n;; the file is NOT in a module context.\n;;\n;; SOLUTION: Use package-qualified imports and set GERBIL_LOADPATH.\n;;\n;; Given a project with gerbil.pkg:\n;;   (package: my-project)\n;;\n;; And modules: aws.ss, resources.ss, etc.\n\n;; test-script.ss — correct way:\n;; (import :my-project/aws\n;;         :my-project/resources\n;;         :my-project/pricing)\n;;\n;; Run with GERBIL_LOADPATH pointing to the project's compiled libs:\n;;   GERBIL_LOADPATH=.gerbil/lib gxi test-script.ss\n;;\n;; Or with absolute path:\n;;   GERBIL_LOADPATH=/path/to/project/.gerbil/lib gxi test-script.ss\n;;\n;; If the project also depends on external packages:\n;;   GERBIL_LOADPATH=/path/to/project/.gerbil/lib:~/.gerbil/lib gxi test-script.ss\n\n;; IMPORTANT: The project must be built first (`gerbil build` or `make`)\n;; so that .gerbil/lib/ contains the compiled module files.\n\n;; Full example — standalone memory test script:\n;; #!/usr/bin/env gxi\n;; (import :std/format\n;;         :std/debug/heap\n;;         :my-project/aws\n;;         :my-project/resources)\n;;\n;; (def (main . args)\n;;   (let ((snap (mem-snapshot \"START\")))\n;;     (get-resources)\n;;     (mem-delta \"END\" snap)))\n;;\n;; (apply main (cdr (command-line)))",
    "notes": "Key points: (1) ./module syntax ONLY works inside compiled modules, not standalone gxi scripts. (2) Use :package/module paths matching your gerbil.pkg package: declaration. (3) GERBIL_LOADPATH must include the project's .gerbil/lib/ directory. (4) The project must be built first so compiled modules exist. (5) Multiple LOADPATH entries are colon-separated. (6) For CLI scripts, use (command-line) to get args and (apply main (cdr (command-line))) to invoke.",
    "related": [
      "gerbil-build-loadpath"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "resolve-import-naming-conflicts",
    "title": "Resolve naming conflicts when importing modules with only-in/except-in",
    "tags": [
      "import",
      "only-in",
      "except-in",
      "conflict",
      "naming",
      "duplicate",
      "shadow",
      "string-split",
      "string-prefix"
    ],
    "imports": [],
    "code": ";; PROBLEM: Your module defines a function that has the same name as\n;; something exported by a standard library module you want to import.\n;;\n;; Example: Your aws.ss defines its own string-split and string-prefix?\n;; but you also want to import :std/misc/string for other utilities.\n;;\n;; WRONG — duplicate definition error:\n;; (import :std/misc/string)  ;; exports string-split, string-prefix?, etc.\n;; (def (string-split s sep) ...)  ;; CONFLICT! already imported\n;;\n;; SOLUTION 1: Use only-in to import specific non-conflicting symbols\n;; (import (only-in :std/misc/string\n;;           string-trim-prefix\n;;           string-trim-suffix\n;;           string-trim-eol))\n;;\n;; SOLUTION 2: Use except-in to exclude conflicting symbols\n;; (import (except-in :std/misc/string\n;;           string-split\n;;           string-prefix?))\n;;\n;; SOLUTION 3: Use prefix-in to namespace all imports\n;; (import (prefix-in str: :std/misc/string))\n;; ;; Now use str:string-split, str:string-prefix?, etc.\n;; ;; Your own string-split is unaffected\n;;\n;; SOLUTION 4: Skip the import entirely if you only need the\n;; conflicting symbols and already have local implementations.\n;; This is the simplest approach when the overlap is large.\n;;\n;; SOLUTION 5: Use rename-in to rename specific conflicting imports\n;; (import (rename-in :std/misc/string\n;;           (string-split std-string-split)\n;;           (string-prefix? std-string-prefix?)))\n;; ;; Now both versions available under different names\n\n;; CHECKING what a module exports before importing:\n;; Use gerbil_module_exports MCP tool, or in the REPL:\n;;   (import :std/misc/string)\n;;   ;; then check which names appeared",
    "notes": "Common conflict sources: (1) :std/misc/string exports string-split, string-prefix?, string-suffix? which many projects define locally. (2) :std/srfi/1 exports map, for-each, filter etc. which shadow Gerbil's built-ins. (3) :std/iter exports for which shadows Gerbil's for (though they're usually compatible). Always use gerbil_module_exports to check what a module exports BEFORE importing it. The only-in approach is safest — you explicitly list what you need and won't get surprise conflicts if the upstream module adds new exports.",
    "related": [
      "export-t-no-reexport"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "def-self-shadow-infinite-recursion",
    "title": "Local def shadows imported/intended function — causes infinite recursion",
    "tags": [
      "shadow",
      "def",
      "infinite recursion",
      "SIGSEGV",
      "stack overflow",
      "self-call",
      "gotcha"
    ],
    "imports": [
      ":std/error"
    ],
    "code": ";; PROBLEM: Defining a function with the same name as one you intend to call\n;; creates accidental infinite recursion. The local def shadows any import.\n;;\n;; WRONG — infinite recursion, manifests as SIGSEGV (stack overflow):\n;; (def (exception->string e)\n;;   (or (exception->string e)   ;; calls ITSELF, not some library function\n;;       (call-with-output-string (lambda (p) (display-exception e p)))))\n;;\n;; The author likely intended to call a library's exception->string first,\n;; then fall back. But no such function exists in Gerbil's stdlib, and\n;; even if it did, the local def would shadow it.\n;;\n;; This causes SIGSEGV because:\n;; 1. An exception occurs somewhere (e.g., API error)\n;; 2. A catch block calls exception->string\n;; 3. The function calls itself infinitely\n;; 4. Stack overflow hits the guard page → SIGSEGV\n;; 5. GDB may report the crash in a DIFFERENT module's code\n;;    (wherever the stack pointer lands)\n\n;; CORRECT — use type-dispatch, never self-reference unless intended:\n(def (exception->string e)\n  (cond\n    ((Error? e) (Error-message e))              ;; Gerbil Error struct\n    ((error-exception? e)                        ;; Gambit error-exception\n     (error-exception-message e))\n    (else                                        ;; everything else\n     (call-with-output-string\n       (lambda (p) (display-exception e p))))))\n\n;; GENERAL RULE: In Gerbil, a top-level (def (foo ...) ...) in a module\n;; creates a binding for 'foo' that shadows ANY imported 'foo'.\n;; If you call 'foo' inside the body of that def, you call YOURSELF.\n;; There is no way to \"fall through\" to the imported version.\n;;\n;; If you need the imported version, rename on import:\n;; (import (rename-in :some-lib (foo lib-foo)))\n;; (def (foo e)\n;;   (or (lib-foo e)  ;; calls the imported version\n;;       (fallback e)))",
    "notes": "This is a subtle bug because: (1) it compiles without warning, (2) it only crashes when the code path is actually hit (e.g., when an exception is caught), (3) the SIGSEGV crash location in GDB may point to a completely different module due to how stack overflow works in compiled Gambit code. The key diagnostic clue is a SIGSEGV during exception handling. Always check that your catch-block helper functions don't accidentally recurse.",
    "related": [
      "error-message-returns-false",
      "error-handling"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "hash-list-to-json-consumer-gotcha",
    "title": "After converting alist pairs to hashes for JSON, consumers must use hget not car/cdr",
    "tags": [
      "hash",
      "json",
      "car",
      "cdr",
      "hget",
      "alist",
      "pair",
      "write-json",
      "read-json",
      "consume",
      "iterate"
    ],
    "imports": [
      ":std/text/json",
      ":std/sort"
    ],
    "code": ";; SCENARIO: You have hash->list pairs that you convert to hashes for JSON\n;; serialization (as required by write-json), but the code that reads\n;; them back still uses car/cdr — causing \"PAIR expected\" errors.\n\n;; === DATA PRODUCTION (correct) ===\n;; Convert alist pairs to hashes for write-json compatibility:\n(def service-totals (hash (\"EC2\" 5000) (\"S3\" 2000) (\"RDS\" 1500)))\n(def sorted (sort (hash->list service-totals)\n                  (lambda (a b) (> (cdr a) (cdr b)))))\n;; sorted = ((\"EC2\" . 5000) (\"S3\" . 2000) (\"RDS\" . 1500))\n\n;; Convert for JSON:\n(def top-services\n  (map (lambda (p) (hash (\"service\" (car p)) (\"cost\" (cdr p))))\n       sorted))\n;; top-services = list of hash tables\n\n;; === DATA CONSUMPTION (the gotcha) ===\n\n;; WRONG — crashes with \"PAIR expected\" because items are hash tables:\n;; (for (item top-services)\n;;   (let ((svc (car item)) (cost (cdr item)))  ;; ERROR!\n;;     (displayln svc \": \" cost)))\n\n;; CORRECT — use hget to access hash table fields:\n(for (item top-services)\n  (let ((svc (hash-ref item \"service\" \"Unknown\"))\n        (cost (hash-ref item \"cost\" 0)))\n    (displayln svc \": \" cost)))\n;; EC2: 5000\n;; S3: 2000\n;; RDS: 1500",
    "notes": "This is the follow-on bug from the \"write-json cannot serialize cons pairs\" recipe. After you fix JSON serialization by converting (hash->list) pairs to hash tables, ALL consumer code must be updated from car/cdr to hget/hash-ref. The error message is: \"PAIR expected (car '#&lt;HashTable #N&gt;)\". The backtrace will show car being called on a hash table. Common in report/display code that was written when data was still alist pairs.",
    "related": [
      "write-json-cons-pair-error",
      "gerbil-json-arrays-are-lists-not-vectors",
      "hash-table-basics"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "debounce-thread-pattern",
    "title": "Debounce pattern with thread-sleep! and thread-terminate!",
    "tags": [
      "debounce",
      "thread",
      "timer",
      "cancel",
      "sleep",
      "spawn"
    ],
    "imports": [],
    "code": ";; Debounce pattern: cancel previous timer, start new one.\n;; Useful for running expensive operations after a quiet period.\n\n(def *debounce-thread* #f)\n(def *debounce-mutex* (make-mutex 'debounce))\n\n(def (schedule-debounced! delay-ms action)\n  (mutex-lock! *debounce-mutex*)\n  ;; Cancel previous debounce thread if running\n  (let ((prev *debounce-thread*))\n    (when prev\n      (with-catch (lambda (e) (void))\n        (lambda () (thread-terminate! prev)))))\n  ;; Spawn new timer thread\n  (let ((t (spawn\n              (lambda ()\n                (with-catch\n                  (lambda (e) (void))  ;; silently handle termination\n                  (lambda ()\n                    (thread-sleep! (/ delay-ms 1000.0))\n                    (action)))))))\n    (set! *debounce-thread* t))\n  (mutex-unlock! *debounce-mutex*))\n\n(def (cancel-debounce!)\n  (mutex-lock! *debounce-mutex*)\n  (let ((prev *debounce-thread*))\n    (when prev\n      (with-catch (lambda (e) (void))\n        (lambda () (thread-terminate! prev)))\n      (set! *debounce-thread* #f)))\n  (mutex-unlock! *debounce-mutex*))\n\n;; Usage:\n;; (schedule-debounced! 1500 (lambda () (run-expensive-task)))\n;; (cancel-debounce!)  ;; cancels if still pending",
    "notes": "thread-terminate! on a thread that already exited throws an exception, so always wrap in with-catch. The debounce thread gets terminated when a new event arrives before the delay expires. thread-sleep! accepts seconds as a real number, so divide milliseconds by 1000.0.",
    "related": [
      "mutex-unwind-protect"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "open-process-capture-output",
    "title": "Run external process and capture stdout+stderr with exit status",
    "tags": [
      "process",
      "open-process",
      "spawn",
      "capture",
      "stdout",
      "stderr",
      "exit-status"
    ],
    "imports": [
      ":std/misc/ports"
    ],
    "code": "(import :std/misc/ports)\n\n;; Use open-process (not run-process) when you need to read output\n;; from a command that may exit non-zero. run-process throws on\n;; non-zero exit, but open-process lets you read output first.\n\n(let* ((proc (open-process\n               (list path: \"gerbil\"\n                     arguments: (list \"test\" \"myfile.ss\")\n                     stderr-redirection: #t    ;; merge stderr into stdout\n                     stdout-redirection: #t)))\n       (output (read-all-as-string proc))\n       (status (process-status proc)))\n  ;; status is raw waitpid value: 0 = success, non-zero = failure\n  (if (= status 0)\n    (displayln \"Success: \" output)\n    (displayln \"Failed with status \" status \": \" output)))",
    "notes": "process-status returns the raw waitpid status. Normal exit code N gives N*256 for Gambit's open-process, but in practice checking (= status 0) vs non-zero works. stderr-redirection: #t merges stderr into stdout so read-all-as-string captures both. Use run-process from :std/misc/process when you want automatic exception on failure.",
    "related": [
      "spawn-threads"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "u8vector-character-classifier",
    "title": "Classify string characters into categories using u8vector",
    "tags": [
      "u8vector",
      "classify",
      "string",
      "character",
      "scanner",
      "lexer",
      "parser"
    ],
    "imports": [],
    "code": ";; Pattern: Use a u8vector parallel to a string to classify each\n;; character position (e.g., code=0, string=1, comment=2).\n;; Much faster than re-scanning for each query.\n\n(def (classify-chars text)\n  (let* ((len (string-length text))\n         (regions (make-u8vector len 0)))  ;; default: 0 = code\n    ;; Walk through text, setting classification\n    (let loop ((i 0))\n      (when (< i len)\n        (let ((c (string-ref text i)))\n          (cond\n            ;; String literal: mark all chars as 1\n            ((char=? c #\\\")\n             (u8vector-set! regions i 1)\n             (let str-loop ((j (+ i 1)))\n               (if (>= j len) (loop j)\n                 (let ((sc (string-ref text j)))\n                   (u8vector-set! regions j 1)\n                   (cond\n                     ((char=? sc #\\\\)  ;; skip escape\n                      (when (< (+ j 1) len)\n                        (u8vector-set! regions (+ j 1) 1))\n                      (str-loop (+ j 2)))\n                     ((char=? sc #\\\") (loop (+ j 1)))\n                     (else (str-loop (+ j 1))))))))\n            ;; Line comment: mark rest of line as 2\n            ((char=? c #\\;)\n             (let cmt-loop ((j i))\n               (if (or (>= j len)\n                       (char=? (string-ref text j) #\\newline))\n                 (loop j)\n                 (begin (u8vector-set! regions j 2)\n                        (cmt-loop (+ j 1))))))\n            (else (loop (+ i 1)))))))\n    regions))\n\n;; Query: check if offset is in a non-code region\n(def (in-non-code? regions offset)\n  (and (< offset (u8vector-length regions))\n       (> (u8vector-ref regions offset) 0)))\n\n;; Example:\n;; (def r (classify-chars \"(def x \\\"hi\\\") ; comment\"))\n;; (in-non-code? r 7)  ;; #t — inside string\n;; (in-non-code? r 13) ;; #t — inside comment\n;; (in-non-code? r 0)  ;; #f — code",
    "notes": "u8vector is ideal for per-character classification because it uses 1 byte per position (vs 8 bytes for a vector of fixnums). make-u8vector accepts an initial fill value. This scan-once-query-many pattern avoids O(n*m) cost when checking multiple positions against string/comment boundaries. Extend the cond for block comments (#| ... |#) with a depth counter for nesting.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "defstruct-positional-constructor",
    "title": "Defstruct constructors use positional args, not keywords",
    "tags": [
      "defstruct",
      "make-struct",
      "constructor",
      "positional",
      "arity",
      "keyword"
    ],
    "imports": [],
    "code": ";; WRONG: defstruct constructor does NOT accept keyword arguments\n(defstruct point (x y z) transparent: #t)\n;; (make-point x: 1 y: 2 z: 3)  ;; ERROR: arguments don't match object size\n\n;; CORRECT: use positional arguments in field order\n(make-point 1 2 3)  ;; => #<point x: 1 y: 2 z: 3>\n\n;; For structs with many fields, document the order:\n(defstruct config (host port timeout ssl debug) transparent: #t)\n;; Constructor: (make-config host port timeout ssl debug)\n(make-config \"localhost\" 8080 30 #f #t)\n\n;; If you need keyword args, use a wrapper:\n(def (make-config* host: (host \"localhost\")\n                   port: (port 80)\n                   timeout: (timeout 30)\n                   ssl: (ssl #f)\n                   debug: (debug #f))\n  (make-config host port timeout ssl debug))",
    "notes": "Gerbil's defstruct generates a make-NAME constructor that takes positional arguments in the same order as the field declaration. Keyword arguments are NOT supported. This often causes \"arguments don't match object size\" errors when trying to use keyword syntax. The wrapper pattern using def with keyword args provides a convenient alternative when needed.",
    "related": [
      "define-structs",
      "typed-struct-field-access"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "open-process-environment",
    "title": "Run subprocess with custom environment variables",
    "tags": [
      "open-process",
      "environment",
      "subprocess",
      "gxc",
      "GERBIL_LOADPATH",
      "spawn"
    ],
    "imports": [
      ":std/misc/ports"
    ],
    "code": ";; open-process with custom environment variables for subprocess\n(let* ((proc (open-process\n               (list path: \"gxc\"\n                     arguments: (list \"-S\" \"myfile.ss\")\n                     ;; Set environment for the subprocess\n                     environment: (list \"GERBIL_LOADPATH=/path/to/libs\"\n                                        \"HOME=/home/user\")\n                     stderr-redirection: #t\n                     stdout-redirection: #t)))\n       (output (read-all-as-string proc))\n       (status (process-status proc)))\n  (if (= status 0)\n    output\n    (error \"gxc failed\" output)))\n\n;; Common use: pass GERBIL_LOADPATH to gxc for project-local modules\n(def (run-gxc-with-loadpath file-path loadpaths)\n  (let* ((env (if (pair? loadpaths)\n                (list (string-append \"GERBIL_LOADPATH=\"\n                        (string-join loadpaths \":\")))\n                #f))\n         (proc (open-process\n                 (list path: \"gxc\"\n                       arguments: (list \"-S\" file-path)\n                       environment: env\n                       stderr-redirection: #t\n                       stdout-redirection: #t)))\n         (output (read-all-as-string proc))\n         (status (process-status proc)))\n    (values status output)))",
    "notes": "The environment: parameter takes a list of \"KEY=VALUE\" strings. If #f (default), the subprocess inherits the parent's environment. This is essential for running gxc with custom GERBIL_LOADPATH for project-local module resolution. Note: :std/misc/ports is needed for read-all-as-string.",
    "related": [
      "run-external-process",
      "gerbil-build-loadpath"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "atomic-json-file-cache",
    "title": "Atomic JSON file writes for caching",
    "tags": [
      "json",
      "cache",
      "atomic",
      "write",
      "persist",
      "file",
      "mtime"
    ],
    "imports": [
      ":std/text/json"
    ],
    "code": ";; Persist data to JSON file atomically (write to temp, then rename)\n(import :std/text/json)\n\n(def (save-json-atomically! file-path data)\n  (let ((temp-path (string-append file-path \".tmp\")))\n    ;; Write to temporary file\n    (call-with-output-file temp-path\n      (lambda (port)\n        (write-json data port)))\n    ;; Atomic rename\n    (rename-file temp-path file-path)))\n\n;; Load JSON with error handling\n(def (load-json-safely file-path default)\n  (if (file-exists? file-path)\n    (with-catch\n      (lambda (e) default)\n      (lambda ()\n        (call-with-input-file file-path read-json)))\n    default))\n\n;; Example: cache with modification time tracking\n(def (save-cache! cache-path items get-mtime-fn)\n  (let ((cache-data (make-hash-table)))\n    (hash-for-each\n      (lambda (key value)\n        (hash-put! cache-data key\n          (hash (\"mtime\" (get-mtime-fn key))\n                (\"data\" value))))\n      items)\n    (save-json-atomically! cache-path\n      (hash (\"version\" 1)\n            (\"items\" cache-data)))))",
    "notes": "Atomic writes prevent data corruption if the process crashes mid-write. The pattern is: write to temp file, then rename. rename-file is atomic on POSIX systems. For caches, storing modification timestamps allows detecting stale entries on reload.",
    "related": [
      "read-json-file",
      "hash-table-basics"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "current-second-time",
    "title": "Get current time in seconds",
    "tags": [
      "time",
      "seconds",
      "current-second",
      "current-time",
      "timestamp",
      "elapsed",
      "mtime"
    ],
    "imports": [],
    "code": ";; Get current time in seconds (floating point)\n\n;; Method 1: Gambit's current-second (simplest)\n(current-second)  ;; => 1738713852.1234567\n\n;; Method 2: Via time->seconds (more explicit)\n(time->seconds (current-time))  ;; => 1738713852.1234567\n\n;; Method 3: If SRFI-19 is imported, use ##current-time to get Gambit's version\n(import :std/srfi/19)\n(time->seconds (##current-time))  ;; => works (bypasses SRFI-19 shadow)\n\n;; WRONG: Without ##, SRFI-19 shadows current-time with incompatible type\n;; (time->seconds (current-time))  ;; ERROR after importing :std/srfi/19\n\n;; Get file modification time as seconds:\n(def (file-mtime path)\n  (time->seconds\n    (file-info-last-modification-time\n      (file-info path))))\n\n;; Measure elapsed time:\n(let ((start (current-second)))\n  (do-work)\n  (let ((elapsed (- (current-second) start)))\n    (displayln \"Took \" elapsed \" seconds\")))",
    "notes": "current-second is Gambit's built-in (no import needed). Note: it's current-second (singular), NOT current-seconds. If you import :std/srfi/19, it shadows current-time — use ##current-time to access the Gambit version. For file mtimes, use file-info + file-info-last-modification-time + time->seconds.",
    "related": [
      "srfi-19-current-time-shadows-gambit",
      "date-time-formatting-srfi-19"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gambit-path-builtins",
    "title": "Gambit path manipulation builtins (path-directory, path-normalize, path-strip-directory, path-extension)",
    "tags": [
      "path",
      "directory",
      "normalize",
      "gambit",
      "builtin",
      "file",
      "basename",
      "dirname",
      "extension"
    ],
    "imports": [],
    "code": ";; Gambit provides path manipulation primitives — NO import needed.\n;; These are available in any Gerbil module automatically.\n\n;; path-directory — like dirname, returns directory portion with trailing /\n(path-directory \"/home/user/project/src/main.ss\")\n;; => \"/home/user/project/src/\"\n\n(path-directory \"src/main.ss\")\n;; => \"src/\"\n\n(path-directory \"main.ss\")\n;; => \"\"\n\n;; path-strip-directory — like basename, returns filename only\n(path-strip-directory \"/home/user/project/src/main.ss\")\n;; => \"main.ss\"\n\n;; path-strip-extension — remove file extension\n(path-strip-extension \"main.ss\")\n;; => \"main\"\n\n(path-strip-extension \"/path/to/module.ss\")\n;; => \"/path/to/module\"\n\n;; path-extension — get file extension (includes dot)\n(path-extension \"main.ss\")\n;; => \".ss\"\n\n;; path-normalize — resolve to absolute path, canonicalize . and ..\n(path-normalize \"src/../lib/module.ss\")\n;; => \"/home/user/project/lib/module.ss\"  (resolves relative to cwd)\n\n;; path-normalize with origin-directory (2nd arg)\n(path-normalize \"../other/file.ss\" \"/home/user/project/src/\")\n;; => \"/home/user/project/other/file.ss\"\n\n;; COMMON PATTERN: compute relative path between two files\n;; (useful for generating relative import paths in LSP/tooling)\n(def (compute-relative-path from-file to-file)\n  (let* ((from-dir (path-directory (path-normalize from-file)))\n         (to-norm (path-normalize to-file))\n         (to-no-ext (path-strip-extension to-norm)))\n    ;; Build relative path from from-dir to to-no-ext\n    ;; (simplified — real implementation needs directory traversal)\n    (string-append \"./\" (path-strip-directory to-no-ext))))",
    "notes": "These are Gambit primitives (##path-directory etc.) exposed as safe wrappers. No import is needed — they're always available. Key gotcha: path-directory returns trailing slash (e.g., \"src/\" not \"src\"). path-normalize resolves against cwd by default; pass a second argument to resolve against a different origin directory. These are NOT from :std/misc/path — that module provides different utilities like path-default-extension and path-force-extension.",
    "related": [
      "read-file-to-string",
      "read-file-lines"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "http-multipart-file-upload",
    "title": "HTTP multipart/form-data file upload",
    "tags": [
      "http",
      "multipart",
      "upload",
      "file",
      "form-data",
      "post",
      "binary",
      "attachment"
    ],
    "imports": [
      ":std/net/request",
      ":std/misc/ports",
      ":std/format"
    ],
    "code": "(import :std/net/request :std/misc/ports :std/format)\\n\\n;; Gerbil's http-post does NOT have built-in multipart support.\\n;; You must manually construct the multipart/form-data body.\\n\\n(def (http-upload-file url file-path\\n       headers: (extra-headers '())\\n       field-name: (field-name \\\"file\\\"))\\n  (let* ((boundary (format \\\"----GerbilBoundary~a\\\" (random-integer 999999999)))\\n         (filename (path-strip-directory file-path))\\n         (file-bytes (call-with-input-file file-path read-all-as-u8vector))\\n         ;; Build multipart body as string prefix + binary + string suffix\\n         (prefix (string-append\\n                   \\\"--\\\" boundary \\\"\\\\r\\\\n\\\"\\n                   (format \\\"Content-Disposition: form-data; name=\\\\\\\"~a\\\\\\\"; filename=\\\\\\\"~a\\\\\\\"\\\\r\\\\n\\\" field-name filename)\\n                   \\\"Content-Type: application/octet-stream\\\\r\\\\n\\\"\\n                   \\\"\\\\r\\\\n\\\"))\\n         (suffix (string-append \\\"\\\\r\\\\n--\\\" boundary \\\"--\\\\r\\\\n\\\"))\\n         ;; Combine into single u8vector\\n         (prefix-bytes (string->bytes prefix))\\n         (suffix-bytes (string->bytes suffix))\\n         (body (u8vector-append prefix-bytes file-bytes suffix-bytes))\\n         (content-type (format \\\"multipart/form-data; boundary=~a\\\" boundary))\\n         (all-headers (cons (cons \\\"Content-Type\\\" content-type) extra-headers)))\\n    (http-post url data: body headers: all-headers)))\\n\\n;; Example: Upload attachment to Jira\\n;; (def resp (http-upload-file\\n;;   \\\"https://your-jira.atlassian.net/rest/api/3/issue/PROJ-123/attachments\\\"\\n;;   \\\"/path/to/file.pdf\\\"\\n;;   headers: '((\\\"Authorization\\\" . \\\"Basic ...\\\") (\\\"X-Atlassian-Token\\\" . \\\"no-check\\\"))))\\n;; (request-status resp)  ;; => 200",
    "notes": "Gerbil's :std/net/request does NOT support multipart/form-data natively. You must manually construct the body with boundary delimiters, Content-Disposition headers, and binary content. The data: keyword accepts u8vector for binary data. Use u8vector-append to combine the text prefix, binary file content, and text suffix into a single body. For APIs requiring multipart upload (like Jira attachments), you may also need extra headers like X-Atlassian-Token: no-check. Alternative approach: use open-process to call curl for complex multipart needs.",
    "related": [
      "http-get",
      "http-post-json"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "csv-write-output",
    "title": "Write CSV output with :std/text/csv",
    "tags": [
      "csv",
      "write",
      "output",
      "table",
      "export",
      "file",
      "text"
    ],
    "imports": [
      ":std/text/csv"
    ],
    "code": "(import :std/text/csv)\\n\\n;; Write CSV to file\\n(write-csv-file \\\"output.csv\\\"\\n  '((\\\"Name\\\" \\\"Age\\\" \\\"City\\\")\\n    (\\\"Alice\\\" \\\"30\\\" \\\"NYC\\\")\\n    (\\\"Bob\\\" \\\"25\\\" \\\"LA\\\")))\\n\\n;; Write CSV to stdout\\n(write-csv-lines\\n  '((\\\"Key\\\" \\\"Summary\\\" \\\"Status\\\")\\n    (\\\"PROJ-1\\\" \\\"Fix bug\\\" \\\"Open\\\")\\n    (\\\"PROJ-2\\\" \\\"Add feature\\\" \\\"Done\\\"))\\n  (current-output-port))\\n\\n;; Write single line\\n(write-csv-line '(\\\"field1\\\" \\\"field2\\\" \\\"field3\\\") (current-output-port))\\n\\n;; All values must be strings, numbers, symbols, or #f (empty).\\n;; Fields with commas or quotes are automatically escaped.",
    "notes": "write-csv-file takes a path (or path+settings) and a list of rows. write-csv-lines and write-csv-line take a port. Default format is RFC 4180 (comma-separated, LF line endings). Fields containing commas, quotes, or newlines are automatically quoted and escaped. Non-string values should be converted with format or number->string before passing.",
    "related": [
      "read-json-file",
      "hash-table-basics"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "plain-text-aligned-table",
    "title": "Print aligned plain text table to stdout",
    "tags": [
      "table",
      "output",
      "align",
      "columns",
      "format",
      "display",
      "print",
      "cli"
    ],
    "imports": [
      ":std/iter",
      ":std/format",
      ":std/srfi/13"
    ],
    "code": "(import :std/iter :std/format :std/srfi/13)\\n\\n(def (print-table headers rows)\\n  \\\"Print aligned columns with header separator line.\\\"\\n  (let* ((all-rows (cons headers rows))\\n         ;; Calculate max width for each column\\n         (widths (map (lambda (col-idx)\\n                        (apply max\\n                          (map (lambda (row)\\n                                 (string-length\\n                                   (if (< col-idx (length row))\\n                                     (format \\\"~a\\\" (list-ref row col-idx))\\n                                     \\\"\\\")))\\n                               all-rows)))\\n                      (iota (length headers)))))\\n         ;; Format one row with padding\\n         (fmt-row (lambda (row)\\n                    (string-join\\n                      (map (lambda (val width)\\n                             (string-pad-right (format \\\"~a\\\" val) width))\\n                           row widths)\\n                      \\\"  \\\"))))\\n    ;; Print header\\n    (displayln (fmt-row headers))\\n    ;; Print separator\\n    (displayln (string-join (map (lambda (w) (make-string w #\\\\-)) widths) \\\"  \\\"))\\n    ;; Print rows\\n    (for (row rows)\\n      (displayln (fmt-row row)))))\\n\\n;; Example:\\n;; (print-table\\n;;   [\\\"Key\\\" \\\"Summary\\\" \\\"Status\\\"]\\n;;   [[\\\"PROJ-1\\\" \\\"Fix login bug\\\" \\\"Open\\\"]\\n;;    [\\\"PROJ-2\\\" \\\"Add search\\\" \\\"Done\\\"]])\\n;;\\n;; Output:\\n;; Key     Summary         Status\\n;; ------  --------------  ------\\n;; PROJ-1  Fix login bug   Open\\n;; PROJ-2  Add search      Done",
    "notes": "Uses string-pad-right from :std/srfi/13 for column alignment. iota from :std/srfi/1 can also be used but (iota n) works with :std/iter's for. All values are coerced to strings via (format \\\"~a\\\" val). For wide tables, consider adding a truncate-string helper: (def (trunc s n) (if (> (string-length s) n) (string-append (substring s 0 (- n 3)) \\\"...\\\") s)).",
    "related": [
      "csv-write-output"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "rest-api-client-pattern",
    "title": "REST API client with JSON, auth, error handling, and pagination",
    "tags": [
      "rest",
      "api",
      "client",
      "http",
      "json",
      "pagination",
      "auth",
      "basic-auth",
      "request"
    ],
    "imports": [
      ":std/net/request",
      ":std/net/uri",
      ":std/text/json",
      ":std/text/base64",
      ":std/format"
    ],
    "code": "(import :std/net/request :std/net/uri :std/text/json :std/text/base64 :std/format)\\n\\n;; Basic auth header\\n(def (make-basic-auth user password)\\n  (format \\\"Basic ~a\\\" (base64-encode (string->bytes (format \\\"~a:~a\\\" user password)))))\\n\\n;; Core request function - returns parsed JSON body, throws on error\\n(def (api-request method url\\n       auth: (auth #f)\\n       data: (data #f)\\n       headers: (extra-headers '()))\\n  (let* ((hdrs (append\\n                 `((\\\"Accept\\\" . \\\"application/json\\\")\\n                   (\\\"Content-Type\\\" . \\\"application/json\\\"))\\n                 (if auth `((\\\"Authorization\\\" . ,auth)) '())\\n                 extra-headers))\\n         (body (and data (if (string? data) data (json-object->string data))))\\n         (resp (case method\\n                 ((GET)    (http-get url headers: hdrs))\\n                 ((POST)   (http-post url headers: hdrs data: body))\\n                 ((PUT)    (http-put url headers: hdrs data: body))\\n                 ((DELETE) (http-delete url headers: hdrs)))))\\n    (let ((status (request-status resp)))\\n      (if (and (>= status 200) (< status 300))\\n        (if (= status 204) (void) (request-json resp))\\n        (error (format \\\"HTTP ~a: ~a\\\" status (request-text resp)))))))\\n\\n;; Auto-paginated GET - collects all pages into a single list\\n(def (api-get-all url auth\\n       results-key: (results-key 'values)\\n       max-per-page: (max-per-page 100))\\n  (let loop ((offset 0) (acc '()))\\n    (let* ((sep (if (string-contains url \\\"?\\\") \\\"&\\\" \\\"?\\\"))\\n           (page-url (format \\\"~a~astartAt=~a&maxResults=~a\\\" url sep offset max-per-page))\\n           (body (api-request 'GET page-url auth: auth))\\n           (items (if (hash-table? body) (hash-ref body results-key '()) body))\\n           (total (if (hash-table? body) (hash-ref body 'total 0) 0))\\n           (all (append acc (if (list? items) items '()))))\\n      (if (and (hash-table? body) (< (+ offset (length items)) total) (> (length items) 0))\\n        (loop (+ offset (length items)) all)\\n        all))))",
    "notes": "This pattern provides a complete REST API client foundation for CLI tools. Key details: (1) request-json parses the response body as JSON automatically. (2) HTTP 204 (No Content) returns void since there's no body. (3) The pagination helper handles Jira-style startAt/maxResults but the pattern works for any offset-based API. (4) data: can be a hash table (auto-serialized) or pre-serialized string. (5) Use uri-encode from :std/net/uri for query parameter values.",
    "related": [
      "http-get",
      "http-post-json",
      "http-multipart-file-upload"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "request-json-symbol-keys",
    "title": "Force request-json to return symbol keys for let-hash",
    "tags": [
      "request-json",
      "symbol",
      "keys",
      "let-hash",
      "parameterize",
      "read-json-key-as-symbol"
    ],
    "imports": [
      ":std/net/request",
      ":std/text/json",
      ":std/sugar"
    ],
    "code": "(import :std/net/request :std/text/json :std/sugar)\n\n;; PROBLEM: request-json returns hash tables with STRING keys by default.\n;; But let-hash (.field, .?field) expects SYMBOL keys.\n;;\n;; WRONG — keys are strings, let-hash accessors silently return #f:\n;; (let ((body (request-json resp)))\n;;   (let-hash body\n;;     .?name))        ;; => #f (looking for symbol 'name, but key is string \"name\")\n\n;; CORRECT — wrap in parameterize to get symbol keys:\n(def (check-response resp)\n  (let ((status (request-status resp)))\n    (if (and (>= status 200) (< status 300))\n      (let ((text (request-text resp)))\n        (if (and text (> (string-length text) 0))\n          (parameterize ((read-json-key-as-symbol? #t))\n            (with-input-from-string text read-json))\n          #t))\n      (error (format \"HTTP ~a: ~a\" status (request-text resp))))))\n\n;; Usage:\n(let* ((resp (http-get \"https://api.example.com/data\"\n               headers: '((\"Accept\" . \"application/json\"))))\n       (body (check-response resp)))\n  (let-hash body\n    (displayln .?name)     ;; works — symbol key\n    (displayln .?status))) ;; works — symbol key\n\n;; WHY: request-json calls read-json internally, which defaults to\n;; string keys. Using request-text + read-json with parameterize\n;; gives you control over the key type. This is essential when using\n;; let-hash to destructure API responses.",
    "notes": "request-json uses read-json internally which defaults to string keys. The parameterize approach uses request-text first to get the raw string, then parses it with read-json inside a parameterize block that sets read-json-key-as-symbol? to #t. This gives symbol keys that work with let-hash's .field and .?field syntax. Without this, let-hash silently returns #f for all lookups because it looks for symbol keys but finds string keys.",
    "related": [
      "http-get",
      "let-hash-destructure",
      "rest-api-client-json-auth-pagination"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "getopt-subcommand-handler-two-args",
    "title": "getopt subcommand handler receives (cmd opt), not (opt) with .command",
    "tags": [
      "getopt",
      "subcommand",
      "command",
      "handler",
      "call-with-getopt",
      "cli"
    ],
    "imports": [
      ":std/cli/getopt",
      ":std/sugar"
    ],
    "code": "(import :std/cli/getopt :std/sugar)\n\n;; CRITICAL: With subcommands, the handler takes TWO arguments: (cmd opt)\n;; NOT one argument with .command in the hash.\n\n;; Define commands\n(def list-cmd\n  (command 'list\n    help: \"List items\"\n    (option 'filter \"--filter\" \"-f\" default: #f help: \"Filter\")))\n\n(def create-cmd\n  (command 'create\n    help: \"Create an item\"\n    (argument 'name help: \"Item name\")))\n\n;; CORRECT — handler takes (cmd opt):\n(def (main . args)\n  (call-with-getopt\n    (lambda (cmd opt)\n      (case cmd\n        ((list)\n         (let-hash opt\n           (displayln \"listing with filter: \" .?filter)))\n        ((create)\n         (let-hash opt\n           (displayln \"creating: \" .name)))))\n    args\n    program: \"my-tool\"\n    help: \"My CLI tool\"\n    list-cmd create-cmd))\n\n;; WRONG — this crashes with \"Wrong number of arguments\":\n;; (lambda (opt)\n;;   (let-hash opt\n;;     (case .command ...)))  ;; ERROR: handler called with 2 args, not 1",
    "notes": "This contradicts the existing cookbook recipe which shows (lambda (opt) ... (case .command ...)). In Gerbil v0.19+, when using subcommands (command forms), call-with-getopt calls the handler with TWO arguments: the command symbol and the options hash. Without subcommands (just flags/options), the handler takes ONE argument (the options hash). The error message is: \"Wrong number of arguments passed to procedure (#<procedure> 'command-name #<HashTable>)\".",
    "related": [
      "cli-getopt-subcommands",
      "let-hash-destructure"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "string-subst-arg-order",
    "title": "string-subst takes (str old new), not (old new str)",
    "tags": [
      "string-subst",
      "string",
      "replace",
      "substitute",
      "misc/string",
      "argument-order"
    ],
    "imports": [
      ":std/misc/string"
    ],
    "code": "(import :std/misc/string)\n\n;; string-subst argument order: (string-subst str old new)\n;; The string to modify comes FIRST, then old, then new.\n\n(string-subst \"hello world\" \"world\" \"gerbil\")\n;; => \"hello gerbil\"\n\n(string-subst \"/pets/{petId}\" \"{\" \"\")\n;; => \"/pets/petId}\"\n\n;; Chaining substitutions with let*:\n(let* ((s \"/pets/{petId}/toys\")\n       (s (string-subst s \"{\" \"\"))\n       (s (string-subst s \"}\" \"\"))\n       (s (string-subst s \"/\" \"-\")))\n  s)\n;; => \"-pets-petId-toys\"\n\n;; Optional count: keyword limits replacements\n(string-subst \"aaa\" \"a\" \"b\" count: 2)\n;; => \"bba\"",
    "notes": "Easy to confuse with other languages where replace(old, new, str) is common. In Gerbil's :std/misc/string, it's (string-subst str old new). The optional count: keyword limits the number of replacements.",
    "related": [
      "string-trim-prefix"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "camelcase-to-kebab-case",
    "title": "Convert camelCase/PascalCase to kebab-case with pregexp",
    "tags": [
      "camelCase",
      "kebab-case",
      "convert",
      "pregexp",
      "naming",
      "identifier"
    ],
    "imports": [
      ":std/pregexp",
      ":std/srfi/13"
    ],
    "code": "(import :std/pregexp :std/srfi/13)\n\n;; Convert camelCase or PascalCase to kebab-case.\n;; Handles consecutive uppercase letters correctly:\n;;   \"getAPIKey\" -> \"get-api-key\" (not \"get-a-p-i-key\")\n;;   \"XMLParser\" -> \"xml-parser\"\n(def (camel-case->kebab-case s)\n  (let* (;; Step 1: Insert hyphen between consecutive uppercase run and next word\n         ;; \"getAPIKey\" -> \"getAPI-Key\"\n         (s1 (pregexp-replace* \"([A-Z]+)([A-Z][a-z])\" s \"\\\\1-\\\\2\"))\n         ;; Step 2: Insert hyphen between lowercase/digit and uppercase\n         ;; \"getAPI-Key\" -> \"get-API-Key\"\n         (s2 (pregexp-replace* \"([a-z0-9])([A-Z])\" s1 \"\\\\1-\\\\2\")))\n    (string-downcase s2)))\n\n(camel-case->kebab-case \"getUserById\")    ;; => \"get-user-by-id\"\n(camel-case->kebab-case \"listPets\")       ;; => \"list-pets\"\n(camel-case->kebab-case \"createHTTPServer\") ;; => \"create-http-server\"\n(camel-case->kebab-case \"getAPIKey\")      ;; => \"get-api-key\"\n(camel-case->kebab-case \"XMLParser\")      ;; => \"xml-parser\"\n(camel-case->kebab-case \"Pet\")            ;; => \"pet\"\n(camel-case->kebab-case \"simple\")         ;; => \"simple\"",
    "notes": "Two-pass regex approach handles the tricky case of consecutive uppercase letters (like HTTP, API, XML). The first pass handles \"APIKey\" -> \"API-Key\" and the second handles \"getAPI\" -> \"get-API\". Then string-downcase normalizes everything. string-downcase is from :std/srfi/13. pregexp-replace* replaces ALL matches (not just the first).",
    "related": [
      "regular-expressions"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "pretty-print-code-generation",
    "title": "Use pretty-print for Scheme code generation / emission",
    "tags": [
      "pretty-print",
      "code-generation",
      "emit",
      "s-expression",
      "codegen",
      "format"
    ],
    "imports": [],
    "code": ";; pretty-print is a Gambit builtin — no import needed.\n;; It formats s-expressions with proper indentation.\n\n;; Emit a single form as a string:\n(def (emit-form form)\n  (call-with-output-string\n    (lambda (p) (pretty-print form p))))\n\n(emit-form '(def (add x y) (+ x y)))\n;; => \"(def (add x y) (+ x y))\\n\"\n\n;; Emit multiple forms with blank lines between:\n(def (emit-forms forms)\n  (call-with-output-string\n    (lambda (p)\n      (for-each (lambda (form)\n                  (pretty-print form p)\n                  (newline p))\n                forms))))\n\n;; Use quasiquote to build forms with computed parts:\n(let ((fn-name 'my-function)\n      (body '(+ x y)))\n  (emit-form `(def (,fn-name x y) ,body)))\n;; => \"(def (my-function x y) (+ x y))\\n\"\n\n;; Useful for code generators that output .ss files:\n(def (generate-module exports definitions)\n  (string-append\n    (emit-form `(export ,@exports))\n    \"\\n\"\n    (emit-forms definitions)))",
    "notes": "pretty-print is from Gambit (no import needed). It handles long forms by breaking across lines with proper indentation. For code generation, combine with quasiquote (backtick) and unquote (comma) to build s-expressions with dynamic parts, then pretty-print to get properly formatted output. string-append multiple emit-form calls to build complete source files.",
    "related": [
      "regular-expressions"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "string-to-keyword-vs-symbol-for-codegen",
    "title": "Use string->keyword (not string->symbol) for keyword parameter code generation",
    "tags": [
      "keyword",
      "string->keyword",
      "string->symbol",
      "pretty-print",
      "code generation",
      "codegen"
    ],
    "imports": [],
    "code": ";; PROBLEM: When generating Gerbil code with pretty-print, keyword\n;; parameters must use actual keywords (created via string->keyword),\n;; NOT symbols with a colon suffix (created via string->symbol).\n;;\n;; WRONG — creates a regular symbol, pretty-prints as |body:| (escaped):\n(string->symbol \"body:\")     ;; => |body:|\n;; (keyword? (string->symbol \"body:\"))  ;; => #f\n;; pretty-print wraps it in vertical bars: |body:|\n;; The reader treats |body:| as a NON-keyword symbol\n;; This causes \"Bad syntax; invalid match target\" in def parameter lists\n\n;; CORRECT — creates an actual keyword, pretty-prints as body: (unescaped):\n(string->keyword \"body\")     ;; => body:\n;; (keyword? (string->keyword \"body\"))  ;; => #t\n;; pretty-print outputs it as: body:\n;; The reader treats body: as a keyword — works correctly in def\n\n;; Example in code generation context:\n(import :std/format)\n(let ((kw (string->keyword \"body\"))\n      (param-list `(def (my-fn ,kw (body #f)) body)))\n  (call-with-output-string (lambda (p) (pretty-print param-list p))))\n;; => \"(def (my-fn body: (body #f)) body)\\n\"\n\n;; Note: string->keyword takes the name WITHOUT the colon suffix.\n;; The colon is added automatically by the keyword representation.",
    "notes": "Key gotcha for code generation: string->symbol with a colon suffix creates a regular symbol that pretty-print escapes with vertical bars (|body:|). The reader treats |body:| differently from body: — it's NOT a keyword. Use string->keyword (without the colon) to create actual keywords that pretty-print correctly. Also applies to write and display.",
    "related": [
      "optional-keyword-arguments",
      "pretty-print-code-generation"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "void-is-truthy-use-hash-get-not-hash-ref",
    "title": "hash-ref returns #!void for missing keys (truthy!); use hash-get for conditional checks",
    "tags": [
      "void",
      "truthy",
      "hash-ref",
      "hash-get",
      "when",
      "conditional",
      "gotcha"
    ],
    "imports": [],
    "code": ";; GOTCHA: #!void is TRUTHY in Gerbil. Only #f is falsy.\n;;\n;; hash-ref without a default returns #!void for missing keys (not #f).\n;; This means conditional checks like (if value ...) will be wrong.\n\n(def ht (hash (\"a\" 1)))\n\n;; WRONG — hash-ref returns #!void for missing key, which is truthy:\n(let ((val (hash-ref ht \"missing\")))\n  (if val \"found\" \"not-found\"))\n;; => \"found\" — WRONG! #!void is truthy\n\n;; ALSO WRONG — (when ...) returns #!void when condition is false:\n(def (maybe-get key)\n  (when (hash-key? ht key)\n    (hash-ref ht key)))\n(if (maybe-get \"missing\") \"found\" \"not-found\")\n;; => \"found\" — WRONG! (when ...) returned #!void which is truthy\n\n;; CORRECT — use hash-get which returns #f for missing keys:\n(let ((val (hash-get ht \"missing\")))\n  (if val \"found\" \"not-found\"))\n;; => \"not-found\" — correct\n\n;; CORRECT — use if instead of when, with explicit #f:\n(def (maybe-get-v2 key)\n  (if (hash-key? ht key)\n    (hash-ref ht key)\n    #f))\n(if (maybe-get-v2 \"missing\") \"found\" \"not-found\")\n;; => \"not-found\" — correct",
    "notes": "This is a common source of bugs in Gerbil. The (when ...) form returns #!void when the condition is false, and #!void is truthy. So if you store the result of (when ...) and later test it, it will appear to be a valid value. Always use (if ... ... #f) when you need to return #f for the false case, or use hash-get instead of hash-ref for lookups that might miss.",
    "related": [
      "hash-table-operations"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "deduplicate-names-hash-counter",
    "title": "Deduplicate names with hash table counter",
    "tags": [
      "deduplicate",
      "unique",
      "names",
      "collision",
      "hash",
      "counter",
      "codegen"
    ],
    "imports": [],
    "code": ";; Pattern: Make names unique by appending numeric suffix on collision\n;; Useful for code generation when input may have duplicate identifiers\n\n(def (deduplicate-names items get-name set-name!)\n  (let ((seen (make-hash-table)))\n    (for-each\n     (lambda (item)\n       (let* ((base-name (get-name item))\n              (count (hash-ref seen base-name 0))\n              (unique-name (if (= count 0)\n                             base-name\n                             (string-append base-name \"-\" (number->string count)))))\n         (hash-put! seen base-name (+ count 1))\n         (set-name! item unique-name)))\n     items)\n    items))\n\n;; Example: deduplicate field names in a list of field hashes\n(def fields (list (hash (\"name\" \"id\") (\"type\" \"int\"))\n                  (hash (\"name\" \"id\") (\"type\" \"string\"))\n                  (hash (\"name\" \"name\") (\"type\" \"string\"))))\n\n(deduplicate-names fields\n  (lambda (f) (hash-ref f \"name\"))\n  (lambda (f new) (hash-put! f \"name\" new)))\n\n;; Verify: first \"id\" kept as-is, second becomes \"id-1\"\n(and (equal? (hash-ref (list-ref fields 0) \"name\") \"id\")\n     (equal? (hash-ref (list-ref fields 1) \"name\") \"id-1\")\n     (equal? (hash-ref (list-ref fields 2) \"name\") \"name\"))",
    "notes": "This pattern is essential for code generators that produce Scheme identifiers from external sources (like OpenAPI/Swagger specs) where name collisions can occur. The counter-based approach ensures stable, deterministic naming when applied to sorted input. Sort items first for reproducible output.",
    "related": [
      "hash-table-operations"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "defstruct-naming-avoid-accessor-collision",
    "title": "Avoid defstruct accessor name collisions with -t suffix",
    "tags": [
      "defstruct",
      "struct",
      "accessor",
      "collision",
      "naming",
      "codegen",
      "type"
    ],
    "imports": [],
    "code": ";; PROBLEM: defstruct creates accessors named struct-name-field-name.\n;; If you have:\n;;   (defstruct foo (bar) ...)        ;; creates accessor foo-bar\n;;   (defstruct foo-bar (x) ...)      ;; tries to create struct foo-bar\n;; This causes a \"rebind conflict\" because foo-bar is already the accessor.\n\n;; SOLUTION: Use a -t suffix for type/struct names to avoid collisions.\n;; This is a common convention in Scheme/Lisp for type names.\n\n;; Example defstructs after applying this convention:\n(defstruct dashboard-gadget-t (id title position) transparent: #t)\n(defstruct dashboard-gadget-position-t (row column) transparent: #t)\n\n;; Create instances to verify both structs work\n(def gadget (make-dashboard-gadget-t 1 \"My Gadget\" (make-dashboard-gadget-position-t 0 1)))\n\n;; Accessors are now distinct:\n(and (dashboard-gadget-t? gadget)\n     (= (dashboard-gadget-t-id gadget) 1)\n     (dashboard-gadget-position-t? (dashboard-gadget-t-position gadget))\n     (= (dashboard-gadget-position-t-column (dashboard-gadget-t-position gadget)) 1))",
    "notes": "This pattern is essential when generating structs from external schemas (OpenAPI, JSON Schema, etc.) where schema names like \"Foo\" and \"FooBar\" would create accessor collisions. The -t suffix is a Lisp/Scheme convention indicating a type name. Alternative suffixes like -type or -struct also work.",
    "related": [
      "define-structs"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "sanitize-string-to-scheme-identifier",
    "title": "Sanitize arbitrary strings to valid Scheme identifiers",
    "tags": [
      "sanitize",
      "identifier",
      "string",
      "scheme-id",
      "codegen",
      "pregexp"
    ],
    "imports": [
      ":std/pregexp",
      ":std/srfi/13"
    ],
    "code": "(import :std/pregexp :std/srfi/13)\n\n;; Convert any string to a valid Scheme identifier\n;; Handles: spaces, punctuation, unicode, empty strings\n(def (string->scheme-id s)\n  (let* ((s (pregexp-replace* \"[^a-zA-Z0-9]+\" s \"-\"))  ;; non-alphanum -> hyphen\n         (s (string-trim-prefix \"-\" s))                ;; trim leading hyphens\n         (s (string-trim-suffix \"-\" s)))               ;; trim trailing hyphens\n    (if (string=? s \"\") \"unnamed\" (string-downcase s))))\n\n;; Test cases\n(and (equal? (string->scheme-id \"getUserById\") \"getuserbyid\")\n     (equal? (string->scheme-id \"The column position.\") \"the-column-position\")\n     (equal? (string->scheme-id \"foo_bar_baz\") \"foo-bar-baz\")\n     (equal? (string->scheme-id \"  spaces  \") \"spaces\")\n     (equal? (string->scheme-id \"\") \"unnamed\")\n     (equal? (string->scheme-id \"!!!@@@###\") \"unnamed\"))",
    "notes": "Use string->scheme-id for arbitrary external strings (JSON property names, user input). For camelCase identifiers like \"getUserById\", a separate camel-case->kebab-case function that inserts hyphens at case boundaries gives better results (\"get-user-by-id\").",
    "related": [
      "pregexp-replace"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gambit-ffi-pointer-types",
    "title": "Define FFI pointer types with automatic cleanup",
    "tags": [
      "ffi",
      "c-define-type",
      "pointer",
      "gambit",
      "cleanup",
      "gc",
      "foreign"
    ],
    "imports": [],
    "code": ";; In a .scm file (Gambit FFI), define pointer types with automatic GC cleanup.\n;; The pattern is: (c-define-type TypeName* (pointer CType (TagName) \"cleanup_function\"))\n;;\n;; The cleanup function is called when the Scheme object is garbage collected.\n\n;; Example from LevelDB FFI:\n(c-declare #<<END-C\n#include <leveldb/c.h>\n\n;; Cleanup function - called when GC collects the Scheme wrapper\n___SCMOBJ ffi_free_leveldb_options (void *ptr)\n{\n  leveldb_options_destroy ((leveldb_options_t*)ptr);\n  return ___FIX (___NO_ERR);\n}\nEND-C\n)\n\n;; Define the pointer type with automatic cleanup\n(c-define-type leveldb_options_t \"leveldb_options_t\")\n(c-define-type leveldb_options_t*\n  (pointer leveldb_options_t (leveldb_options_t*) \"ffi_free_leveldb_options\"))\n\n;; Now when you create a pointer:\n(define-c-lambda leveldb_options_create () leveldb_options_t*)\n\n;; The returned pointer is automatically wrapped in a Scheme object.\n;; When that object is garbage collected, ffi_free_leveldb_options is called.\n\n;; For pointers that should NOT be auto-freed (borrowed pointers):\n(c-define-type leveldb_snapshot_t \"leveldb_snapshot_t\")\n(c-define-type leveldb_snapshot_t*\n  (pointer leveldb_snapshot_t (leveldb_snapshot_t*)))  ;; no cleanup function\n\n;; For char* that needs free():\n(c-declare #<<END-C\n___SCMOBJ ffi_free (void *ptr)\n{\n  free (ptr);\n  return ___FIX (___NO_ERR);\n}\nEND-C\n)\n\n(c-define-type char*\n  (pointer char (char*) \"ffi_free\"))",
    "notes": "The three-element form (pointer CType (TagName) \"cleanup\") enables automatic memory management. The tag (e.g., leveldb_options_t*) is used for type checking. The cleanup function MUST return ___FIX(___NO_ERR). For types where Scheme doesn't own the memory (like iterator keys that point into LevelDB internal buffers), omit the cleanup function. Common pattern: define a base type for the C struct, then a pointer type with cleanup for the Scheme wrapper.",
    "related": [
      "gambit-ffi-c-lambda",
      "gambit-ffi-scheme-object"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gambit-ffi-u8vector-to-c",
    "title": "Pass u8vector to C functions efficiently",
    "tags": [
      "ffi",
      "u8vector",
      "bytes",
      "c-lambda",
      "gambit",
      "string"
    ],
    "imports": [],
    "code": ";; Pass Scheme u8vectors (byte arrays) to C functions without copying.\n;; Use scheme-object as the parameter type, then access via macros.\n\n(c-declare #<<END-C\n;; Define macros to access u8vector data and length\n#ifndef ___HAVE_FFI_U8VECTOR\n#define ___HAVE_FFI_U8VECTOR\n#define U8_DATA(obj) ___CAST (___U8*, ___BODY_AS (obj, ___tSUBTYPED))\n#define U8_LEN(obj) ___HD_BYTES (___HEADER (obj))\n#endif\n\n;; Example: wrapper that takes key and value as u8vectors\nvoid ffi_leveldb_put(leveldb_t* db, leveldb_writeoptions_t* opts,\n                     ___SCMOBJ key, ___SCMOBJ val, char** errptr)\n{\n  leveldb_put(db, opts,\n    (char*)U8_DATA(key), U8_LEN(key),\n    (char*)U8_DATA(val), U8_LEN(val),\n    errptr);\n}\nEND-C\n)\n\n;; Bind the wrapper - note scheme-object for the u8vector parameters\n(define-c-lambda leveldb_put\n  (leveldb_t* leveldb_writeoptions_t* scheme-object scheme-object leveldb_errptr)\n  void\n  \"ffi_leveldb_put\")\n\n;; In Gerbil, convert strings to bytes before calling:\n;; (def (value-bytes v)\n;;   (if (string? v) (string->bytes v) v))\n;; (leveldb_put db opts (value-bytes key) (value-bytes val) errptr)",
    "notes": "The scheme-object type passes the raw Scheme object pointer to C. U8_DATA extracts the data pointer, U8_LEN gets the byte length. This avoids copying - the C code accesses the Scheme heap directly. IMPORTANT: Don't store the pointer beyond the C call - GC could move the object. For returned data, allocate with malloc and wrap in a Scheme object with cleanup. The ___CAST, ___BODY_AS, ___tSUBTYPED, ___HD_BYTES, ___HEADER macros are from Gambit's internal API.",
    "related": [
      "gambit-ffi-pointer-types",
      "string-to-bytes"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gambit-ffi-c-define-limitation",
    "title": "c-define callback limitation - complex C-to-Scheme callbacks are fragile",
    "tags": [
      "ffi",
      "c-define",
      "callback",
      "gambit",
      "limitation",
      "workaround"
    ],
    "imports": [],
    "code": ";; LIMITATION: Gambit's c-define creates C functions that call Scheme,\n;; but using them as callbacks passed to C libraries is complex and fragile.\n;;\n;; c-define syntax:\n;; (c-define (scheme-name args...) (c-types...) return-type \"c_name\" \"\"\n;;   body...)\n;;\n;; This creates a C function \"c_name\" that invokes the Scheme body.\n;; The problem: you can't easily pass this as a function pointer to C APIs\n;; that expect callbacks (like leveldb_comparator_create).\n\n;; WHAT WORKS: Simple one-shot callbacks where you control the C wrapper\n(c-define (my_callback x)\n          (int) int\n          \"my_callback\" \"\"\n  (* x 2))\n\n;; Then in C you can call: my_callback(5) → 10\n\n;; WHAT'S FRAGILE: Callbacks stored by C libraries for later use\n;; Examples: comparators, iterators, custom allocators\n;;\n;; Issues:\n;; 1. The Scheme runtime must be initialized when callback fires\n;; 2. Callbacks during GC can cause crashes\n;; 3. Callbacks from C threads not created by Gambit fail\n;; 4. Type mismatches between extern declaration and c-define cause errors\n\n;; WORKAROUND: For complex callbacks, implement in pure C\n;; For comparators: use the default byte-ordering comparator\n;; For iterators: use Gerbil-level iteration, not C callbacks\n\n;; Example of what DOESN'T work reliably:\n;; Trying to pass Scheme function as LevelDB comparator callback\n;; The c-define callback can hang or crash when LevelDB invokes it",
    "notes": "The c-define mechanism works for callbacks that you invoke from Scheme-controlled C code. It's fragile for callbacks stored by C libraries and invoked at arbitrary times (comparators, event handlers, custom allocators). The safest approach is to implement callback-heavy functionality in pure C. For LevelDB specifically: use the default byte-ordering comparator (design keys to sort correctly), avoid writebatch_iterate (use normal iteration instead), and avoid custom filter policies (use bloom filters).",
    "related": [
      "gambit-ffi-pointer-types"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gxpkg-install-destroys-cwd",
    "title": "DANGER: gxpkg install/uninstall can destroy working directory",
    "tags": [
      "gxpkg",
      "install",
      "uninstall",
      "package",
      "danger",
      "working-directory",
      "destroy"
    ],
    "imports": [],
    "code": ";; CRITICAL WARNING: Running `gerbil pkg install` or `gerbil pkg uninstall`\n;; from within a project directory that has its own `.gerbil/` subdirectory\n;; can DESTROY the entire project directory contents.\n;;\n;; The gxpkg tool treats the CWD's `.gerbil/` as a package context.\n;; During install/uninstall, the `clean` step may remove project files.\n;;\n;; SAFE PATTERN — always cd to HOME or another directory first:\n;;\n;;   cd ~ && gerbil pkg install github.com/user/package\n;;   cd ~ && gerbil pkg uninstall github.com/user/package\n;;\n;; DANGEROUS — DO NOT do this from your project directory:\n;;\n;;   cd /path/to/my-project  # has .gerbil/ subdir\n;;   gerbil pkg install github.com/user/package  # MAY WIPE PROJECT FILES\n;;\n;; When using MCP tools (gerbil_package_manage), ensure the CWD\n;; is not a project directory with .gerbil/, or use the `cwd` parameter\n;; to explicitly set a safe working directory.\n;;\n;; RECOVERY: If this happens, use `git checkout` or restore from backup.\n;; The .git directory may also be deleted, requiring re-cloning.",
    "notes": "This was discovered when running `gerbil pkg install github.com/ober/gerbil-leveldb` from within the kunabi project directory. The entire project was wiped including .git, all source files, and build artifacts. Only .claude/ survived because it was created after the wipe. The gxpkg clean step is the culprit — it removes files from the local .gerbil/ context which cascades to removing the project structure.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "leveldb-snapshot-consistent-reads",
    "title": "LevelDB snapshot for consistent reads across multiple queries",
    "tags": [
      "leveldb",
      "snapshot",
      "read-options",
      "consistent",
      "iterator",
      "clan/db/leveldb"
    ],
    "imports": [
      ":clan/db/leveldb"
    ],
    "code": "(import :clan/db/leveldb)\n\n;; Create a snapshot for point-in-time consistent reads.\n;; Requires the ober/gerbil-leveldb fork (github.com/ober/gerbil-leveldb).\n;; The mighty-gerbils fork does NOT have snapshot support.\n\n;; Step 1: Create snapshot from open db\n(def snap (leveldb-snapshot db))\n\n;; Step 2: Create read-options with snapshot\n(def snap-opts (leveldb-read-options snapshot: snap))\n\n;; Step 3: Use snap-opts as optional 2nd/3rd arg to leveldb-get / leveldb-iterator\n(def val (leveldb-get db \"mykey\" snap-opts))      ;; 3rd arg = read-options\n(def itor (leveldb-iterator db snap-opts))          ;; 2nd arg = read-options\n\n;; Step 4: ALWAYS release the snapshot when done\n(leveldb-snapshot-release db snap)\n\n;; --- Recommended pattern: defrule macro for safe cleanup ---\n;; (defrule (with-snapshot db (snap-var opts-var) body ...)\n;;   (let* ((snap-var (leveldb-snapshot db))\n;;          (opts-var (leveldb-read-options snapshot: snap-var)))\n;;     (try (begin body ...)\n;;       (finally (leveldb-snapshot-release db snap-var)))))\n;;\n;; Usage:\n;; (with-snapshot my-db (snap snap-opts)\n;;   (let ((itor (leveldb-iterator my-db snap-opts)))\n;;     (leveldb-iterator-seek itor \"prefix:\")\n;;     ;; ... iterate consistently even if writes happen concurrently ...\n;;     (leveldb-iterator-close itor))\n;;   (leveldb-get my-db \"other-key\" snap-opts))",
    "notes": "Key API details from ober/gerbil-leveldb source: (1) leveldb-snapshot takes 1 arg (db), returns an opaque pointer. (2) leveldb-snapshot-release takes 2 args (db, snapshot). (3) leveldb-read-options accepts keyword snapshot: with the snapshot pointer. (4) leveldb-get signature is (ldb key (opts default-read-options)) — the read-options is a positional optional arg, not keyword. (5) leveldb-iterator signature is (ldb (opts default-read-options)) — same pattern. (6) Snapshots are lightweight in LevelDB but MUST be released to avoid blocking compaction. Always use try/finally or a macro wrapper.",
    "related": [
      "gxpkg-install-destroys-cwd"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "leveldb-local-pkg-manifest-setup",
    "title": "Fix 'gerbil build' when local .gerbil/pkg/ is missing manifests",
    "tags": [
      "leveldb",
      "gerbil-build",
      "manifest",
      "pkg",
      "gerbil.pkg",
      "depend"
    ],
    "imports": [],
    "code": ";; PROBLEM: `gerbil build` fails with:\n;;   No such file or directory\n;;   (call-with-input-file \".gerbil/pkg/github.com/user/package.manifest\" ...)\n;;\n;; This happens when your gerbil.pkg has depend: entries but the local\n;; .gerbil/pkg/ directory is missing the manifest files (e.g., after\n;; a clean checkout or after .gerbil/ was wiped).\n;;\n;; The manifests exist globally in ~/.gerbil/pkg/ but gerbil build\n;; looks for them locally when gerbil.pkg has depend: declarations.\n;;\n;; FIX: Copy manifest files from global to local:\n;;\n;;   # For each dependency in gerbil.pkg depend: list:\n;;   mkdir -p .gerbil/pkg/github.com/user/\n;;   cp ~/.gerbil/pkg/github.com/user/package.manifest \\\n;;      .gerbil/pkg/github.com/user/\n;;\n;; Then also copy the TAGS file:\n;;   cp ~/.gerbil/pkg/TAGS .gerbil/pkg/\n;;\n;; Example for a project depending on gerbil-leveldb and gerbil-libyaml:\n;;   mkdir -p .gerbil/pkg/github.com/ober\n;;   mkdir -p .gerbil/pkg/github.com/mighty-gerbils\n;;   cp ~/.gerbil/pkg/github.com/ober/gerbil-leveldb.manifest \\\n;;      .gerbil/pkg/github.com/ober/\n;;   cp ~/.gerbil/pkg/github.com/mighty-gerbils/gerbil-libyaml.manifest \\\n;;      .gerbil/pkg/github.com/mighty-gerbils/\n;;   cp ~/.gerbil/pkg/TAGS .gerbil/pkg/\n;;\n;; After this, run with GERBIL_LOADPATH:\n;;   GERBIL_LOADPATH=~/.gerbil/lib gerbil build",
    "notes": "This commonly happens after .gerbil/ is wiped (see gxpkg-install-destroys-cwd recipe) or on a fresh git clone. The gerbil build process reads manifests from the local .gerbil/pkg/ when gerbil.pkg declares dependencies via depend:. Even though the actual compiled modules are in ~/.gerbil/lib/, the manifest metadata must exist locally. An alternative is to run the full `gerbil pkg install` for each dependency, but that's slower and riskier (see the gxpkg destruction bug).",
    "related": [
      "gxpkg-install-destroys-cwd",
      "gerbil-build-loadpath"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "leveldb-iterator-close-not-destroy",
    "title": "LevelDB iterator cleanup: use leveldb-iterator-close, NOT leveldb-iterator-destroy",
    "tags": [
      "leveldb",
      "iterator",
      "close",
      "destroy",
      "cleanup",
      "unbound identifier"
    ],
    "imports": [
      ":clan/db/leveldb"
    ],
    "code": "(import :clan/db/leveldb)\n\n;; GOTCHA: The C LevelDB API uses leveldb_iter_destroy() to clean up iterators,\n;; but the Gerbil wrapper names it leveldb-iterator-close (NOT leveldb-iterator-destroy).\n;; Using leveldb-iterator-destroy causes: \"Reference to unbound identifier\"\n\n;; WRONG — unbound identifier:\n;; (leveldb-iterator-destroy iter)\n\n;; CORRECT:\n(def db (leveldb-open \"/tmp/testdb\"))\n(def iter (leveldb-iterator db))\n(leveldb-iterator-seek-first iter)\n(let loop ()\n  (when (leveldb-iterator-valid? iter)\n    (let ((key (leveldb-iterator-key iter))\n          (val (leveldb-iterator-value iter)))\n      (displayln \"key=\" key \" val=\" val))\n    (leveldb-iterator-next iter)\n    (loop)))\n(leveldb-iterator-close iter)  ;; <-- correct function name\n(leveldb-close db)\n\n;; Full iterator API (all exported from :clan/db/leveldb):\n;;   leveldb-iterator          — create iterator (optionally with read-options)\n;;   leveldb-iterator-close    — destroy/cleanup iterator\n;;   leveldb-iterator-valid?   — check if current position is valid\n;;   leveldb-iterator-seek-first — move to first key\n;;   leveldb-iterator-seek-last  — move to last key\n;;   leveldb-iterator-seek     — seek to specific key\n;;   leveldb-iterator-next     — advance to next entry\n;;   leveldb-iterator-prev     — move to previous entry\n;;   leveldb-iterator-key      — get current key (u8vector)\n;;   leveldb-iterator-value    — get current value (u8vector)\n;;   leveldb-iterator-error    — check for iterator errors\n;;\n;; Also: in-leveldb, in-leveldb-keys — for :std/iter protocol integration",
    "notes": "The naming mismatch comes from the C API (leveldb_iter_destroy) vs the Gerbil wrapper (leveldb-iterator-close). Iterators also have automatic finalization via Gambit's \"will\" mechanism, so they're cleaned up on GC even without explicit close — but explicit cleanup is good practice to release resources promptly. Note: key and value are returned as u8vectors; use (bytes->string key) to convert to strings.",
    "related": [
      "leveldb-snapshot"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "for-destructuring-compile-workaround",
    "title": "for loop destructuring fails with gxc compiler — use let or with instead",
    "tags": [
      "for",
      "destructuring",
      "in-hash",
      "in-indexed",
      "compile",
      "gxc",
      "unbound",
      "workaround"
    ],
    "imports": [
      ":std/iter"
    ],
    "code": ";; PROBLEM: Destructuring bindings in (for ...) work in the REPL (gxi)\n;; but cause \"Reference to unbound identifier\" errors when compiled with gxc.\n;;\n;; WRONG — works in REPL, fails with gxc:\n;; (for ((k v) (in-hash ht))        ;; v is unbound at compile time\n;;   (displayln k \": \" v))\n;;\n;; (for ((item i) (in-indexed lst))  ;; i is unbound at compile time\n;;   (displayln i \": \" item))        ;; also: in-indexed not exported from :std/iter\n\n;; CORRECT — iterate hash with single binding + let destructure:\n(import :std/iter)\n(def ht (hash (\"name\" \"Alice\") (\"age\" 30)))\n(for (kv (in-hash ht))\n  (let ((k (car kv)) (v (cdr kv)))\n    (displayln k \": \" v)))\n;; name: Alice\n;; age: 30\n\n;; CORRECT — indexed iteration with named let loop:\n(def items '(\"apple\" \"banana\" \"cherry\"))\n(let loop ((rest items) (i 0))\n  (unless (null? rest)\n    (displayln i \": \" (car rest))\n    (loop (cdr rest) (+ i 1))))\n;; 0: apple\n;; 1: banana\n;; 2: cherry\n\n;; CORRECT — use (with ...) for destructuring inside for body:\n(for (kv (in-hash ht))\n  (with ([k . v] kv)\n    (displayln k \" => \" v)))\n;; name => Alice\n;; age => 30",
    "notes": "This is a critical REPL-vs-compiler divergence. The for macro's destructuring pattern ((k v) (in-hash ...)) expands correctly in gxi (interpreter) but the gxc compiler does not bind the destructured variables, causing \"Reference to unbound identifier\" errors. Similarly, in-indexed is NOT exported from :std/iter (only 33 symbols are exported, in-indexed is not among them) — it only works in the REPL because it resolves dynamically. Always use single-variable for bindings and destructure in the body when writing code that will be compiled. The (with ...) pattern from match is the most concise alternative for destructuring pairs.",
    "related": [
      "iterate-hash",
      "for-collect",
      "for-fold"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "display-human-readable-hash",
    "title": "Display hash tables and lists in human-readable YAML-like format",
    "tags": [
      "display",
      "human",
      "readable",
      "hash",
      "nested",
      "yaml",
      "cli",
      "output",
      "pretty"
    ],
    "imports": [
      ":std/iter",
      ":std/format",
      ":std/srfi/13"
    ],
    "code": "(import :std/iter :std/format :std/srfi/13)\n\n;; Recursively display hash tables and lists in a human-readable format.\n;; Nested hashes indent, lists of hashes get numbered separators,\n;; flat lists join with commas.\n;; NOTE: Uses compiler-safe for patterns (no destructuring in for bindings).\n\n(def (display-human data (indent 0))\n  (let ((prefix (make-string indent #\\space)))\n    (cond\n     ((hash-table? data)\n      (for (kv (in-hash data))\n        (let ((k (car kv)) (v (cdr kv)))\n          (cond\n           ((or (hash-table? v)\n                (and (list? v) (not (null? v)) (hash-table? (car v))))\n            (displayln prefix k \":\")\n            (display-human v (+ indent 2)))\n           ((list? v)\n            (displayln prefix k \": \"\n                       (string-join (map (lambda (x) (format \"~a\" x)) v) \", \")))\n           (else\n            (displayln prefix k \": \" v))))))\n     ((list? data)\n      (if (and (not (null? data)) (hash-table? (car data)))\n        (let loop ((rest data) (i 1))\n          (unless (null? rest)\n            (when (> i 1) (displayln))\n            (displayln prefix \"--- [\" i \"] ---\")\n            (display-human (car rest) indent)\n            (loop (cdr rest) (+ i 1))))\n        (for (item data)\n          (displayln prefix item))))\n     (else\n      (displayln prefix data)))))\n\n;; Example:\n(display-human\n  (hash (\"key\" \"PROJ-123\")\n        (\"summary\" \"Fix bug\")\n        (\"status\" (hash (\"name\" \"In Progress\")))\n        (\"labels\" '(\"bug\" \"urgent\"))))\n;; Output:\n;; key: PROJ-123\n;; summary: Fix bug\n;; status:\n;;   name: In Progress\n;; labels: bug, urgent\n\n;; List of objects:\n(display-human\n  (list (hash (\"key\" \"PROJ-1\") (\"summary\" \"First\"))\n        (hash (\"key\" \"PROJ-2\") (\"summary\" \"Second\"))))\n;; Output:\n;; --- [1] ---\n;; key: PROJ-1\n;; summary: First\n;;\n;; --- [2] ---\n;; key: PROJ-2\n;; summary: Second",
    "notes": "This is a compiler-safe pattern (uses (for (kv (in-hash ...))) with manual car/cdr, not destructuring). Designed for CLI tools that need human-readable default output with a --json flag for machine-readable. Pair with a display-result dispatcher: (def (display-result data) (if (current-json-output) (display-json data) (display-human data))). The indent parameter enables recursive nesting for sub-hashes.",
    "related": [
      "for-destructuring-compile-workaround",
      "iterate-hash",
      "print-table"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "let-star-nested-hash-invalid-match-target",
    "title": "let* with deeply nested hash literals causes \"Bad syntax; invalid match target\"",
    "tags": [
      "let*",
      "hash",
      "bad syntax",
      "invalid match target",
      "nested",
      "destructure",
      "test"
    ],
    "imports": [],
    "code": ";; PROBLEM: In Gerbil, let* supports pattern-matching destructure on\n;; its bindings. When a deeply nested (hash ...) literal appears as\n;; the init-expr of the FIRST binding in let*, the compiler may\n;; misparse it as a destructuring pattern, causing:\n;;   \"Bad syntax; invalid match target\"\n;;\n;; WRONG — let* with deeply nested hash as first binding init-expr:\n;; (let* ((spec (hash (\"components\"\n;;                     (hash (\"schemas\"\n;;                            (hash (\"Container\"\n;;                                   (hash (\"type\" \"object\")\n;;                                         (\"properties\"\n;;                                          (hash (\"items\" (hash (\"type\" \"array\")\n;;                                                               (\"items\" (hash (\"$ref\" \"...\")))))\n;;                                                (\"owner\" (hash (\"$ref\" \"...\"))))))))))))\n;;        (resolved (process spec)))\n;;   (use resolved))\n;; => Syntax Error: Bad syntax; invalid match target\n\n;; FIX 1: Use plain (let ...) for the deeply nested hash binding,\n;; then let* for the rest:\n(let ((spec (hash (\"components\"\n                   (hash (\"schemas\"\n                          (hash (\"Container\"\n                                 (hash (\"type\" \"object\")\n                                       (\"properties\"\n                                        (hash (\"items\" (hash (\"type\" \"array\")\n                                                             (\"items\" (hash (\"$ref\" \"...\")))))\n                                              (\"owner\" (hash (\"type\" \"object\")))))))))))))\n  (let* ((resolved (process spec))\n         (result (transform resolved)))\n    (use result)))\n\n;; FIX 2: Build the hash in a separate def before the let*:\n(def test-spec\n  (hash (\"components\"\n         (hash (\"schemas\"\n                (hash (\"Container\"\n                       (hash (\"type\" \"object\")\n                             (\"properties\"\n                              (hash (\"items\" (hash (\"type\" \"array\"))))))))))))\n(let* ((resolved (process test-spec))\n       (result (transform resolved)))\n  (use result))",
    "notes": "This commonly bites in test code where you construct complex hash-table fixtures inline. The issue is that Gerbil's let* uses syntax-case matching on binding forms, and deeply nested hash literals with string keys can confuse the pattern matcher. Shallow hashes in let* work fine — it's specifically when there are 3+ levels of nesting that the problem appears. The workaround is to use plain (let ...) for the problematic binding and nest a let* inside for the sequential bindings, or to extract the hash construction into a separate (def ...).",
    "related": [
      "hash-table-operations",
      "dotted-pair-syntax-in-brackets"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "resolve-all-refs-preserve-ref-name",
    "title": "Preserve $ref names after JSON $ref resolution",
    "tags": [
      "json",
      "ref",
      "resolve",
      "openapi",
      "swagger",
      "schema",
      "reference"
    ],
    "imports": [],
    "code": ";; PROBLEM: When resolving JSON $ref pointers (e.g. for OpenAPI specs),\n;; you replace {\"$ref\": \"#/components/schemas/Pet\"} with the actual Pet\n;; schema object. But downstream code needs the original ref name to know\n;; WHICH schema was referenced (e.g. for display formatters, type dispatch).\n;;\n;; After resolution, the $ref string is gone — replaced by the target hash.\n;;\n;; SOLUTION: Store the original $ref path as \"$resolved-ref\" on the resolved hash.\n\n(def (resolve-all-refs node root (seen '()))\n  (cond\n   ((hash-table? node)\n    (let ((ref (hash-get node \"$ref\")))\n      (if (and ref (string? ref))\n        ;; $ref node — resolve it\n        (if (member ref seen)\n          (hash (\"$circular-ref\" ref))  ;; cycle detection\n          (let* ((resolved (resolve-json-pointer root ref))\n                 (result (resolve-all-refs resolved root (cons ref seen))))\n            ;; KEY: preserve original $ref path on the resolved hash\n            (when (hash-table? result)\n              (hash-put! result \"$resolved-ref\" ref))\n            result))\n        ;; Regular object — resolve all values recursively\n        (let ((result (make-hash-table)))\n          (hash-for-each\n           (lambda (k v)\n             (hash-put! result k (resolve-all-refs v root seen)))\n           node)\n          result))))\n   ((list? node)\n    (map (lambda (item) (resolve-all-refs item root seen)) node))\n   (else node)))\n\n;; Then downstream code checks both:\n(def (get-schema-ref schema)\n  (or (hash-get schema \"$ref\")           ;; unresolved\n      (hash-get schema \"$resolved-ref\"))) ;; resolved — still has the name",
    "notes": "After resolve-all-refs runs, (hash-get resolved-schema \"$resolved-ref\") returns e.g. \"#/components/schemas/Pet\". You can extract the name with (extract-ref-name ref) which takes the last path segment. This is critical for code generators that need to know schema names for type dispatch, formatter selection, or struct name generation.",
    "related": [
      "hash-table-operations"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "quasiquote-splice-empty-list-when-body",
    "title": "Quasiquote splicing empty list into when/begin produces invalid syntax",
    "tags": [
      "quasiquote",
      "splice",
      "when",
      "empty",
      "codegen",
      "generate",
      "syntax"
    ],
    "imports": [],
    "code": ";; PROBLEM: When generating Gerbil code with quasiquote + unquote-splicing,\n;; if the spliced list is empty, forms like (when ...) and (begin ...) end up\n;; with no body — which is a syntax error.\n;;\n;; This commonly happens in code generators that build per-schema formatters\n;; where some schemas have no displayable properties.\n\n;; WRONG — empty field-entries produces (when (hash-table? data)) with no body:\n;; (def field-entries '())  ;; e.g. schema with no properties\n;; `(def (display-foo data)\n;;    (when (hash-table? data)\n;;      ,@(map (lambda (e) `(display-field ,(car e) ,(cadr e)))\n;;             field-entries)))\n;; => (def (display-foo data) (when (hash-table? data)))\n;; => Syntax Error: Bad syntax; invalid match target\n\n;; CORRECT — guard against empty splice:\n(def (generate-object-formatter name field-entries)\n  (if (null? field-entries)\n    ;; No fields: generate a simple fallback\n    `(def (,(string->symbol (string-append \"display-\" name)) data)\n       (display-human data))\n    ;; Has fields: generate when + field displays\n    `(def (,(string->symbol (string-append \"display-\" name)) data)\n       (when (hash-table? data)\n         ,@(map (lambda (e) `(display-field ,(car e) ,(cadr e)))\n                field-entries)))))\n\n;; GENERAL RULE: Before splicing into forms that require a body\n;; (when, unless, begin, lambda, let, etc.), always check if the\n;; list is empty and provide an alternative form.",
    "notes": "This is a code generation gotcha. Forms like (when test body ...), (unless test body ...), and (begin body ...) require at least one body expression. When using ,@(map ...) to generate the body, an empty input list produces zero body forms, which is a syntax error. Always guard with (if (null? items) fallback-form normal-form) before constructing the quasiquote. The error message \"Bad syntax; invalid match target\" is misleading — the real issue is empty body.",
    "related": [
      "let-star-nested-hash-invalid-match-target",
      "pretty-print-code-generation"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "write-xml-generate-sxml",
    "title": "Generate XML/SVG output from SXML using write-xml",
    "tags": [
      "write-xml",
      "sxml",
      "svg",
      "xml",
      "generate",
      "output",
      "serialize"
    ],
    "imports": [
      ":std/xml"
    ],
    "code": "(import :std/xml)\n\n;; write-xml serializes an SXML tree to XML text.\n;; SXML format: (tag (@ (attr \"val\") ...) children...)\n;; All attribute values MUST be strings.\n\n;; Write to a port (default: current-output-port)\n(write-xml '(svg (@ (xmlns \"http://www.w3.org/2000/svg\")\n                    (width \"200\") (height \"200\"))\n                 (rect (@ (x \"10\") (y \"10\")\n                          (width \"180\") (height \"180\")\n                          (fill \"steelblue\")))\n                 (circle (@ (cx \"100\") (cy \"100\") (r \"50\")\n                            (fill \"white\")))\n                 (text (@ (x \"100\") (y \"108\")\n                          (text-anchor \"middle\")\n                          (font-size \"16\") (fill \"steelblue\"))\n                       \"Hello\"))\n           (current-output-port))\n;; Output: <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"200\">\n;;           <rect x=\"10\" y=\"10\" width=\"180\" height=\"180\" fill=\"steelblue\"></rect>\n;;           <circle cx=\"100\" cy=\"100\" r=\"50\" fill=\"white\"></circle>\n;;           <text x=\"100\" y=\"108\" text-anchor=\"middle\" ...>Hello</text>\n;;         </svg>\n\n;; Capture XML as a string\n(def xml-string\n  (call-with-output-string\n    (lambda (p)\n      (write-xml '(root (@ (id \"1\")) (item \"hello\") (item \"world\")) p))))\n;; => \"<root id=\\\"1\\\"><item>hello</item><item>world</item></root>\"\n\n;; Write to a file\n(call-with-output-file \"/tmp/output.svg\"\n  (lambda (p)\n    (write-xml '(svg (@ (xmlns \"http://www.w3.org/2000/svg\")\n                        (width \"100\") (height \"100\"))\n                     (rect (@ (width \"100\") (height \"100\") (fill \"red\"))))\n               p)))\n\n;; GOTCHAS:\n;; 1. write-xml does NOT add <?xml?> declaration — add manually if needed\n;; 2. Self-closing tags like <rect/> are written as <rect></rect> (valid XML)\n;; 3. All attribute values must be strings — use number->string for numbers\n;; 4. For SVG: the xmlns attribute is REQUIRED for browsers to render it\n;; 5. print-sxml->xml is an alternative that also accepts a port argument",
    "notes": "write-xml takes (sxml [port]). Without a port arg, it writes to current-output-port. The output is NOT pretty-printed (no indentation). Self-closing tags become open+close pairs which is valid XML/SVG. The xmlns attribute on the root SVG element is critical for browser rendering. print-sxml->xml is equivalent. For reading XML back, use read-xml which returns SXML wrapped in (*TOP* ...).",
    "related": [
      "parse-xml-to-sxml",
      "sxml-skip-pi-nodes"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "build-ffi-module-with-pkg-config",
    "title": "Build FFI module with pkg-config cc-options and ld-options",
    "tags": [
      "build",
      "ffi",
      "pkg-config",
      "cc-options",
      "ld-options",
      "defbuild-script",
      "gxc",
      "compile"
    ],
    "imports": [
      ":std/build-script",
      ":std/make"
    ],
    "code": "#!/usr/bin/env gxi\n;; build.ss — building an FFI module that links to a C library\n;; Uses :std/make helpers for pkg-config integration.\n(import :std/build-script\n        :std/make)\n\n;; defbuild-script with gxc: directive for FFI modules.\n;; gxc: passes -cc-options and -ld-options to the Gambit C compiler/linker.\n;; Plain strings are regular Gerbil modules (no special compile flags).\n(defbuild-script\n  `(;; FFI module — needs C compiler and linker flags\n    (gxc: \"libmylib\"\n          \"-cc-options\" ,(cppflags \"mylib\" \"\")\n          \"-ld-options\" ,(ldflags \"mylib\" \"-lmylib\"))\n    ;; High-level Gerbil wrapper — no special flags needed\n    \"mylib\"))\n\n;; --- How the :std/make helpers work ---\n;;\n;; (cppflags \"pkg-name\" \"fallback\")\n;;   Runs: pkg-config --cflags pkg-name\n;;   Falls back to \"fallback\" string if pkg-config fails\n;;   Returns: \"-I/path/to/include ...\" string\n;;\n;; (ldflags \"pkg-name\" \"fallback\")\n;;   Runs: pkg-config --libs pkg-name\n;;   Falls back to \"fallback\" string if pkg-config fails\n;;   Returns: \"-L/path/to/lib -lname\" string\n;;\n;; (append-options str1 str2 ...)\n;;   Joins non-empty strings with spaces\n;;   Useful for combining multiple flag sources\n\n;; --- Example: Cairo library with SVG+PNG support ---\n;; (defbuild-script\n;;   `((gxc: \"libcairo\"\n;;           \"-cc-options\" ,(cppflags \"cairo\" \"\")\n;;           \"-ld-options\" ,(append-options\n;;                            (ldflags \"cairo\" \"-lcairo\")\n;;                            (ldflags \"cairo-png\" \"-lpng16\")))\n;;     \"cairo\"))\n\n;; --- Example: OpenSSL with warning suppression ---\n;; (gxc: \"crypto/libcrypto\"\n;;       \"-cc-options\" ,(append-options\n;;                        (cppflags \"libcrypto\" \"\")\n;;                        \"-Wno-deprecated-declarations\")\n;;       \"-ld-options\" ,(ldflags \"libcrypto\" \"-lcrypto\")\n;;       ,@(include-gambit-sharp))",
    "notes": "The gxc: directive in defbuild-script tells the build system this module needs special compiler/linker flags (unlike plain string module names). The :std/make module provides cppflags, ldflags, append-options, pkg-config-cflags, pkg-config-libs helpers. Build order in the list matters — FFI modules must come before modules that import them. The (include-gambit-sharp) call adds Gambit's internal headers for advanced FFI (##vector-ref etc). Fallback strings in cppflags/ldflags are used when pkg-config is not available (e.g., manual installs). Use backtick (quasiquote) for the build spec since the ,() calls need evaluation.",
    "related": [
      "gambit-ffi-pointer-types",
      "static-exe-with-deps",
      "gerbil-build-loadpath"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ffi-c-struct-field-accessors",
    "title": "Access C struct fields via wrapper functions in FFI",
    "tags": [
      "ffi",
      "struct",
      "accessor",
      "wrapper",
      "c-lambda",
      "text-extents",
      "cairo"
    ],
    "imports": [
      ":std/foreign"
    ],
    "code": "(import :std/foreign)\n\n;; PROBLEM: C functions that fill a struct by pointer (like cairo_text_extents)\n;; are awkward to bind directly — Gambit FFI doesn't easily expose struct fields.\n;;\n;; SOLUTION: Write thin C wrapper functions that call the C API and return\n;; individual fields. Each wrapper calls the original function and extracts\n;; one field from the result struct.\n\n(begin-ffi (text_width text_height)\n\n  (declare (not safe))\n\n  (c-declare #<<END-C\n#include <cairo/cairo.h>\n\n/* Wrapper: call cairo_text_extents, return just the width field */\nstatic double ffi_text_width(cairo_t *cr, const char *text)\n{\n  cairo_text_extents_t extents;\n  cairo_text_extents(cr, text, &extents);\n  return extents.width;\n}\n\n/* Wrapper: call cairo_text_extents, return just the height field */\nstatic double ffi_text_height(cairo_t *cr, const char *text)\n{\n  cairo_text_extents_t extents;\n  cairo_text_extents(cr, text, &extents);\n  return extents.height;\n}\nEND-C\n  )\n\n  ;; Bind the wrapper functions — note the C name string at the end\n  (define-c-lambda text_width (cairo_t* char-string) double \"ffi_text_width\")\n  (define-c-lambda text_height (cairo_t* char-string) double \"ffi_text_height\")\n)\n\n;; PATTERN SUMMARY:\n;; 1. C function fills struct by pointer: void some_fn(ctx*, result_struct*)\n;; 2. Write C wrappers that call fn and return one field each\n;; 3. Bind wrappers with define-c-lambda pointing to the C wrapper name\n;;\n;; This is cleaner than trying to define the struct in Gambit FFI\n;; and works for any C struct you need to read individual fields from.\n;; The trade-off is one C call per field — acceptable for non-hot-path code.",
    "notes": "This pattern is used in Gerbil's own libcrypto.ss for OpenSSL struct access. The alternative — defining the struct layout with c-define-type and field accessors — is more complex and fragile (struct layout must match exactly). For structs with many fields you need, consider a single C wrapper that returns values via multiple output parameters or packs them into a Scheme vector. The overhead of calling the C function multiple times (once per field) is negligible for non-hot-path code like text measurement.",
    "related": [
      "gambit-ffi-pointer-types",
      "gambit-ffi-scheme-object"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "sxml-optional-attrs-from-keywords",
    "title": "Build SXML attribute list from keyword args, filtering #f values",
    "tags": [
      "sxml",
      "attributes",
      "keyword",
      "optional",
      "filter",
      "xml",
      "svg"
    ],
    "imports": [
      ":std/srfi/13"
    ],
    "code": ";; Pattern for building SXML (@ ...) attribute lists from keyword arguments,\\n;; filtering out #f (unset) values. Useful for SVG/XML element constructors.\\n\\n(def (n->s v)\\n  (if (string? v) v (number->string v)))\\n\\n;; Convert keyword args to SXML attribute pairs, skipping #f values.\\n;; keyword->string strips the trailing colon automatically.\\n(def (opt-attrs . kvs)\\n  (let loop ((kvs kvs) (acc '()))\\n    (if (null? kvs)\\n      (reverse acc)\\n      (let ((k (car kvs))\\n            (v (cadr kvs)))\\n        (if v\\n          (loop (cddr kvs)\\n                (cons (list (string->symbol (keyword->string k)) (n->s v)) acc))\\n          (loop (cddr kvs) acc))))))\\n\\n;; Usage in an SVG element constructor:\\n(def (svg-rect x y width height\\n               fill: (fill #f)\\n               stroke: (stroke #f)\\n               rx: (rx #f))\\n  `(rect (@ (x ,(n->s x)) (y ,(n->s y))\\n            (width ,(n->s width)) (height ,(n->s height))\\n            ,@(opt-attrs fill: fill stroke: stroke rx: rx))))\\n\\n;; Examples:\\n(svg-rect 10 20 100 50)\\n;; => (rect (@ (x \\\"10\\\") (y \\\"20\\\") (width \\\"100\\\") (height \\\"50\\\")))\\n\\n(svg-rect 10 20 100 50 fill: \\\"red\\\" stroke: \\\"black\\\")\\n;; => (rect (@ (x \\\"10\\\") (y \\\"20\\\") (width \\\"100\\\") (height \\\"50\\\")\\n;;            (fill \\\"red\\\") (stroke \\\"black\\\")))",
    "notes": "keyword->string automatically strips the trailing colon: (keyword->string 'fill:) => \"fill\". All attribute values must be strings in SXML, hence n->s conversion. The ,@(opt-attrs ...) splice inserts only non-#f attributes. This pattern is the foundation of the gerbil-svg library's element constructors.",
    "related": [
      "generate-xml-svg-output",
      "defstruct-positional-args"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "defstruct-internal-constructor-pattern",
    "title": "Use internal helper to avoid defstruct make-NAME rebind conflict",
    "tags": [
      "defstruct",
      "constructor",
      "rebind",
      "conflict",
      "make",
      "pattern"
    ],
    "imports": [],
    "code": ";; PROBLEM: defstruct generates make-NAME. If you also define (def (make-NAME ...)),\\n;; you get \\\"Bad binding; rebind conflict\\\".\\n;;\\n;; This happens when you want a zero-arg convenience constructor but\\n;; defstruct's auto-generated one requires all fields.\\n\\n;; WRONG — rebind conflict:\\n;; (defstruct path-builder (commands) transparent: #t)\\n;; (def (make-path-builder (commands []))   ;; ERROR: rebinds make-path-builder\\n;;   (##structure path-builder::t commands))\\n\\n;; CORRECT — use an internal helper name:\\n(defstruct path-builder (commands) transparent: #t)\\n\\n(def (new-pb commands)\\n  (##structure path-builder::t commands))\\n\\n;; Use new-pb inside module functions:\\n(def (path-move-to pb x y)\\n  (new-pb (cons (string-append \\\"M\\\" (number->string x) \\\" \\\" (number->string y))\\n                (path-builder-commands pb))))\\n\\n;; Export make-path-builder (from defstruct) for external callers:\\n;; (make-path-builder [])  ;; create empty builder\\n;; (make-path-builder '(\\\"M0 0\\\"))  ;; create with initial commands",
    "notes": "defstruct creates make-NAME, NAME?, and NAME-field accessors. You CANNOT redefine make-NAME with def — it causes a compile-time rebind conflict. The workaround is to use an internal helper (e.g., new-pb) for constructing instances inside the module, and let callers use the defstruct-generated make-NAME directly. Use ##structure to construct directly when you know the type descriptor.",
    "related": [
      "defstruct-positional-args",
      "defstruct-accessor-collision"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "write-xml-arity-one-parameterize",
    "title": "write-xml is arity 1 — use parameterize for port redirection",
    "tags": [
      "write-xml",
      "xml",
      "port",
      "parameterize",
      "arity",
      "output"
    ],
    "imports": [
      ":std/xml"
    ],
    "code": "(import :std/xml)\\n\\n;; write-xml reports as arity:1 — it takes ONLY the SXML tree.\\n;; It writes to current-output-port.\\n;;\\n;; To redirect output to a specific port, use parameterize:\\n\\n;; Capture as string:\\n(def (sxml->string sxml)\\n  (call-with-output-string\\n    (lambda (p)\\n      (parameterize ((current-output-port p))\\n        (write-xml sxml)))))\\n\\n(sxml->string '(root (@ (id \\\"1\\\")) (item \\\"hello\\\")))\\n;; => \\\"<root id=\\\\\\\"1\\\\\\\"><item>hello</item></root>\\\"\\n\\n;; Write to file:\\n(def (sxml->file sxml filename)\\n  (call-with-output-file filename\\n    (lambda (p)\\n      (parameterize ((current-output-port p))\\n        (write-xml sxml)))))\\n\\n;; NOTE: Some cookbook entries show (write-xml sxml port) with 2 args.\\n;; The function signature tool reports arity:1. In practice, the\\n;; parameterize approach always works reliably.",
    "notes": "Despite some documentation suggesting write-xml accepts an optional port argument, gerbil_function_signature reports arity:1. The parameterize approach is the safe, verified way to redirect write-xml output. print-sxml->xml is an alternative that does accept a port argument, but its output is pretty-printed with newlines which may not be desired.",
    "related": [
      "generate-xml-svg-output"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "make-temporary-file-name",
    "title": "Create a temporary file name with prefix",
    "tags": [
      "temporary",
      "file",
      "temp",
      "tmp",
      "tmpfile",
      "temporaries"
    ],
    "imports": [
      ":std/os/temporaries"
    ],
    "code": "(import :std/os/temporaries)\n\n;; make-temporary-file-name takes exactly 1 argument: a prefix string\n;; Returns a unique path in /tmp like: /tmp/myprefix.eghagFpE.1770327980.9162219\n(def tmpfile (make-temporary-file-name \"myprefix\"))\n;; => \"/tmp/myprefix.eghagFpE.1770327980.9162219\"\n\n;; Common pattern: append an extension\n(def png-file (string-append (make-temporary-file-name \"cairo\") \".png\"))\n;; => \"/tmp/cairo.xxxxx.yyyy.zzzz.png\"",
    "notes": "Arity is 1 — requires a prefix string argument. Calling with no arguments causes \"Wrong number of arguments\" error. The prefix is used as the first component of the generated filename.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ffi-type-predicate",
    "title": "Define FFI type predicate for foreign pointer types",
    "tags": [
      "ffi",
      "foreign",
      "type",
      "predicate",
      "pointer",
      "check",
      "define-c-type-predicate"
    ],
    "imports": [
      ":std/foreign"
    ],
    "code": ";; Inside a (begin-ffi (...) ...) block, define type predicates\n;; for foreign pointer types. This lets you check at runtime whether\n;; a Scheme object wraps a specific C pointer type.\n\n;; First, define the macro (must be inside begin-ffi):\n(define-macro (define-c-type-predicate pred tag)\n  `(define (,pred x)\n     (and (##foreign? x)\n          (##memq ',tag (foreign-tags x)))))\n\n;; Then use it with the tag from your c-define-type pointer declaration:\n;; Given:  (c-define-type cairo_t* (pointer cairo_t (cairo_t*) \\\"ffi_cairo_destroy\\\"))\n;;                                                   ^^^^^^^^^ this is the tag\n\n(define-c-type-predicate cairo_t? cairo_t*)\n(define-c-type-predicate cairo_surface_t? cairo_surface_t*)\n\n;; Usage in Gerbil code:\n;; (cairo_t? my-context)       ;; => #t if it's a cairo context pointer\n;; (cairo_surface_t? surface)  ;; => #t if it's a cairo surface pointer\n;; (cairo_t? 42)               ;; => #f (not a foreign object)",
    "notes": "The tag in define-c-type-predicate must match the tag in the c-define-type pointer declaration (the symbol in the tag list). ##foreign? and foreign-tags are Gambit internals — this must be inside a (declare (not safe)) block. This pattern is used in Gerbil's own libcrypto.ss. The macro must be defined inside begin-ffi, not at the module level.",
    "related": [
      "gambit-ffi-pointer-types"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gxi-e-import-suppresses-output",
    "title": "gxi -e with import suppresses output — use script files instead",
    "tags": [
      "gxi",
      "import",
      "output",
      "suppress",
      "script",
      "eval",
      "displayln"
    ],
    "imports": [],
    "code": ";; PROBLEM: When using `gxi -e` with an import statement followed by\n;; other expressions, output from displayln/display is suppressed:\n;;\n;;   $ gxi -e '(import :my-module) (displayln \"hello\")'\n;;   (no output!)\n;;\n;; But without the import, output works fine:\n;;   $ gxi -e '(displayln \"hello\")'\n;;   hello\n;;\n;; SOLUTION: Write a script file and run it with gxi instead.\n\n;; smoke-test.ss:\n;; (import :my-project/my-module)\n;; (def (main . args)\n;;   (do-something)\n;;   (displayln \"Done!\"))\n\n;; Run with:\n;;   GERBIL_LOADPATH=.gerbil/lib gxi smoke-test.ss\n;;\n;; This reliably produces output and handles imports correctly.",
    "notes": "This appears to be a Gambit/Gerbil quirk where `gxi -e` with an import expression suppresses subsequent expression output. The workaround is trivial — use a script file. For quick one-liners that don't need imports, `gxi -e` works fine.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "interface-method-dispatch",
    "title": "Define and use Gerbil interfaces for polymorphic method dispatch",
    "tags": [
      "interface",
      "defmethod",
      "polymorphism",
      "method",
      "dispatch",
      "canvas",
      "abstraction"
    ],
    "imports": [],
    "code": ";; Define an interface with method signatures\n(interface Drawable\n  (draw! canvas)\n  (bounds))\n\n;; Implement on a class using defmethod\n(defclass circle-shape (cx cy radius color)\n  constructor: :init!)\n\n(defmethod {:init! circle-shape}\n  (lambda (self cx cy radius color)\n    (set! self.cx cx)\n    (set! self.cy cy)\n    (set! self.radius radius)\n    (set! self.color color)))\n\n;; NOTE: self.field dot syntax ONLY works inside defmethod lambda bodies\n;; It does NOT work in standalone def functions\n(defmethod {draw! circle-shape}\n  (lambda (self canvas)\n    (displayln \"Drawing circle at \" self.cx \",\" self.cy)))\n\n(defmethod {bounds circle-shape}\n  (lambda (self)\n    (list (- self.cx self.radius) (- self.cy self.radius)\n          (* 2 self.radius) (* 2 self.radius))))\n\n;; The interface exports: Drawable, is-Drawable?, make-Drawable, try-Drawable\n;; Method dispatch uses {obj.method args} syntax\n(let ((c (make-circle-shape 100 200 50 \"red\")))\n  {c.draw! \"my-canvas\"}   ;; dispatches to circle-shape's draw!\n  {c.bounds})              ;; => (50 150 100 100)\n\n;; IMPORTANT: interface does NOT generate standalone canvas-width etc.\n;; It generates Drawable-draw!, &Drawable-draw! (checked/unchecked)\n;; For {obj.method} dispatch, just define defmethod on each class",
    "notes": "Gerbil interfaces define a protocol but method dispatch via {obj.method args} works through defmethod on the class, not through the interface directly. The interface adds type predicates (is-Drawable?, Drawable?) and cast constructors (make-Drawable). The self.field dot syntax only works in defmethod lambda bodies, NOT in standalone def functions. Export only the interface name and predicates, not method names.",
    "related": [
      "defstruct-positional-args",
      "typed-struct-field-access"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "defclass-constructor-init-factory",
    "title": "defclass with constructor: :init! — auto-generated make-NAME forwards args to :init!",
    "tags": [
      "defclass",
      "constructor",
      "init",
      "make",
      "factory",
      "rebind"
    ],
    "imports": [],
    "code": ";; defclass with constructor: :init! generates make-NAME that forwards args to :init!\n(defclass my-widget (name value items)\n  constructor: :init!)\n\n(defmethod {:init! my-widget}\n  (lambda (self name (value 0))\n    (set! self.name name)\n    (set! self.value value)\n    (set! self.items [])))\n\n;; make-my-widget is auto-generated — DO NOT redefine with def!\n;; (def (make-my-widget name) ...)  ;; BAD: rebind conflict!\n\n;; The auto-generated make-my-widget forwards all args to :init!\n(make-my-widget \"foo\")        ;; calls :init! with self, \"foo\"\n(make-my-widget \"foo\" 42)     ;; calls :init! with self, \"foo\", 42\n\n;; If you need a convenience factory with a DIFFERENT name:\n(def (create-widget name)\n  (make-my-widget name 0))",
    "notes": "When using `constructor: :init!`, defclass generates a `make-NAME` function that allocates the object and calls its `:init!` method with all provided arguments. Do NOT define a function with the same `make-NAME` name — this causes a compile-time rebind conflict. If you need a convenience constructor, use a different name.",
    "related": [
      "use-internal-helper-rebind-conflict",
      "defstruct-positional-args"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "indexed-iteration-without-in-indexed",
    "title": "Iterate with index using named let (in-indexed does not exist)",
    "tags": [
      "iterate",
      "index",
      "loop",
      "in-indexed",
      "for",
      "counter",
      "enumerate"
    ],
    "imports": [],
    "code": ";; in-indexed does NOT exist in :std/iter\n;; Use a named let loop for indexed iteration:\n\n(def (process-items items)\n  (let loop ((rest items) (i 0))\n    (when (pair? rest)\n      (let ((item (car rest)))\n        (displayln i \": \" item)\n        (loop (cdr rest) (+ i 1))))))\n\n;; Example: draw indexed series in a chart legend\n(def (draw-legend series-list)\n  (let loop ((rest series-list) (i 0))\n    (when (pair? rest)\n      (let ((s (car rest))\n            (y (* i 18)))\n        (displayln \"Series \" i \" at y=\" y \": \" s)\n        (loop (cdr rest) (+ i 1))))))",
    "notes": "The function `in-indexed` referenced in some Gerbil documentation does NOT exist in `:std/iter`. For indexed iteration, use a named let loop with a counter variable. This is the standard Scheme pattern and always works.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gerbil-pkg-depend-local-deps",
    "title": "Use GERBIL_LOADPATH for local project dependencies (not gerbil.pkg depend:)",
    "tags": [
      "gerbil.pkg",
      "depend",
      "GERBIL_LOADPATH",
      "local",
      "dependency",
      "contract",
      "string-split"
    ],
    "imports": [],
    "code": ";; PROBLEM: gerbil.pkg depend: expects installable package strings\n;; (like GitHub URLs), NOT bare symbols or local project names.\n;;\n;; WRONG — causes string-split contract violation at build time:\n;; ;; gerbil.pkg\n;; (package: my-charts)\n;; (depend: (gerbil-svg gerbil-cairo))\n;;\n;; Error: \"contract violation; expected: string given: gerbil-svg\"\n;; This happens because depend: entries are processed with string-split\n;; to extract package URLs for resolution.\n;;\n;; WRONG — local paths don't work either:\n;; (depend: (\"../gerbil-svg\" \"../gerbil-cairo\"))\n;;\n;; depend: is for installable packages like:\n;; (depend: (\"github.com/user/gerbil-svg\" \"github.com/user/gerbil-cairo\"))\n\n;; CORRECT — for LOCAL (non-published) dependencies, use GERBIL_LOADPATH:\n;;\n;; gerbil.pkg — keep it simple, no depend:\n;; (package: my-charts)\n;;\n;; Makefile — set GERBIL_LOADPATH to point at local dependency builds:\n;; GERBIL_SVG_LIB ?= $(HOME)/mine/gerbil-svg/.gerbil/lib\n;; GERBIL_CAIRO_LIB ?= $(HOME)/mine/gerbil-cairo/.gerbil/lib\n;; export GERBIL_LOADPATH := $(GERBIL_SVG_LIB):$(GERBIL_CAIRO_LIB)\n;;\n;; build:\n;; \tgerbil build\n;;\n;; test:\n;; \tgerbil test ./...\n\n;; SUMMARY:\n;; - depend: is for published packages installable via `gerbil pkg install`\n;; - GERBIL_LOADPATH is for local project dependencies built from source\n;; - Each entry in GERBIL_LOADPATH points to the dep's .gerbil/lib/ dir\n;; - Build deps first: cd ~/mine/gerbil-svg && gerbil build",
    "notes": "The contract violation error \"expected: string given: gerbil-svg\" is misleading — it comes from internal string processing of depend: entries, not from a type check on user code. The real issue is that depend: only accepts package URL strings that can be resolved by the package manager. For local development dependencies, GERBIL_LOADPATH is the correct mechanism. Set it in a Makefile to keep the workflow simple.",
    "related": [
      "gerbil-build-loadpath",
      "gxpkg-install-destroys-cwd"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ffi-callback-dispatch-table",
    "title": "FFI callback dispatch table — map multiple Scheme closures through a single C trampoline",
    "tags": [
      "ffi",
      "callback",
      "c-define",
      "trampoline",
      "dispatch",
      "user-data",
      "void-pointer",
      "closure"
    ],
    "imports": [
      ":std/foreign"
    ],
    "code": ";; PATTERN: When a C library accepts callbacks with a void* user_data parameter,\n;; you can route multiple distinct Scheme closures through a SINGLE c-define\n;; trampoline by encoding a callback ID in the void* arg.\n;;\n;; This solves the problem that c-define creates one fixed C function,\n;; but you need many different callbacks (one per button, event, etc.).\n\n;; Inside begin-ffi:\n\n;; 1. Global dispatch table (Scheme side)\n(define *handlers* (make-hash-table))\n(define *next-id* 0)\n\n(define (register-handler! proc)\n  (let ((id *next-id*))\n    (set! *next-id* (+ id 1))\n    (hash-put! *handlers* id proc)\n    id))\n\n(define (unregister-handler! id)\n  (hash-remove! *handlers* id))\n\n;; 2. c-define trampoline — single C function that dispatches to Scheme\n(c-define (ffi_dispatch_callback callback-id arg1 arg2)\n          (long char-string char-string) void\n          \"ffi_dispatch_callback\" \"\"\n  (let ((handler (hash-ref *handlers* callback-id #f)))\n    (when handler (handler arg1 arg2))))\n\n;; 3. C wrapper that passes the callback ID as void* user_data\n(c-declare #<<END-C\n/* Example: C library has api_register(name, callback, user_data) */\n/* We wrap it to pass the integer ID as the void* arg */\n\nstatic void trampoline(const char *a1, const char *a2, void *arg) {\n    long callback_id = (long)arg;\n    ffi_dispatch_callback(callback_id, a1, a2);\n}\n\nstatic int ffi_register(void *handle, const char *name, long callback_id) {\n    return api_register(handle, name, trampoline, (void*)callback_id);\n}\nEND-C\n)\n\n;; 4. Bind the wrapper (NOT the original C function)\n(define-c-lambda raw_register ((pointer void) char-string long) int \"ffi_register\")\n\n;; === Usage from Gerbil ===\n;; (def id (register-handler! (lambda (a1 a2) (displayln \"got: \" a1 \" \" a2))))\n;; (raw_register handle \"my-event\" id)\n;; ;; When C library fires the callback, it calls trampoline → ffi_dispatch_callback\n;; ;; → looks up handler by ID → calls the Scheme closure\n;;\n;; (unregister-handler! id)  ;; cleanup when done",
    "notes": "This pattern works when: (1) the C API passes a void* user_data through to the callback, (2) callbacks fire on a thread where the Gambit runtime is active (e.g., the same thread that called the C function, or the event loop thread). It does NOT work for callbacks invoked from arbitrary C threads not created by Gambit. Closures stored in the hash table are safe from GC. For one-shot callbacks (like dispatch/schedule), remove the handler after it fires to avoid leaking entries. For persistent callbacks (like event handlers), remove on unbind/cleanup. The long↔void* cast is safe on both 32-bit and 64-bit platforms for small integer IDs.",
    "related": [
      "c-define-callback-limitation",
      "gambit-ffi-pointer-types"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "vendor-cpp-shared-library",
    "title": "Vendor and build a C++ library as shared .so for Gerbil FFI linking",
    "tags": [
      "ffi",
      "vendor",
      "shared-library",
      "c++",
      "build",
      "makefile",
      "ld-options",
      "rpath"
    ],
    "imports": [
      ":std/build-script",
      ":std/make"
    ],
    "code": "#!/usr/bin/env gxi\n;; build.ss — link FFI module against a vendored shared library\n;;\n;; When a C library is C++ internally but provides a C API (extern \"C\"),\n;; you can't compile it inline with Gambit's c-declare (which compiles as C).\n;; Instead: build the C++ source into a .so, then link the FFI module against it.\n\n(import :std/build-script)\n\n(defbuild-script\n  `((gxc: \"libmylib\"\n          \"-cc-options\" \"-I./vendor\"\n          \"-ld-options\" \"-L./vendor -lmylib -Wl,-rpath,$ORIGIN/vendor\")\n    \"mylib\"))\n\n;; === Makefile to build the vendored .so ===\n;;\n;; # Makefile\n;; CFLAGS := $(shell pkg-config --cflags dependency-lib)\n;; LIBS   := $(shell pkg-config --libs dependency-lib)\n;;\n;; vendor/libmylib.so: vendor/mylib.h\n;; \tg++ -shared -fPIC -o $@ -DMYLIB_BUILD_SHARED \\\n;; \t    -x c++ vendor/mylib.h $(CFLAGS) $(LIBS)\n;;\n;; build: vendor/libmylib.so\n;; \tgerbil build\n;;\n;; clean:\n;; \tgerbil clean\n;; \trm -f vendor/libmylib.so\n\n;; === Key details ===\n;;\n;; -Wl,-rpath,$ORIGIN/vendor\n;;   Embeds a relative rpath so the compiled Gerbil module finds\n;;   libmylib.so at runtime without setting LD_LIBRARY_PATH.\n;;   $ORIGIN expands to the directory containing the .so/.o file.\n;;\n;; -x c++\n;;   Tells g++ to compile the input as C++ even if the extension\n;;   is .h (needed for amalgamated single-header libraries).\n;;\n;; -DMYLIB_BUILD_SHARED\n;;   Many C/C++ libraries use a preprocessor flag to toggle between\n;;   static and shared library builds (controls dllexport/visibility).\n;;\n;; The Gerbil FFI module (.ss) only sees the C API (extern \"C\" functions).\n;; It uses define-c-lambda as normal — the C++ implementation is hidden\n;; behind the shared library boundary.",
    "notes": "This pattern is needed when: (1) the library source is C++ but provides a stable C API, (2) the library is not commonly available as a system package, (3) you want reproducible builds by vendoring a specific version. The amalgamated header approach (single .h file) is ideal for vendoring — just one file to manage. For libraries available via pkg-config, prefer linking directly with cppflags/ldflags instead. The rpath trick ($ORIGIN) avoids LD_LIBRARY_PATH but may need adjustment for installed packages vs development builds. On macOS, use -Wl,-rpath,@loader_path/vendor instead of $ORIGIN.",
    "related": [
      "build-ffi-pkg-config",
      "gambit-ffi-pointer-types"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ffi-foreign-release-prevent-double-free",
    "title": "Use foreign-release! to prevent double-free with FFI pointer finalizers",
    "tags": [
      "ffi",
      "foreign-release",
      "finalizer",
      "double-free",
      "destroy",
      "gc",
      "pointer"
    ],
    "imports": [],
    "code": ";; PROBLEM: When a c-define-type pointer has a finalizer, calling the\n;; C destroy function explicitly AND letting GC collect the object\n;; causes a double-free (segfault).\n;;\n;; Example setup:\n;; (c-define-type mytype_t* (pointer mytype_t (mytype_t*) \"ffi_mytype_destroy\"))\n;; (define-c-lambda mytype_destroy (mytype_t*) int \"mytype_destroy\")\n;;\n;; WRONG — double free:\n;; (def (my-destroy! obj)\n;;   (mytype_destroy obj))  ;; calls C destroy\n;; ;; Later, GC collects obj → finalizer calls mytype_destroy AGAIN → crash\n;;\n;; CORRECT — use foreign-release! which triggers the finalizer and marks\n;; the object as released so GC won't finalize it again:\n;; (def (my-destroy! obj)\n;;   (foreign-release! obj))\n;;\n;; You can also check if already released:\n;; (foreign-released? obj)  ;; => #t if already released\n\n;; Full pattern for a safe destroy function:\n(def (my-destroy! obj)\n  (unless (foreign-released? obj)\n    (foreign-release! obj)))",
    "notes": "foreign-release! and foreign-released? are Gambit builtins (no import needed). foreign-release! calls the finalizer registered in c-define-type and marks the object so GC won't finalize it again. Always use this instead of calling the raw C destroy function directly. This is critical for any FFI wrapper that offers explicit resource cleanup alongside GC-based cleanup.",
    "related": [
      "gambit-ffi-pointer-types",
      "c-define-callback-limitation"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "c-define-char-string-const-mismatch",
    "title": "Gambit c-define char-string generates char* not const char* — fix forward declarations",
    "tags": [
      "ffi",
      "c-define",
      "char-string",
      "const",
      "type-mismatch",
      "forward-declaration",
      "trampoline"
    ],
    "imports": [
      ":std/foreign"
    ],
    "code": ";; PROBLEM: When using c-define with char-string parameters, Gambit generates\n;; C functions with (char *) parameters, NOT (const char *).\n;; If your C forward declaration uses const char*, you get:\n;;   \"conflicting types for 'ffi_my_handler'\"\n;;\n;; WRONG — forward declaration uses const:\n;; void ffi_my_handler(long id, const char *name, const char *data);\n;;\n;; But c-define generates: void ffi_my_handler(long id, char *name, char *data);\n;; => COMPILATION ERROR: conflicting types\n\n;; FIX: Use char* (no const) in the forward declaration, and cast\n;; in the trampoline that calls it:\n\n;; In c-declare:\n(c-declare #<<END-C\n/* Forward declaration matches c-define's generated signature */\nvoid ffi_my_handler(long id, char *name, char *data);\n\n/* Trampoline receives const char* from C library, casts for c-define */\nstatic void my_trampoline(const char *name, const char *data, void *arg) {\n    long id = (long)arg;\n    ffi_my_handler(id, (char*)name, (char*)data);\n}\nEND-C\n)\n\n;; The c-define with char-string generates char* parameters:\n(c-define (ffi_my_handler id name data)\n          (long char-string char-string) void\n          \"ffi_my_handler\" \"\"\n  (displayln \"got: \" id \" \" name \" \" data))",
    "notes": "This is a common gotcha when writing FFI callback trampolines. The C library's callback signature typically uses const char*, but Gambit's c-define for char-string generates char*. The (char*) cast in the trampoline is safe because the c-define function only reads the string (Gambit copies it into a Scheme string). Without the cast, you get -Wdiscarded-qualifiers warnings; without matching the forward declaration, you get a hard compilation error.",
    "related": [
      "ffi-callback-dispatch-table",
      "c-define-callback-limitation"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "build-ss-absolute-path-cc-options",
    "title": "Use absolute paths in build.ss cc-options — relative paths break because gxc compiles in .gerbil/lib/",
    "tags": [
      "build",
      "build.ss",
      "cc-options",
      "absolute-path",
      "relative-path",
      "gxc",
      "include",
      "vendor"
    ],
    "imports": [
      ":std/build-script",
      ":std/make"
    ],
    "code": "#!/usr/bin/env gxi\n;; build.ss — MUST use absolute paths for -I and -L flags\n;;\n;; PROBLEM: gxc compiles .ss files into .gerbil/lib/pkg/module~0.c,\n;; then runs gcc from that directory. Relative paths like -I./vendor\n;; resolve relative to .gerbil/lib/pkg/, NOT the project root.\n;;\n;; WRONG — relative path breaks:\n;; (gxc: \"libfoo\" \"-cc-options\" \"-I./vendor\" ...)\n;; => fatal error: foo.h: No such file or directory\n\n;; CORRECT — compute absolute path from build.ss location:\n(import :std/build-script\n        :std/make)\n\n(def here (path-directory (this-source-file)))\n(def vendor-dir (path-expand \"vendor\" here))\n\n(defbuild-script\n  `((gxc: \"libfoo\"\n          \"-cc-options\" ,(string-append\n                          \"-I\" vendor-dir \" \"\n                          (cppflags \"some-lib\" \"\"))\n          \"-ld-options\" ,(string-append\n                          \"-L\" vendor-dir \" -lfoo \"\n                          \"-Wl,-rpath,\" vendor-dir \" \"\n                          (ldflags \"some-lib\" \"-lsome-lib\")))\n    \"foo\"))",
    "notes": "this-source-file returns the path to the currently executing file (build.ss). path-directory extracts the directory. path-expand joins path components. This pattern is essential when vendoring C libraries — the -I and -L flags must be absolute because gxc's working directory during compilation is NOT the project root. The -Wl,-rpath flag should also use the absolute path (or $ORIGIN for installed packages).",
    "related": [
      "build-ffi-pkg-config",
      "vendor-shared-library"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "write-json-arity-one-parameterize",
    "title": "write-json is arity 1 — uses current-output-port, must parameterize for string output",
    "tags": [
      "json",
      "write-json",
      "serialize",
      "arity",
      "current-output-port",
      "parameterize",
      "string"
    ],
    "imports": [
      ":std/text/json"
    ],
    "code": "(import :std/text/json)\n\n;; write-json takes ONLY the value — it writes to current-output-port.\n;; It does NOT accept a port argument (arity 1, not 2).\n\n;; WRONG — trying to pass port as second arg:\n;; (write-json data port)  ;; ERROR: wrong number of arguments\n\n;; CORRECT — parameterize current-output-port:\n(def (json-serialize value)\n  (call-with-output-string\n   (lambda (p)\n     (parameterize ((current-output-port p))\n       (write-json value)))))\n\n(json-serialize (hash (\"name\" \"alice\") (\"age\" 30)))\n;; => \"{\\\"name\\\":\\\"alice\\\",\\\"age\\\":30}\"\n\n(json-serialize [1 2 3])\n;; => \"[1,2,3]\"\n\n;; Similarly, read-json takes NO arguments — reads from current-input-port:\n(def (json-parse str)\n  (call-with-input-string str read-json))\n\n(json-parse \"[1, \\\"hello\\\", true, null]\")\n;; => (1 \"hello\" #t #!void)\n\n;; Alternative: json-object->string for quick hash->string:\n(json-object->string (hash (\"key\" \"value\")))\n;; => \"{\\\"key\\\":\\\"value\\\"}\"",
    "notes": "This differs from many Scheme JSON libraries that accept an optional port argument. In Gerbil's :std/text/json, both write-json and read-json use current-output-port/current-input-port respectively. json-object->string is a convenience wrapper but only works for hash tables (not lists/primitives). For general serialization, use the parameterize pattern shown above. JSON null maps to #!void in Gerbil.",
    "related": [
      "json-parse",
      "json-generate"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "define-c-type-predicate-returns-list-not-bool",
    "title": "FFI type predicate (##memq) returns sublist not #t — use as truthy, not equal? #t",
    "tags": [
      "ffi",
      "type-predicate",
      "memq",
      "foreign",
      "truthy",
      "test",
      "check"
    ],
    "imports": [],
    "code": ";; The standard FFI type predicate pattern uses ##memq:\n;;\n;; (define-macro (define-c-type-predicate pred tag)\n;;   `(define (,pred x)\n;;      (and (##foreign? x)\n;;           (##memq ',tag (foreign-tags x)))))\n;;\n;; ##memq returns the SUBLIST starting at the match, NOT #t.\n;; So (my-type? obj) returns something like (my-type*), which is truthy but not #t.\n\n;; WRONG in tests:\n;; (check (my-type? obj) => #t)  ;; FAILS: actual value is (my-type*)\n\n;; CORRECT — use predicate check:\n;; (check (my-type? obj) ? values)  ;; passes: (my-type*) is truthy\n\n;; Or wrap the predicate to return a proper boolean:\n(define-macro (define-c-type-predicate pred tag)\n  `(define (,pred x)\n     (and (##foreign? x)\n          (##memq ',tag (foreign-tags x))\n          #t)))",
    "notes": "This bites you in test suites where (check expr => #t) does exact comparison. The ##memq-based predicate returns the sublist (tag ...) which is truthy but not equal? to #t. Either use (check expr ? values) in tests, or add an explicit #t at the end of the predicate definition to coerce to boolean. The standard gerbil-cairo pattern does NOT include the #t coercion.",
    "related": [
      "gambit-ffi-pointer-types",
      "ffi-type-predicate"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ffi-utf8-string-unicode-support",
    "title": "Use UTF-8-string instead of char-string for Unicode FFI bindings",
    "tags": [
      "ffi",
      "UTF-8-string",
      "char-string",
      "unicode",
      "gambit",
      "c-define-type",
      "encoding"
    ],
    "imports": [
      ":std/foreign"
    ],
    "code": ";; PROBLEM: Gambit's char-string FFI type only handles Latin-1 (ISO 8859-1).\n;; Passing strings with non-Latin-1 characters (e.g., em-dash U+2014, CJK, emoji)\n;; causes: \"Can't convert to C char-string\"\n;;\n;; SOLUTION: Use UTF-8-string instead of char-string in all FFI bindings.\n;; UTF-8-string properly encodes/decodes Unicode strings as UTF-8 C strings.\n\n(begin-ffi (my_set_title my_get_title)\n  (c-declare \"#include \\\"mylib.h\\\"\")\n\n  ;; WRONG — breaks on Unicode:\n  ;; (define-c-lambda my_set_title (void* char-string) int \"set_title\")\n\n  ;; CORRECT — handles all Unicode:\n  (define-c-lambda my_set_title (void* UTF-8-string) int \"set_title\")\n\n  ;; Works for return types too:\n  (define-c-lambda my_get_title (void*) UTF-8-string \"get_title\")\n\n  ;; Also works in c-define callbacks (Scheme functions callable from C):\n  ;; The C forward declaration still uses char* — Gambit generates char*\n  ;; for both char-string and UTF-8-string in c-define signatures.\n  (c-declare \"void my_callback(char *text);\")\n\n  (c-define (my_callback text)\n            (UTF-8-string) void   ;; <-- UTF-8-string here too\n            \"my_callback\" \"\"\n    (displayln \"received: \" text))\n)\n\n;; SUMMARY:\n;; - char-string   → Latin-1 only (ISO 8859-1, first 256 Unicode code points)\n;; - UTF-8-string  → Full Unicode via UTF-8 encoding\n;; - nonnull-UTF-8-string → Same but rejects #f (NULL)\n;; - Always prefer UTF-8-string unless you specifically need Latin-1",
    "notes": "This is a common gotcha when binding modern C libraries that accept UTF-8 strings (which is most of them). The error \"Can't convert to C char-string\" at runtime means the string contains characters outside Latin-1. The fix is a simple find-and-replace of char-string → UTF-8-string in your FFI bindings. Both types generate char* in the C code, so no C-side changes are needed. The c-define forward declarations use char* for both types.",
    "related": [
      "c-define-char-string-const-mismatch",
      "gambit-ffi-pointer-types"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gerbil-pkg-install-with-depend",
    "title": "Install dependencies declared in gerbil.pkg depend: via gerbil pkg install",
    "tags": [
      "gerbil",
      "pkg",
      "install",
      "depend",
      "dependency",
      "gxpkg",
      "package"
    ],
    "imports": [],
    "code": ";; To properly install a dependency declared in gerbil.pkg:\n;;\n;; 1. Declare the dependency in gerbil.pkg:\n;;    (package: my-project)\n;;    (depend: (\"github.com/ober/gerbil-svg\"))\n;;\n;; 2. Run `gerbil pkg install` FROM the project directory:\n;;    cd /path/to/my-project\n;;    gerbil pkg install github.com/ober/gerbil-svg\n;;\n;; This installs into the LOCAL project context:\n;;    .gerbil/pkg/github.com/ober/gerbil-svg/   (source, cloned from git)\n;;    .gerbil/lib/gerbil-svg/                    (compiled modules)\n;;\n;; The local context is CORRECT — gerbil build automatically finds\n;; packages in .gerbil/pkg/ when gerbil.pkg has depend: entries.\n;; No GERBIL_LOADPATH needed for build.\n;;\n;; 3. For gxi scripts/demos that import project + dependency modules,\n;;    include the local .gerbil/lib in GERBIL_LOADPATH:\n;;    GERBIL_LOADPATH=.gerbil/lib gxi demo/my-demo.ss\n;;\n;; KEY POINTS:\n;; - `gerbil pkg install` from a project dir → installs to LOCAL .gerbil/\n;; - `gerbil pkg install` from $HOME → installs to GLOBAL ~/.gerbil/\n;; - With depend: declared, local install is preferred (self-contained project)\n;; - `gerbil build` auto-resolves local .gerbil/pkg/ deps (no LOADPATH needed)\n;; - gxi scripts need GERBIL_LOADPATH=.gerbil/lib to find local deps",
    "notes": "The local vs global install context confused many sessions. When you run `gerbil pkg install` from inside a project (directory with gerbil.pkg), it installs to the project's .gerbil/ directory. This is intentional — it makes the project self-contained. The compiled modules land in .gerbil/lib/ which `gerbil build` searches automatically. For global installs, cd to $HOME first or use the gerbil_package_manage MCP tool with global_env: true.",
    "related": [
      "gxpkg-install-destroys-cwd",
      "gerbil-build-loadpath"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "build-ss-setenv-pkg-config-path",
    "title": "Set PKG_CONFIG_PATH inside build.ss for standalone gerbil pkg install",
    "tags": [
      "setenv",
      "PKG_CONFIG_PATH",
      "build.ss",
      "pkg-config",
      "gerbil pkg install",
      "linuxbrew",
      "environment"
    ],
    "imports": [
      ":std/build-script",
      ":std/make",
      ":std/misc/process"
    ],
    "code": "#!/usr/bin/env gxi\n;; build.ss — self-contained build script that works when invoked by\n;; `gerbil pkg install` (which does NOT inherit Makefile exports).\n;;\n;; PROBLEM: `gerbil pkg install github.com/user/my-ffi-pkg` clones\n;; the repo and runs build.ss directly. If the system uses linuxbrew's\n;; pkg-config (or any non-standard pkg-config), the default search path\n;; won't include system .pc files like gtk+-3.0.pc or libssl.pc.\n;;\n;; The Makefile workaround:\n;;   export PKG_CONFIG_PATH := /usr/lib/x86_64-linux-gnu/pkgconfig:$(PKG_CONFIG_PATH)\n;; does NOT help because `gerbil pkg install` doesn't use the Makefile.\n;;\n;; FIX: Set PKG_CONFIG_PATH inside build.ss using Gambit's setenv:\n\n(import :std/build-script\n        :std/make\n        :std/misc/process)\n\n;; Ensure pkg-config finds system packages\n;; (linuxbrew's pkg-config only searches its own paths)\n(let ((current (getenv \"PKG_CONFIG_PATH\" \"\"))\n      (sysdir \"/usr/lib/x86_64-linux-gnu/pkgconfig\"))\n  (when (and (file-exists? sysdir)\n             (not (string-contains current sysdir)))\n    (setenv \"PKG_CONFIG_PATH\"\n            (if (string-empty? current) sysdir\n                (string-append sysdir \":\" current)))))\n\n;; Now cppflags/ldflags will find system packages\n(def here (path-directory (this-source-file)))\n(def vendor-dir (path-expand \"vendor\" here))\n\n(defbuild-script\n  `((gxc: \"libfoo\"\n          \"-cc-options\" ,(string-append \"-I\" vendor-dir \" \" (cppflags \"gtk+-3.0\" \"\"))\n          \"-ld-options\" ,(string-append \"-L\" vendor-dir \" -lfoo \" (ldflags \"gtk+-3.0\" \"-lgtk-3\")))\n    \"foo\"))",
    "notes": "This is essential for FFI packages that use pkg-config and will be installed via `gerbil pkg install`. Without this, `cppflags`/`ldflags` from :std/make silently fall back to their default values (often empty strings), causing g++ compilation to fail with missing headers. The `file-exists?` guard makes it safe on non-Debian systems. `setenv` and `getenv` are Gambit builtins — no import needed. `string-contains` and `string-empty?` are also Gambit builtins. The path `/usr/lib/x86_64-linux-gnu/pkgconfig` is the Debian/Ubuntu multiarch location — on RHEL/Fedora it would be `/usr/lib64/pkgconfig`.",
    "related": [
      "build-ss-absolute-path-cc-options",
      "build-ffi-pkg-config",
      "vendor-shared-library"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "char-literal-parens-brackets",
    "title": "Avoid #\\\\( #\\\\) #\\\\[ #\\\\] character literals in code",
    "tags": [
      "character",
      "literal",
      "paren",
      "bracket",
      "reader",
      "workaround",
      "char->integer"
    ],
    "imports": [],
    "code": ";; Problem: #\\( #\\) #\\[ #\\] character literals confuse the Gerbil reader\n;; when used inside list expressions. The reader sees [ as list syntax\n;; and ) as a closer, causing \"Datum or EOF expected\" errors.\n;;\n;; WRONG — causes reader errors:\n;; (or (char=? ch #\\()\n;;     (char=? ch #\\))\n;;     (char=? ch #\\[)\n;;     (char=? ch #\\]))\n;;\n;; CORRECT — use integer comparison:\n(def (is-bracket-char? ch)\n  (let ((c (char->integer ch)))\n    (or (= c 40)    ;; (\n        (= c 41)    ;; )\n        (= c 91)    ;; [\n        (= c 93)    ;; ]\n        (= c 123)   ;; {\n        (= c 125))));; }\n\n;; Test:\n;; (is-bracket-char? (string-ref \"(\" 0))  ;; => #t\n;; (is-bracket-char? (string-ref \"a\" 0))  ;; => #f",
    "notes": "ASCII codes: ( = 40, ) = 41, [ = 91, ] = 93, { = 123, } = 125. The #\\{ and #\\} may also cause issues since { } is method dispatch syntax. Always use char->integer comparison for delimiter characters. #\\/ #\\\\ #\\. etc. are fine.",
    "related": [
      "dotted-pair-in-brackets"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "defrules-macro-ambiguity-fix",
    "title": "Fix defrules macro ambiguity with optional pattern argument",
    "tags": [
      "defrules",
      "macro",
      "ambiguity",
      "pattern",
      "optional",
      "ellipsis"
    ],
    "imports": [],
    "code": ";; Problem: When a defrules macro has two clauses — one with a pattern\n;; argument and one without — calls with a single expression always\n;; match the first clause, treating the expression as the pattern.\n;;\n;; WRONG — (my-macro (some-expr)) matches first clause,\n;; pattern = (some-expr), body ... = () (empty), producing (lambda () )\n;;\n;; (defrules my-macro ()\n;;   ((_ pattern body ...)\n;;    (do-with-pattern pattern (lambda () body ...)))\n;;   ((_ body ...)\n;;    (do-without-pattern (lambda () body ...))))\n;;\n;; CORRECT — require at least one body form when pattern is present:\n(defrules my-macro ()\n  ((_ pattern body0 body ...)\n   (do-with-pattern pattern (lambda () body0 body ...)))\n  ((_ body ...)\n   (do-without-pattern (lambda () body ...))))\n\n;; Now:\n;; (my-macro (expr))         => matches second clause (no pattern)\n;; (my-macro \"/path\" (expr)) => matches first clause (with pattern)",
    "notes": "The key insight is that body ... (with ellipsis) matches ZERO or more items. So ((_ pattern body ...) always matches any call with 1+ args, even when body ... is empty. Using body0 body ... requires at least one body form, forcing single-arg calls to fall through to the patternless clause.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "path-normalize-missing-dir",
    "title": "path-normalize throws on non-existent directories",
    "tags": [
      "path-normalize",
      "file",
      "directory",
      "error",
      "with-catch",
      "exists"
    ],
    "imports": [],
    "code": ";; Problem: (path-normalize \"./some/path\") throws an error if the\n;; directory doesn't exist, instead of returning a normalized string.\n;;\n;; WRONG — crashes if ./public doesn't exist:\n;; (path-normalize \"./public/./file.txt\")\n;; => \"No such file or directory\" error\n;;\n;; CORRECT — wrap in with-catch:\n(def (safe-path-normalize path)\n  (with-catch\n    (lambda (e) #f)\n    (lambda () (path-normalize path))))\n\n;; Or when used in a function that should return #f on failure:\n(def (try-resolve-file base-dir rel-path)\n  (with-catch\n    (lambda (e) #f)\n    (lambda ()\n      (let* ((full (path-expand rel-path base-dir))\n             (normalized (path-normalize full)))\n        (and (file-exists? normalized) normalized)))))",
    "notes": "This commonly bites in web frameworks when checking for static files in a public/ directory that may not exist. Always guard path-normalize with with-catch when the directory is user-configurable or optional.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "http-request-method-returns-symbol",
    "title": "http-request-method returns a symbol, not a string",
    "tags": [
      "httpd",
      "http-request-method",
      "symbol",
      "string",
      "net",
      "server",
      "request"
    ],
    "imports": [
      ":std/net/httpd"
    ],
    "code": "(import :std/net/httpd)\n\n;; http-request-method returns a SYMBOL like 'GET, 'POST, etc.\n;; NOT a string like \"GET\".\n\n;; WRONG — crashes or always returns \"GET\":\n;; (def method (string->symbol (http-request-method req)))\n;; This calls string->symbol on a symbol, which errors.\n\n;; CORRECT — guard against both types:\n(def (get-method req)\n  (let ((m (http-request-method req)))\n    (if (symbol? m) m (string->symbol m))))\n\n;; Or just use it directly as a symbol:\n(def (handle-request req res)\n  (case (http-request-method req)\n    ((GET)  (handle-get req res))\n    ((POST) (handle-post req res))\n    (else   (method-not-allowed res))))",
    "notes": "This is a common gotcha when wrapping httpd requests. The method is already a symbol, so you can compare with eq? or use in case forms directly. If you need a string, use (symbol->string (http-request-method req)).",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "makefile-local-install-rsync",
    "title": "Makefile for installing a local Gerbil library globally with gerbil pkg",
    "tags": [
      "makefile",
      "install",
      "gerbil",
      "pkg",
      "link",
      "build",
      "global",
      "library"
    ],
    "imports": [],
    "code": ";; Standard Makefile for a Gerbil library with build/test/install/uninstall.\n;; Uses `gerbil pkg link -g` + `gerbil pkg build -g` for proper global install.\n;;\n;; CRITICAL: gerbil pkg commands MUST run from OUTSIDE the project directory\n;; (e.g. `cd /tmp &&`) to avoid the local .gerbil/ context interfering.\n;; Running from within the project dir silently fails or worse.\n;;\n;; ---- Makefile ----\n;; export GERBIL_LOADPATH := $(HOME)/.gerbil/lib\n;;\n;; .PHONY: build test clean install uninstall\n;;\n;; build:\n;; \tgerbil build\n;;\n;; test: build\n;; \tgerbil test ./...\n;;\n;; clean:\n;; \tgerbil clean\n;;\n;; install: build\n;; \tcd /tmp && gerbil pkg link -g mypackage $(CURDIR)\n;; \tcd /tmp && gerbil pkg build -g mypackage\n;;\n;; uninstall:\n;; \tcd /tmp && gerbil pkg unlink -g mypackage\n;; ---- end ----\n;;\n;; The package name (\"mypackage\") must match (package: mypackage) in gerbil.pkg.\n;;\n;; How it works:\n;; - `gerbil pkg link -g NAME PATH` creates a symlink at ~/.gerbil/pkg/NAME -> PATH\n;; - `gerbil pkg build -g NAME` compiles and installs artifacts to ~/.gerbil/lib/NAME/\n;; - `gerbil pkg unlink -g NAME` removes the symlink and cleans installed artifacts\n;;\n;; After `make install`, import with:\n;;   (import :mypackage/module-name)",
    "notes": "The `cd /tmp &&` prefix is essential — without it, gxpkg sees the local .gerbil/ directory and operates in local package context instead of global, causing the link to silently fail. The -g flag alone is NOT sufficient when CWD has a .gerbil/ subdirectory. This replaces the previous rsync-based recipe which bypassed Gerbil's package manager.",
    "related": [
      "gxpkg-install-destroys-cwd",
      "gerbil-build-loadpath"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "websocket-binary-send-receive",
    "title": "Send and receive binary WebSocket messages",
    "tags": [
      "websocket",
      "binary",
      "send",
      "receive",
      "message",
      "u8vector",
      "network"
    ],
    "imports": [
      ":std/net/websocket"
    ],
    "code": "(import :std/net/websocket)\n\n;; Connect to a WebSocket endpoint\n(def ws (websocket-connect \"wss://example.com/ws\"))\n\n;; IMPORTANT: make-message is a STRUCT constructor — positional args only!\n;; Field order: (data type partial?)\n;; - data: u8vector for binary, string for text\n;; - type: 'binary or 'text\n;; - partial?: #f for complete messages\n\n;; Send a binary message\n(def payload #u8(1 2 3 4 5))\n(WebSocket-send ws (make-message payload 'binary #f))\n\n;; Send a text message\n(WebSocket-send ws (make-message \"{\\\"action\\\":\\\"hello\\\"}\" 'text #f))\n\n;; Receive a message (blocks until available)\n(let ((msg (WebSocket-recv ws)))\n  (displayln \"Type: \" (message-type msg))      ;; 'binary or 'text\n  (displayln \"Data: \" (message-data msg))      ;; u8vector or string\n  (displayln \"Partial: \" (message-partial? msg)))\n\n;; Close the connection\n(WebSocket-close ws)",
    "notes": "CRITICAL: make-message uses POSITIONAL arguments (it's a defstruct). Do NOT use keyword args like (make-message type: 'binary data: payload) — this will fail with \"arguments don't match object size\". The field order is (data type partial?). WebSocket-send and WebSocket-recv are the methods (capital W). message-data, message-type, message-partial? are the accessors (lowercase m).",
    "related": [
      "defstruct-positional-args"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "os-pipe-create-fd-pair",
    "title": "Create OS pipe fd pair with :std/os/pipe",
    "tags": [
      "pipe",
      "fd",
      "file descriptor",
      "os",
      "pipeline",
      "ipc",
      "values"
    ],
    "imports": [
      ":std/os/pipe",
      ":std/os/fd",
      ":std/os/fdio"
    ],
    "code": ";; Create an OS-level pipe using :std/os/pipe\n;; pipe returns VALUES (not a vector!) with a direction parameter.\n;; Signature: (pipe (direction 'inout) (closeonexec #t))\n;; direction controls which ends become Gambit ports vs raw fds:\n;;   'inout (default) — both ends are Gambit ports (read-port, write-port)\n;;   'in    — read end is Gambit port, write end is raw fd\n;;   'out   — read end is raw fd, write end is Gambit port\n;;   'none  — both ends are raw fd integers\n(import :std/os/pipe :std/os/fd :std/os/fdio)\n\n;; Default ('inout) — both ends are Gambit ports:\n(receive (read-port write-port) (pipe)\n  (display \"hello from pipe\\n\" write-port)\n  (force-output write-port)\n  (close-port write-port)\n  (let ((line (read-line read-port)))\n    (close-port read-port)\n    line))\n;; => \"hello from pipe\"\n\n;; Raw fds ('none) — for passing to open-process or fdwrite:\n(receive (read-fd write-fd) (pipe 'none)\n  (fdwrite write-fd (string->bytes \"raw pipe data\\n\"))\n  (close write-fd)\n  (let* ((read-port (fdopen read-fd 'in))\n         (line (read-line read-port)))\n    (close-port read-port)\n    line))\n;; => \"raw pipe data\"\n\n;; Mixed ('in) — read port + raw write fd (useful for shell pipelines):\n;; Launch cmd1 with stdout -> write-fd, read cmd1 output from read-port\n(receive (read-port write-fd) (pipe 'in)\n  ;; write-fd is a raw integer for passing to open-process\n  ;; read-port is a Gambit port for read-line etc.\n  (close write-fd)    ;; close raw fd with close from :std/os/fdio\n  (close-port read-port))\n\n;; PIPELINE PATTERN for cmd1 | cmd2:\n;;   (receive (read-port write-fd) (pipe 'in)\n;;     ;; Launch cmd1 with stdout -> write-fd\n;;     ;; Launch cmd2 with stdin -> read-port\n;;     ;; Close write-fd and read-port in parent\n;;     ;; Wait for both processes)",
    "notes": "CORRECTED: pipe returns VALUES (via (values ...)), NOT a vector. Use receive or call-with-values to destructure. The direction parameter controls which ends are Gambit ports vs raw fd integers. Default 'inout gives both as ports. Use 'none for raw fds, 'in for read-port+write-fd, 'out for read-fd+write-port. The closeonexec parameter defaults to #t (sets O_CLOEXEC). Use close from :std/os/fdio for raw fds, close-port for Gambit ports.",
    "related": [
      "open-process-stdin-write-read",
      "run-external-process"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "u8vector-big-endian-encoding",
    "title": "Big-endian binary encoding/decoding with u8vectors",
    "tags": [
      "u8vector",
      "binary",
      "big-endian",
      "encode",
      "decode",
      "uint32",
      "uint64",
      "network",
      "protocol"
    ],
    "imports": [],
    "code": ";; Big-endian uint32 encode/decode\n(def (encode-uint32 n)\n  (u8vector (bitwise-and (arithmetic-shift n -24) #xff)\n            (bitwise-and (arithmetic-shift n -16) #xff)\n            (bitwise-and (arithmetic-shift n -8) #xff)\n            (bitwise-and n #xff)))\n\n(def (decode-uint32 buf offset)\n  (+ (arithmetic-shift (u8vector-ref buf offset) 24)\n     (arithmetic-shift (u8vector-ref buf (+ offset 1)) 16)\n     (arithmetic-shift (u8vector-ref buf (+ offset 2)) 8)\n     (u8vector-ref buf (+ offset 3))))\n\n;; Big-endian uint64 encode/decode\n(def (encode-uint64 n)\n  (u8vector (bitwise-and (arithmetic-shift n -56) #xff)\n            (bitwise-and (arithmetic-shift n -48) #xff)\n            (bitwise-and (arithmetic-shift n -40) #xff)\n            (bitwise-and (arithmetic-shift n -32) #xff)\n            (bitwise-and (arithmetic-shift n -24) #xff)\n            (bitwise-and (arithmetic-shift n -16) #xff)\n            (bitwise-and (arithmetic-shift n -8) #xff)\n            (bitwise-and n #xff)))\n\n(def (decode-uint64 buf offset)\n  (+ (arithmetic-shift (u8vector-ref buf offset) 56)\n     (arithmetic-shift (u8vector-ref buf (+ offset 1)) 48)\n     (arithmetic-shift (u8vector-ref buf (+ offset 2)) 40)\n     (arithmetic-shift (u8vector-ref buf (+ offset 3)) 32)\n     (arithmetic-shift (u8vector-ref buf (+ offset 4)) 24)\n     (arithmetic-shift (u8vector-ref buf (+ offset 5)) 16)\n     (arithmetic-shift (u8vector-ref buf (+ offset 6)) 8)\n     (u8vector-ref buf (+ offset 7))))\n\n;; u8vector helpers for building binary protocols\n(def (u8v-copy! dest dest-off src src-off len)\n  (let loop ((i 0))\n    (when (< i len)\n      (u8vector-set! dest (+ dest-off i) (u8vector-ref src (+ src-off i)))\n      (loop (+ i 1)))))\n\n(def (u8v-append . vecs)\n  (let* ((total (apply + (map u8vector-length vecs)))\n         (result (make-u8vector total 0)))\n    (let loop ((vecs vecs) (off 0))\n      (unless (null? vecs)\n        (let ((v (car vecs)))\n          (u8v-copy! result off v 0 (u8vector-length v))\n          (loop (cdr vecs) (+ off (u8vector-length v))))))\n    result))\n\n(def (u8v-slice buf start end)\n  (let* ((len (- end start))\n         (result (make-u8vector len)))\n    (u8v-copy! result 0 buf start len)\n    result))\n\n;; Example: build a 12-byte header\n;; [4 bytes: msg-type] [4 bytes: length] [4 bytes: seq-num]\n(def header (u8v-append (encode-uint32 1)     ;; msg-type = 1\n                        (encode-uint32 256)   ;; length = 256\n                        (encode-uint32 42)))  ;; seq-num = 42\n;; => #u8(0 0 0 1 0 0 1 0 0 0 0 42)",
    "notes": "Gerbil's arithmetic-shift and bitwise-and work on arbitrary precision integers, so uint64 encoding works without overflow issues. For signed int64, use two's complement: if the high bit is set after decode-uint64, subtract (expt 2 64). u8v-append is not in the stdlib — you need to define it yourself for building binary protocol messages.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "signal-handler-add-remove",
    "title": "Register and remove signal handlers with :std/os/signal-handler",
    "tags": [
      "signal",
      "handler",
      "SIGINT",
      "SIGCHLD",
      "SIGTERM",
      "trap",
      "os"
    ],
    "imports": [
      ":std/os/signal",
      ":std/os/signal-handler"
    ],
    "code": ";; Register signal handlers using :std/os/signal-handler\n;; Signal constants are in :std/os/signal\n(import :std/os/signal :std/os/signal-handler)\n\n;; Available signal constants (partial list):\n;; SIGINT SIGTERM SIGHUP SIGQUIT SIGCHLD SIGPIPE\n;; SIGTSTP SIGCONT SIGSTOP SIGUSR1 SIGUSR2 SIGWINCH\n;; SIGALRM SIGURG SIGPROF SIGVTALRM\n\n;; Register a handler — returns a handler-id for later removal\n(def handler-id\n  (add-signal-handler! SIGINT\n    (lambda (sig)\n      (displayln \"\\nCaught SIGINT (Ctrl+C)\")\n      ;; Handle the signal — e.g., set a flag, cleanup, etc.\n      )))\n\n;; Remove the handler when done\n(remove-signal-handler! handler-id)\n\n;; Multiple handlers can be registered for the same signal:\n(def h1 (add-signal-handler! SIGTERM\n          (lambda (sig) (displayln \"Handler 1: cleanup\"))))\n(def h2 (add-signal-handler! SIGTERM\n          (lambda (sig) (displayln \"Handler 2: save state\"))))\n\n;; Remove individually:\n(remove-signal-handler! h1)\n(remove-signal-handler! h2)\n\n;; Send signals to processes using kill:\n(import :std/os/signal)\n(kill pid SIGTERM)    ;; send SIGTERM to process\n(kill pid SIGINT)     ;; send SIGINT\n(kill pid SIGCONT)    ;; resume a stopped process\n(kill pid SIGSTOP)    ;; stop (pause) a process\n\n;; Block/unblock signals with sigprocmask:\n(let ((mask (make_sigset)))\n  (sigemptyset mask)\n  (sigaddset mask SIGCHLD)\n  (sigprocmask SIG_BLOCK mask #f))  ;; block SIGCHLD",
    "notes": "add-signal-handler! returns a handler ID (not void) — save it for removal with remove-signal-handler!. The handler receives the signal number as its argument. Multiple handlers can be registered for the same signal; they all fire. kill from :std/os/signal sends signals to processes by PID. For signal masking, use sigprocmask with make_sigset, sigemptyset, sigaddset, sigfillset, sigdelset, and sigismember. Constants SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK control the masking operation.",
    "related": [
      "run-external-process",
      "os-pipe-create-fd-pair"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "terminal-raw-mode-stty",
    "title": "Set terminal to raw mode and restore on exit",
    "tags": [
      "terminal",
      "raw",
      "stty",
      "tty",
      "interactive",
      "console",
      "unbuffered"
    ],
    "imports": [
      ":std/misc/ports",
      ":std/misc/process"
    ],
    "code": "(import :std/misc/ports :std/misc/process)\n\n;; Save current terminal settings\n(def (get-terminal-settings)\n  (with-input-from-process\n    (list path: \"stty\" arguments: [\"-g\"] stdin-redirection: #f)\n    read-all-as-string))\n\n;; Set raw mode (unbuffered, no echo, pass signals)\n(def (set-terminal-raw!)\n  (run-process [\"stty\" \"raw\" \"-echo\" \"icrnl\"]\n    stdin-redirection: #f))\n\n;; Restore saved settings\n(def (restore-terminal! saved-settings)\n  (run-process [\"stty\" (string-trim-right saved-settings)]\n    stdin-redirection: #f))\n\n;; Get terminal size as (columns . rows)\n(def (get-terminal-size)\n  (let ((output (with-input-from-process\n                  (list path: \"stty\" arguments: [\"size\"]\n                        stdin-redirection: #f)\n                  read-all-as-string)))\n    (let ((parts (string-split output #\\space)))\n      (if (>= (length parts) 2)\n        (cons (string->number (list-ref parts 1))   ;; columns\n              (string->number (list-ref parts 0)))   ;; rows\n        (cons 80 24)))))  ;; fallback\n\n;; Example: interactive session with raw terminal\n(def saved-settings (get-terminal-settings))\n(dynamic-wind\n  (lambda () (set-terminal-raw!))\n  (lambda ()\n    ;; Raw terminal active — read single keystrokes\n    (let loop ()\n      (let ((byte (read-u8 (current-input-port))))\n        (unless (or (eof-object? byte) (= byte 3))  ;; Ctrl-C = 3\n          ;; Process the byte...\n          (displayln \"Got: \" byte)\n          (force-output)\n          (loop)))))\n  (lambda () (restore-terminal! saved-settings)))",
    "notes": "CRITICAL: stty must access the actual terminal, so use stdin-redirection: #f to prevent Gambit from redirecting stdin. Without this, stty will error with \"stdin isn't a terminal\". string-trim-right is needed because stty -g output may include a trailing newline. For interactive binary protocols (like SSM sessions), use read-u8 to read single bytes from stdin in raw mode, not read-char or read-line. Use unwind-protect or dynamic-wind to always restore terminal settings, even on error.",
    "related": [
      "run-external-process-capture-output"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "open-process-stdin-write-read",
    "title": "Write to subprocess stdin and read stdout via open-process",
    "tags": [
      "process",
      "stdin",
      "write",
      "pipe",
      "subprocess",
      "bidirectional"
    ],
    "imports": [],
    "code": ";; open-process with bidirectional I/O — write to stdin, read from stdout\n;; No imports needed — open-process is a Gambit builtin\n\n;; The port returned by open-process is bidirectional (input+output):\n;; - display/write/fprintf writes to the child's stdin\n;; - read-line/read-char reads from the child's stdout\n\n(let* ((proc (open-process\n               (list path: \"/bin/cat\"\n                     arguments: '()\n                     stdout-redirection: #t\n                     stdin-redirection: #t)))\n       ;; Write to child's stdin\n       (_ (display \"hello from parent\\n\" proc))\n       (_ (force-output proc))\n       ;; Close the write direction so child sees EOF on stdin\n       (_ (close-output-port proc))\n       ;; Read from child's stdout\n       (line (read-line proc))\n       ;; Get exit status (blocks until process exits)\n       (status (process-status proc)))\n  (list line status))\n;; => (\"hello from parent\" 0)\n\n;; IMPORTANT GOTCHAS:\n;; 1. Call (force-output proc) after writing — output is buffered\n;; 2. Call (close-output-port proc) when done writing, or child\n;;    may block forever waiting for more input\n;; 3. process-status blocks until the child exits\n;; 4. Read ALL output BEFORE calling process-status, or you may\n;;    deadlock (child blocks on write, parent blocks on wait)\n\n;; Pattern for interactive command (write, read response, repeat):\n(let ((proc (open-process\n              (list path: \"/usr/bin/bc\"\n                    arguments: '(\"-l\")\n                    stdout-redirection: #t\n                    stdin-redirection: #t))))\n  (display \"2 + 3\\n\" proc)\n  (force-output proc)\n  (let ((result (read-line proc)))\n    (display \"quit\\n\" proc)\n    (force-output proc)\n    (close-output-port proc)\n    (process-status proc)\n    result))\n;; => \"5\"\n\n;; Pattern for filter (write all input, then read all output):\n(let ((proc (open-process\n              (list path: \"/usr/bin/sort\"\n                    arguments: '()\n                    stdout-redirection: #t\n                    stdin-redirection: #t))))\n  (for-each (lambda (line) (display line proc) (newline proc))\n            '(\"cherry\" \"apple\" \"banana\"))\n  (force-output proc)\n  (close-output-port proc)\n  (let loop ((lines '()))\n    (let ((line (read-line proc)))\n      (if (eof-object? line)\n        (begin (process-status proc) (reverse lines))\n        (loop (cons line lines))))))",
    "notes": "The port from open-process is bidirectional when both stdin-redirection: and stdout-redirection: are #t. The MOST COMMON mistake is forgetting force-output (writes are buffered) or forgetting close-output-port (child never sees EOF). Deadlock warning: if the child produces output while you're still writing, and the pipe buffer fills, both processes block. For large data, use threads: one thread writes stdin, another reads stdout. The process-status call blocks — always drain stdout first.",
    "related": [
      "run-external-process",
      "os-pipe-create-fd-pair",
      "run-subprocess-custom-env"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "binary-io-device-ports",
    "title": "Binary I/O on device ports (stdin/stdout) with write-subu8vector and read-u8",
    "tags": [
      "binary",
      "io",
      "stdin",
      "stdout",
      "write-subu8vector",
      "read-u8",
      "u8vector",
      "port"
    ],
    "imports": [],
    "code": ";; Writing binary data to stdout (or any output port)\n;; write-u8vector requires explicit port argument\n(def (write-binary-to-port data port)\n  (write-subu8vector data 0 (u8vector-length data) port)\n  (force-output port))\n\n;; Example: write binary payload to stdout\n(write-subu8vector #u8(72 101 108 108 111) 0 5 (current-output-port))\n(force-output (current-output-port))\n\n;; Reading single bytes from stdin (e.g., raw terminal input)\n;; read-u8 returns a fixnum (0-255) or eof-object\n(let loop ()\n  (let ((byte (read-u8 (current-input-port))))\n    (cond\n      ((eof-object? byte) (displayln \"EOF\"))\n      (else\n        (displayln \"Read byte: \" byte)\n        (loop)))))\n\n;; Reading a fixed number of bytes\n;; read-subu8vector returns the number of bytes actually read\n(def (read-exactly port n)\n  (let ((buf (make-u8vector n)))\n    (let loop ((offset 0))\n      (if (>= offset n) buf\n        (let ((got (read-subu8vector buf offset n port)))\n          (if (= got 0) #f  ;; EOF before filling\n            (loop (+ offset got))))))))\n\n;; Example: read 4-byte header then variable-length payload\n(let* ((header (read-exactly (current-input-port) 4))\n       (payload-len (decode-uint32 header 0))\n       (payload (read-exactly (current-input-port) payload-len)))\n  (displayln \"Payload: \" payload))",
    "notes": "GOTCHA: write-u8vector has arity issues on some ports — use write-subu8vector instead, which takes (buf start end port) and always works. read-u8vector takes a COUNT argument (not a buffer), returning a new u8vector — but for interactive byte-at-a-time reading, use read-u8 instead. read-subu8vector returns the number of bytes read (may be less than requested), so loop until you have enough. Always call (force-output port) after writing binary data to ensure it's flushed.",
    "related": [
      "u8vector-big-endian-encoding",
      "terminal-raw-mode-stty"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "directory-files-list-entries",
    "title": "List directory entries with directory-files and file-info",
    "tags": [
      "directory",
      "files",
      "list",
      "stat",
      "file-info",
      "ls",
      "filesystem"
    ],
    "imports": [],
    "code": ";; directory-files and file-info are Gambit builtins — no imports needed\n\n;; Basic: list files in a directory\n(directory-files \".\")\n;; => (\".\" \"..\" \".git\" \"README.md\" \"src\" ...)\n\n;; With options via settings list:\n(directory-files (list path: \".\" ignore-hidden: 'dot-and-dot-dot))\n;; => (\".git\" \"README.md\" \"src\" ...)\n;; ignore-hidden: 'dot-and-dot-dot excludes \".\" and \"..\" only\n\n;; Get file metadata with file-info (like stat):\n(let ((info (file-info \"README.md\")))\n  (list\n    (file-info-type info)                  ;; 'regular, 'directory, 'symbolic-link, etc.\n    (file-info-mode info)                  ;; permission bits as integer (e.g., 493 = #o755)\n    (file-info-size info)                  ;; size in bytes\n    (file-info-owner info)                 ;; uid (integer)\n    (file-info-group info)                 ;; gid (integer)\n    (file-info-last-modification-time info) ;; Gambit time object\n    (file-info-number-of-links info)))     ;; hard link count\n\n;; Check file type:\n(eq? (file-info-type (file-info \"src\")) 'directory)  ;; => #t\n\n;; file-info-type returns one of:\n;;   'regular  'directory  'symbolic-link  'character-special\n;;   'block-special  'fifo  'socket\n\n;; Pattern: list only regular files in a directory\n(let ((dir \".\"))\n  (filter (lambda (name)\n            (let ((path (string-append dir \"/\" name)))\n              (eq? (file-info-type (file-info path)) 'regular)))\n          (directory-files (list path: dir ignore-hidden: 'dot-and-dot-dot))))\n\n;; Pattern: recursive directory walk\n(def (walk-directory dir proc)\n  \"Call (proc full-path) for every file under dir recursively.\"\n  (for-each\n    (lambda (name)\n      (unless (member name '(\".\" \"..\"))\n        (let ((full (string-append dir \"/\" name)))\n          (if (eq? (file-info-type (file-info full)) 'directory)\n            (walk-directory full proc)\n            (proc full)))))\n    (directory-files dir)))",
    "notes": "directory-files accepts either a string path or a settings list with path: and ignore-hidden: keywords. The ignore-hidden: option values are: #f (show all), 'dot-and-dot-dot (hide . and ..), or #t (hide all dotfiles). file-info follows symlinks by default; use (file-info path #f) to not follow symlinks (lstat behavior). file-info-mode returns an integer — use bitwise operations to check permissions (e.g., (bitwise-and mode #o100) for owner-execute). These are all Gambit builtins, no imports needed.",
    "related": [
      "gambit-path-builtins",
      "read-file-to-string"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "user-info-environment-introspection",
    "title": "Get user info, hostname, pid, and environment variables (Gambit builtins)",
    "tags": [
      "user",
      "hostname",
      "pid",
      "environment",
      "getenv",
      "setenv",
      "introspection"
    ],
    "imports": [
      ":std/os/hostname",
      ":std/os/pid"
    ],
    "code": ";; Most of these are Gambit builtins (no import needed)\n;; hostname and getpid need :std/os/hostname and :std/os/pid\n\n(import :std/os/hostname :std/os/pid)\n\n;; --- Environment variables ---\n(getenv \"HOME\" #f)               ;; => \"/home/user\" or #f if unset\n(getenv \"PATH\" \"\")               ;; second arg is default\n(setenv \"MY_VAR\" \"my_value\")     ;; set env var\n(get-environment-variables)      ;; => alist of ALL env vars: ((\"HOME\" . \"/home/user\") ...)\n\n;; --- User info ---\n(user-name)                      ;; => \"jafourni\" (current user)\n(let ((ui (user-info (user-name))))\n  (list\n    (user-info-name ui)          ;; => \"jafourni\"\n    (user-info-uid ui)           ;; => 1000\n    (user-info-gid ui)           ;; => 1000\n    (user-info-home ui)          ;; => \"/home/jafourni\"\n    (user-info-shell ui)))       ;; => \"/bin/bash\"\n\n;; user-info also accepts a uid integer:\n(user-info 0)                    ;; => root's user-info\n\n;; --- System info ---\n(hostname)                       ;; => \"myhost\" (needs :std/os/hostname)\n(getpid)                         ;; => 12345 (needs :std/os/pid)\n(getppid)                        ;; => 12344 (parent pid, needs :std/os/pid)\n\n;; --- Working directory ---\n(current-directory)              ;; => \"/home/user/project/\"\n(current-directory \"/tmp\")       ;; change directory (set!)\n\n;; --- TTY detection ---\n(tty? (current-input-port))      ;; => #t if interactive, #f if piped/redirected",
    "notes": "getenv, setenv, user-name, user-info, current-directory, and tty? are Gambit builtins — no import needed. hostname needs :std/os/hostname, getpid/getppid need :std/os/pid. getenv with 2 args returns the default (not an error) if the variable is unset. user-info accepts either a username string or a uid integer. current-directory with one argument changes the cwd (like cd). tty? returns #t only for actual terminal ports (not when stdin is piped or redirected).",
    "related": [
      "gambit-path-builtins",
      "run-subprocess-custom-env"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "process-status-decode-waitpid",
    "title": "Decode raw waitpid status from process-status",
    "tags": [
      "process",
      "status",
      "waitpid",
      "exit",
      "signal",
      "decode",
      "WEXITSTATUS",
      "WTERMSIG"
    ],
    "imports": [],
    "code": ";; process-status returns the RAW waitpid(2) status integer, NOT the exit code.\n;; No imports needed — open-process and process-status are Gambit builtins.\n;;\n;; Encoding (same as POSIX waitpid):\n;;   Normal exit:  status = exit_code << 8    (exit 0 → 0, exit 1 → 256, exit 42 → 10752)\n;;   Killed by signal: status = signal_number (kill -9 → 9, kill -15 → 15)\n;;   Stopped:      status = (signal << 8) | 0x7f  (but Gambit's SIGCHLD handler ignores these)\n\n;; Decoding helpers (matching POSIX W* macros):\n(def (WIFEXITED status)    (= (bitwise-and status #x7f) 0))\n(def (WEXITSTATUS status)  (arithmetic-shift (bitwise-and status #xff00) -8))\n(def (WIFSIGNALED status)  (and (not (= (bitwise-and status #x7f) 0))\n                                (not (= (bitwise-and status #x7f) #x7f))))\n(def (WTERMSIG status)     (bitwise-and status #x7f))\n(def (WIFSTOPPED status)   (= (bitwise-and status #xff) #x7f))\n(def (WSTOPSIG status)     (arithmetic-shift (bitwise-and status #xff00) -8))\n\n;; Get a clean exit code (0-255) from raw status:\n(def (exit-status->code raw-status)\n  (cond\n    ((WIFEXITED raw-status) (WEXITSTATUS raw-status))\n    ((WIFSIGNALED raw-status) (+ 128 (WTERMSIG raw-status)))  ;; shell convention\n    (else 255)))  ;; unknown\n\n;; Examples:\n(let* ((proc (open-process (list path: \"/bin/sh\" arguments: '(\"-c\" \"exit 42\"))))\n       (status (process-status proc)))\n  (list 'raw: status 'exit-code: (exit-status->code status)))\n;; => (raw: 10752 exit-code: 42)\n\n(let* ((proc (open-process (list path: \"/bin/sh\" arguments: '(\"-c\" \"exit 0\"))))\n       (status (process-status proc)))\n  (list 'raw: status 'exit-code: (exit-status->code status)))\n;; => (raw: 0 exit-code: 0)\n\n;; Killed by signal (128 + signal_number is shell convention):\n;; exit-status->code for kill -9 → 137 (128 + 9)",
    "notes": "CRITICAL for shell implementation: process-status does NOT return the exit code directly. exit 1 returns 256, exit 42 returns 10752, kill -9 returns 9. You MUST use bitwise decoding (WEXITSTATUS, WTERMSIG) to get the actual exit code. The shell convention is to report 128+signal for signal-killed processes. Gambit's internal SIGCHLD handler only handles WIFEXITED and WIFSIGNALED — it ignores WIFSTOPPED, so stopped processes (Ctrl+Z) won't be detected without FFI waitpid with WUNTRACED.",
    "related": [
      "open-process-stdin-write-read",
      "os-pipe-create-fd-pair"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "tty-mode-set-raw-cooked",
    "title": "Set terminal raw/cooked mode with tty-mode-set! (no stty needed)",
    "tags": [
      "tty",
      "terminal",
      "raw",
      "cooked",
      "mode",
      "tty-mode-set!",
      "line-editor",
      "termios"
    ],
    "imports": [],
    "code": ";; tty-mode-set! is a Gambit builtin — no imports needed.\n;; It controls terminal I/O mode without shelling out to stty.\n;;\n;; Signature: (tty-mode-set! port input-allow-special input-echo output-raw input-raw)\n;;   input-allow-special: #t = handle Ctrl-C/Z etc. (ISIG); #f = pass through as bytes\n;;   input-echo: #t = echo typed chars; #f = no echo\n;;   output-raw: #t = no output processing; #f = normal (e.g. LF→CRLF)\n;;   input-raw:  #t = raw byte-at-a-time (no line editing, VMIN=1); #f = canonical (line mode)\n\n;; Save current mode (returns: input-allow-special input-echo output-raw input-raw)\n;; There's no built-in to query mode, so save before changing.\n\n;; Set raw mode for a line editor (most common for shell):\n;; - No echo (we draw the line ourselves)\n;; - No canonical mode (read byte-by-byte)\n;; - Allow special signals (Ctrl-C sends SIGINT)\n;; - Normal output processing (LF→CRLF)\n(tty-mode-set! (current-input-port)\n  #t   ;; input-allow-special = #t (let Ctrl-C work)\n  #f   ;; input-echo = #f (we handle display)\n  #f   ;; output-raw = #f (normal output)\n  #t)  ;; input-raw = #t (byte-at-a-time)\n\n;; Fully raw mode (for things like ssh/screen passthrough):\n(tty-mode-set! (current-input-port)\n  #f   ;; no signal processing\n  #f   ;; no echo\n  #t   ;; raw output\n  #t)  ;; raw input\n\n;; Restore cooked/canonical mode:\n(tty-mode-set! (current-input-port)\n  #t   ;; allow specials\n  #t   ;; echo on\n  #f   ;; normal output\n  #f)  ;; canonical input (line-buffered)\n\n;; Safe pattern with cleanup:\n(def (with-raw-terminal thunk)\n  (let ((port (current-input-port)))\n    (dynamic-wind\n      (lambda () (tty-mode-set! port #t #f #f #t))  ;; enter raw\n      thunk\n      (lambda () (tty-mode-set! port #t #t #f #f))))) ;; restore cooked\n\n;; Read single keystrokes in raw mode:\n(with-raw-terminal\n  (lambda ()\n    (let loop ()\n      (let ((ch (read-char)))\n        (unless (eqv? ch #\\x3)  ;; Ctrl-C\n          (display (format \"key: ~a (~a)\\n\" ch (char->integer ch)))\n          (force-output)\n          (loop))))))",
    "notes": "tty-mode-set! is a native Gambit function that does termios manipulation in C (sets ICANON, ECHO, ISIG, VMIN=1, VTIME=0 etc). It is MORE RELIABLE than shelling out to stty because it doesn't require a subprocess. Internally it calls tcgetattr/tcsetattr. For a shell's line editor, the typical mode is: allow-special=#t, echo=#f, output-raw=#f, input-raw=#t. This gives byte-at-a-time input without echo, while still allowing Ctrl-C to generate SIGINT. Gambit also provides tty-type-set! for setting TERM type and tty-history/tty-history-set! for Gambit's built-in line editor history.",
    "related": [
      "process-status-decode-waitpid",
      "os-pipe-create-fd-pair"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "patchelf-openssl-rpath",
    "title": "Fix OpenSSL version mismatch in compiled Gerbil executables with patchelf",
    "tags": [
      "patchelf",
      "openssl",
      "rpath",
      "linker",
      "executable",
      "build",
      "libcrypto",
      "ssl",
      "makefile"
    ],
    "imports": [],
    "code": ";; PROBLEM: Compiled Gerbil executable fails at runtime with:\n;;   gerbil-aws: /lib/x86_64-linux-gnu/libcrypto.so.3: version `OPENSSL_3.4.0' not found\n;;\n;; ROOT CAUSE: The executable was compiled against Gerbil's bundled OpenSSL\n;; (e.g. from Homebrew/Linuxbrew) but at runtime finds the system's older\n;; libcrypto.so.3 which lacks the required version symbols.\n;;\n;; FIX: Use patchelf to set the RPATH to point to the correct OpenSSL:\n;;\n;;   # Find where Gerbil's OpenSSL lives (commonly Linuxbrew):\n;;   OPENSSL_RPATH=/home/linuxbrew/.linuxbrew/opt/openssl@3/lib\n;;\n;;   # Patch the compiled binary after gerbil build:\n;;   patchelf --set-rpath $OPENSSL_RPATH .gerbil/bin/my-app\n;;\n;; MAKEFILE PATTERN (recommended):\n;;\n;; OPENSSL_RPATH = /home/linuxbrew/.linuxbrew/opt/openssl@3/lib\n;; BINARY = .gerbil/bin/my-app\n;;\n;; build:\n;; \tgerbil build\n;; \tpatchelf --set-rpath $(OPENSSL_RPATH) $(BINARY)\n;;\n;; install: build\n;; \tsudo cp $(BINARY) /usr/local/bin\n;;\n;; IMPORTANT: The install target must depend on build so the patchelf\n;; step runs before copying. Running `gerbil build` alone (e.g. via\n;; gerbil_build_and_report) does NOT patch the binary — always use\n;; `make build` or `make install` for the complete workflow.\n;;\n;; DIAGNOSIS: Check what RPATH the binary has:\n;;   patchelf --print-rpath .gerbil/bin/my-app\n;;   ldd .gerbil/bin/my-app | grep ssl\n;;\n;; On macOS, use install_name_tool instead of patchelf.",
    "notes": "This issue affects any Gerbil project that compiles executables using modules with OpenSSL dependencies (e.g. :std/net/request, :std/crypto, :std/net/ssl, :std/net/websocket). The system OpenSSL and Gerbil's build-time OpenSSL must match, or the RPATH must be patched. Install patchelf via: apt install patchelf (Debian/Ubuntu) or brew install patchelf.",
    "related": [
      "static-exe-with-deps",
      "stale-global-static-segfault"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "atom-atomic-reference",
    "title": "Clojure-style atomic reference with swap, CAS, and watches",
    "tags": [
      "atom",
      "atomic",
      "concurrency",
      "swap",
      "cas",
      "compare-and-set",
      "watch",
      "thread-safe",
      "mutable",
      "state"
    ],
    "imports": [
      ":std/misc/atom"
    ],
    "code": "(import :std/misc/atom)\n\n;; Create an atom with optional validator\n(def counter (atom 0))\n(def positive-counter (atom 1 validator: (lambda (x) (and (fixnum? x) (fx>= x 0)))))\n\n;; Read the current value\n(atom-deref counter)  ;; => 0\n\n;; Reset to a new value (like assignment)\n(atom-reset! counter 42)\n\n;; Swap: apply a function to the current value atomically\n(atom-swap! counter 1+)          ;; => 43\n(atom-swap! counter + 10)        ;; => 53 (extra args passed to fn)\n\n;; Compare-and-set (CAS): only update if current value matches expected\n(atom-compare-and-set! counter 53 100)  ;; => #t (was 53, now 100)\n(atom-compare-and-set! counter 53 200)  ;; => #f (not 53 anymore)\n\n;; Get both old and new values from a swap\n(defvalues (old new) (atom-swap-values! counter 1+))\n\n;; Convenience: atomic increment\n(atom-increment! counter)     ;; +1\n(atom-increment! counter 5)   ;; +5\n\n;; Atomic counter factory (returns a closure)\n(def next-id (atomic-counter))\n(next-id)  ;; => 0\n(next-id)  ;; => 1\n(next-id)  ;; => 2\n\n;; Add a watch function: called on every change\n;; watch-fn receives (key atom old-value new-value)\n(atom-add-watch! counter 'logger\n  (lambda (key a old new)\n    (displayln \"counter changed: \" old \" -> \" new)))\n(atom-swap! counter 1+)  ;; prints: counter changed: 106 -> 107\n\n;; Remove watch\n(atom-remove-watch! counter 'logger)",
    "notes": "Atoms are thread-safe mutable references. Validators run inside the lock — if a validator raises an exception, the swap is aborted. The swap function may be called multiple times if there's contention (like Clojure atoms). Use atom-compare-and-set! for explicit CAS patterns. atomic-counter returns a zero-allocation incrementing closure, ideal for generating unique IDs.",
    "related": [
      "channel-based-communication",
      "spawn-thread"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "list-builder-efficient-append",
    "title": "Efficient O(1) list building with with-list-builder",
    "tags": [
      "list",
      "builder",
      "accumulate",
      "append",
      "efficient",
      "performance",
      "collect",
      "push"
    ],
    "imports": [
      ":std/misc/list-builder"
    ],
    "code": "(import :std/misc/list-builder)\n\n;; with-list-builder provides O(1) append to a growing list\n;; Avoids O(n^2) from repeated (append lst (list new-item))\n(with-list-builder (push! peek)\n  (push! 'a)\n  (push! 'b)\n  (push! 'c)\n  (peek))  ;; => (a b c)\n\n;; Functional form:\n(call-with-list-builder\n  (lambda (push! peek)\n    (for (x (in-range 5))\n      (when (odd? x)\n        (push! x)))\n    (peek)))  ;; => (1 3)\n\n;; Common pattern: conditional collection\n(def (find-matching items pred)\n  (with-list-builder (collect)\n    (for-each (lambda (item)\n                (when (pred item)\n                  (collect item)))\n              items)))\n\n;; Nested collection with intermediate results\n(with-list-builder (push! peek)\n  (push! 'start)\n  (for (x '(1 2 3))\n    (push! (* x 10)))\n  (push! 'end)\n  (peek))  ;; => (start 10 20 30 end)",
    "notes": "with-list-builder uses cons cell mutation internally: a sentinel cons cell [#f] is created, and push! mutates the cdr to append in O(1). This prevents the O(n^2) quadratic append pattern. Always prefer this over (set! result (append result (list item))). The peek function returns the current list without consuming it. push! always appends to the end (maintains insertion order).",
    "related": [
      "collect-results-with-for-collect"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "lru-cache-bounded",
    "title": "LRU cache with bounded size and automatic eviction",
    "tags": [
      "lru",
      "cache",
      "bounded",
      "eviction",
      "memoize",
      "capacity",
      "hash",
      "performance"
    ],
    "imports": [
      ":std/misc/lru"
    ],
    "code": "(import :std/misc/lru)\n\n;; Create a bounded LRU cache\n(def cache (make-lru-cache 100))  ;; capacity 100\n\n;; Put and get values\n(lru-cache-put! cache \"key1\" \"value1\")\n(lru-cache-put! cache \"key2\" \"value2\")\n\n(lru-cache-ref cache \"key1\")          ;; => \"value1\" (marks as recently used)\n(lru-cache-get cache \"key1\")          ;; => \"value1\" (same, alias)\n(lru-cache-get cache \"missing\")       ;; => #f (not found)\n(lru-cache-ref cache \"missing\" 'default) ;; => default\n\n;; Check membership\n(lru-cache-key? cache \"key1\")         ;; => #t\n\n;; Remove\n(lru-cache-remove! cache \"key1\")\n\n;; Iterate (newest to oldest)\n(lru-cache-for-each\n  (lambda (k v) (displayln k \": \" v))\n  cache)\n\n;; Fold (oldest to newest)\n(lru-cache-fold\n  (lambda (k v acc) (cons (cons k v) acc))\n  '() cache)\n\n;; Fold right (newest to oldest)\n(lru-cache-foldr\n  (lambda (k v acc) (cons (cons k v) acc))\n  '() cache)\n\n;; Flush all entries\n(lru-cache-flush! cache)\n\n;; LRU caches are iterable with for\n(import :std/iter)\n(for ((k v) (in-lru-cache cache))\n  (displayln k \" => \" v))\n\n;; Memoization pattern with LRU\n(def expensive-cache (make-lru-cache 1000))\n(def (cached-compute key)\n  (or (lru-cache-get expensive-cache key)\n      (let (result (expensive-operation key))\n        (lru-cache-put! expensive-cache key result)\n        result)))",
    "notes": "LRU cache uses a hash table + doubly-linked list internally. Access (ref/get) promotes the entry to most-recently-used. When capacity is exceeded on put!, the least-recently-used entry is evicted. O(1) for all operations. The cache is NOT thread-safe — wrap with a mutex for concurrent access. Iteration via in-lru-cache yields (key . value) pairs from most-recent to least-recent.",
    "related": [
      "hash-table-basics"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "rbtree-sorted-map",
    "title": "Red-black tree for sorted key-value storage",
    "tags": [
      "rbtree",
      "red-black",
      "tree",
      "sorted",
      "map",
      "ordered",
      "comparator",
      "balanced"
    ],
    "imports": [
      ":std/misc/rbtree"
    ],
    "code": "(import :std/misc/rbtree)\n\n;; Create with a comparator function (must return <0, 0, or >0)\n(def t (rbtree string-cmp))       ;; string keys\n(def t2 (rbtree symbol-cmp))      ;; symbol keys\n\n;; Insert / update\n(rbtree-put! t \"banana\" 2)\n(rbtree-put! t \"apple\" 5)\n(rbtree-put! t \"cherry\" 1)\n\n;; Lookup\n(rbtree-ref t \"apple\")             ;; => 5 (error if missing)\n(rbtree-ref t \"missing\" 'default)  ;; => default\n(rbtree-get t \"apple\")             ;; => 5 (#f if missing)\n(rbtree-key? t \"apple\")            ;; => #t\n\n;; Remove\n(rbtree-remove! t \"banana\")\n\n;; In-order traversal (sorted by key)\n(rbtree-for-each\n  (lambda (k v) (displayln k \": \" v))\n  t)\n;; prints: apple: 5, cherry: 1 (alphabetical order)\n\n;; Fold\n(rbtree-fold\n  (lambda (k v acc) (+ acc v))\n  0 t)  ;; => 6\n\n;; Convert to/from alist\n(rbtree->list t)                   ;; => ((\"apple\" . 5) (\"cherry\" . 1))\n(def t3 (list->rbtree string-cmp '((\"x\" . 1) (\"y\" . 2))))\n\n;; Iterate with for\n(import :std/iter)\n(for ((k v) (in-rbtree t))\n  (displayln k \" => \" v))\n(for (k (in-rbtree-keys t))\n  (displayln k))\n(for (v (in-rbtree-values t))\n  (displayln v))\n\n;; Custom comparator for numeric keys\n(def num-tree (rbtree (lambda (a b) (- a b))))\n(rbtree-put! num-tree 42 \"answer\")\n(rbtree-put! num-tree 1 \"first\")",
    "notes": "Red-black trees maintain sorted order by key. All operations are O(log n). The comparator function must return a negative number if a < b, zero if a = b, and positive if a > b. Pre-built comparators: string-cmp, symbol-cmp, symbol-hash-cmp. For numeric keys, use (lambda (a b) (- a b)). Trees are iterable via in-rbtree, in-rbtree-keys, in-rbtree-values.",
    "related": [
      "hash-table-basics"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "priority-queue-heap",
    "title": "Priority queue (min/max heap) for ordered processing",
    "tags": [
      "priority",
      "queue",
      "heap",
      "pqueue",
      "min-heap",
      "max-heap",
      "scheduling",
      "sorted"
    ],
    "imports": [
      ":std/misc/pqueue"
    ],
    "code": "(import :std/misc/pqueue)\n\n;; Create a min-heap (lowest priority value comes out first)\n(def pq (make-pqueue car <))  ;; priority extracted by car, compared with <\n\n;; Push items (each item has a priority component)\n(pqueue-push! pq '(3 \"low-priority\"))\n(pqueue-push! pq '(1 \"high-priority\"))\n(pqueue-push! pq '(2 \"medium-priority\"))\n\n;; Pop returns the highest-priority item (lowest number for <)\n(pqueue-pop! pq)    ;; => (1 \"high-priority\")\n(pqueue-pop! pq)    ;; => (2 \"medium-priority\")\n(pqueue-pop! pq)    ;; => (3 \"low-priority\")\n(pqueue-pop! pq 'empty)  ;; => empty (default when empty)\n\n;; Peek without removing\n(pqueue-push! pq '(5 \"item\"))\n(pqueue-peek pq)    ;; => (5 \"item\")\n\n;; Check size and emptiness\n(pqueue-empty? pq)  ;; => #f\n(pqueue-size pq)    ;; => 1\n\n;; Get all contents (unordered)\n(pqueue-contents pq)\n\n;; Max-heap example (highest number first)\n(def max-pq (make-pqueue identity >))\n(pqueue-push! max-pq 10)\n(pqueue-push! max-pq 30)\n(pqueue-push! max-pq 20)\n(pqueue-pop! max-pq)   ;; => 30\n\n;; Task scheduling pattern\n(defstruct task (priority name) transparent: #t)\n(def scheduler (make-pqueue task-priority <))\n(pqueue-push! scheduler (make-task 1 \"critical\"))\n(pqueue-push! scheduler (make-task 5 \"background\"))\n(pqueue-push! scheduler (make-task 2 \"important\"))\n(task-name (pqueue-pop! scheduler))  ;; => \"critical\"",
    "notes": "make-pqueue takes a priority-extraction function and a comparator. The extraction function maps items to their priority values, and the comparator determines ordering (< for min-heap, > for max-heap). Uses a binary heap internally with 1-based vector indexing. Auto-resizes when full. O(log n) push and pop. pqueue-contents returns items in no particular order.",
    "related": [
      "rbtree-sorted-map"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "workgroup-thread-pool",
    "title": "Workgroup (thread pool) for parallel task execution",
    "tags": [
      "workgroup",
      "wg",
      "thread-pool",
      "parallel",
      "concurrent",
      "spawn",
      "worker",
      "fan-out"
    ],
    "imports": [
      ":std/misc/wg"
    ],
    "code": "(import :std/misc/wg)\n\n;; Create a workgroup with N worker threads\n(def wg (make-wg 4))  ;; 4 workers\n\n;; Add tasks (thunks) to the workgroup\n(for (i (in-range 10))\n  (wg-add! wg (lambda ()\n    (thread-sleep! 0.1)  ;; simulate work\n    (displayln \"task \" i \" done\"))))\n\n;; Wait for ALL tasks to complete\n;; Rethrows any exception from worker threads\n(wg-wait! wg)\n(displayln \"all done\")\n\n;; Pattern: parallel map with shared result collection\n(import :std/misc/atom)\n(def results (atom []))\n(def wg2 (make-wg 8))\n(for (item '(\"a\" \"b\" \"c\" \"d\" \"e\"))\n  (wg-add! wg2 (lambda ()\n    (let (result (string-append item \"-processed\"))\n      (atom-swap! results (lambda (lst) (cons result lst)))))))\n(wg-wait! wg2)\n(displayln (atom-deref results))\n\n;; Error handling: wg-wait! propagates first error\n(def wg3 (make-wg 2))\n(wg-add! wg3 (lambda () (error \"task failed!\")))\n(wg-add! wg3 (lambda () (displayln \"ok\")))\n(with-catch\n  (lambda (e) (displayln \"caught: \" (error-message e)))\n  (lambda () (wg-wait! wg3)))",
    "notes": "Workgroups create N worker threads that pull tasks from an internal channel. Workers run until the channel is closed. wg-wait! closes the channel and joins all workers, rethrowing any exception that occurred. Tasks are thunks (zero-argument procedures). For collecting results, use atoms or a shared channel since tasks run in parallel threads. The workgroup is single-use — after wg-wait!, create a new one for more work.",
    "related": [
      "atom-atomic-reference",
      "channel-based-communication"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "barrier-synchronization",
    "title": "Barrier synchronization for N threads to reach a checkpoint",
    "tags": [
      "barrier",
      "synchronization",
      "threads",
      "checkpoint",
      "wait",
      "concurrency",
      "rendezvous"
    ],
    "imports": [
      ":std/misc/barrier"
    ],
    "code": "(import :std/misc/barrier)\n\n;; Create a barrier for N threads\n(def b (make-barrier 3))\n\n;; Each thread signals when it reaches the checkpoint\n(for (i (in-range 3))\n  (spawn (lambda ()\n    (thread-sleep! (* i 0.1))  ;; simulate varying work\n    (displayln \"thread \" i \" reached barrier\")\n    (barrier-post! b)           ;; signal \"I'm done\"\n    (displayln \"thread \" i \" past barrier\"))))\n\n;; Main thread waits for all 3 to post\n(barrier-wait! b)\n(displayln \"all threads reached the barrier\")\n\n;; Error propagation: if any thread fails, all waiters get the error\n(def b2 (make-barrier 2))\n(spawn (lambda ()\n  (with-barrier-error b2\n    (error \"worker failed!\"))))\n;; barrier-wait! will re-raise the error\n(with-catch\n  (lambda (e) (displayln \"barrier error: \" (error-message e)))\n  (lambda () (barrier-wait! b2)))",
    "notes": "Barriers use a mutex + condition variable internally. barrier-post! increments a counter and broadcasts when it reaches the limit. barrier-wait! blocks until all expected threads have posted. with-barrier-error catches exceptions in the body and propagates them to all waiters via barrier-error!. Once a barrier fires (or errors), it cannot be reused — create a new one.",
    "related": [
      "workgroup-thread-pool",
      "completion-async-value"
    ],
    "gerbil_version": "v0.18.1-173",
    "deprecated": true,
    "superseded_by": "barrier-synchronization-v19"
  },
  {
    "id": "completion-async-value",
    "title": "Completion: one-shot async value/error container",
    "tags": [
      "completion",
      "async",
      "future",
      "promise",
      "one-shot",
      "concurrency",
      "wait",
      "result"
    ],
    "imports": [
      ":std/misc/completion"
    ],
    "code": "(import :std/misc/completion)\n\n;; Create a completion (like a one-shot promise/future)\n(def c (make-completion))\n\n;; Producer thread posts a value or error\n(spawn (lambda ()\n  (thread-sleep! 0.5)  ;; simulate async work\n  (completion-post! c 42)))\n\n;; Consumer blocks until value is available\n(def result (completion-wait! c))  ;; => 42\n\n;; Error propagation\n(def c2 (make-completion))\n(spawn (lambda ()\n  (completion-error! c2 (make-error \"async failure\"))))\n;; completion-wait! will raise the posted error\n(with-catch\n  (lambda (e) (displayln \"got error: \" (error-message e)))\n  (lambda () (completion-wait! c2)))\n\n;; with-completion-error: catch body errors and propagate to completion\n(def c3 (make-completion))\n(spawn (lambda ()\n  (with-completion-error c3\n    (let (result (risky-computation))\n      (completion-post! c3 result)))))\n;; If risky-computation throws, the error is posted to c3\n\n;; Pattern: async operation with timeout\n(def c4 (make-completion))\n(spawn (lambda ()\n  (let (data (fetch-remote-data))\n    (completion-post! c4 data))))\n;; Poll with timeout (using mutex-unlock! internally)\n(completion-wait! c4)  ;; blocks until ready",
    "notes": "Completions are one-shot: once a value or error is posted, it cannot be changed. Attempting to post twice raises an error. Multiple threads can wait on the same completion — all will be woken when the value is posted. completion-wait! returns the posted value or re-raises the posted error. This is simpler than channels for single-result async operations.",
    "related": [
      "barrier-synchronization",
      "channel-based-communication"
    ],
    "gerbil_version": "v0.18.1-173",
    "deprecated": true,
    "superseded_by": "completion-async-value-v19"
  },
  {
    "id": "rwlock-readers-writer",
    "title": "Read-write lock for multiple readers / single writer",
    "tags": [
      "rwlock",
      "read-write",
      "lock",
      "readers",
      "writer",
      "concurrent",
      "shared",
      "exclusive",
      "mutex"
    ],
    "imports": [
      ":std/misc/rwlock"
    ],
    "code": "(import :std/misc/rwlock)\n\n;; Create a read-write lock\n(def rw (make-rwlock))\n\n;; Multiple readers can hold the lock simultaneously\n(def shared-data (make-hash-table))\n\n;; Reader pattern (shared access)\n(def (read-data key)\n  (with-read-lock rw\n    (lambda () (hash-get shared-data key))))\n\n;; Writer pattern (exclusive access)\n(def (write-data key value)\n  (with-write-lock rw\n    (lambda () (hash-put! shared-data key value))))\n\n;; Manual lock/unlock (use with-read-lock/with-write-lock instead)\n;; (rwlock-read-lock! rw)\n;; (rwlock-read-unlock! rw)\n;; (rwlock-write-lock! rw)\n;; (rwlock-write-unlock! rw)\n\n;; Concurrent usage\n(for (i (in-range 10))\n  (spawn (lambda ()\n    (if (zero? (modulo i 3))\n      ;; Writer (every 3rd thread)\n      (write-data (string-append \"key\" (number->string i)) i)\n      ;; Reader\n      (let (v (read-data \"key0\"))\n        (displayln \"reader \" i \" got: \" v))))))",
    "notes": "Read-write locks allow multiple concurrent readers OR a single exclusive writer. with-read-lock and with-write-lock take a thunk (zero-argument lambda) and handle lock/unlock automatically, even on exceptions. Writers queue with a writers-waiting counter. When all readers release, waiting writers are woken. This is NOT a fair lock — readers can starve writers under heavy read load.",
    "related": [
      "atom-atomic-reference"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "chain-advanced-pipeline",
    "title": "Advanced chain pipeline with destructuring and named bindings",
    "tags": [
      "chain",
      "pipeline",
      "compose",
      "sugar",
      "transform",
      "destructure",
      "threading",
      "diamond"
    ],
    "imports": [
      ":std/sugar",
      ":std/iter"
    ],
    "code": "(import :std/sugar :std/iter)\n\n;; Basic chain: <> is the slot for the piped value\n(chain [1 2 3 4 5]\n  (filter odd? <>)\n  (map (cut * <> 10) <>)\n  (apply + <>))\n;; => 90 (1+3+5 = 9, *10 = 90)\n\n;; Unary functions don't need <>\n(chain \"Hello World\"\n  string-downcase\n  (string-split <> \" \")\n  car)\n;; => \"hello\"\n\n;; Destructuring in pipeline stages\n(chain [1 2 3 4 5]\n  ([head . tail] tail)           ;; destructure, keep tail\n  (map (cut + <> 10) <>))\n;; => (12 13 14 15)\n\n;; Named bindings for intermediate values\n(chain [1 2 3]\n  (xs (map number->string xs))   ;; bind as 'xs', use in expression\n  (string-join <> \", \"))\n;; => \"1, 2, 3\"\n\n;; Starting with <> creates a lambda (point-free style)\n(def add-and-sum\n  (chain <>\n    (map (cut + <> 1) <>)\n    (apply + <>)))\n(add-and-sum [1 2 3])  ;; => 9\n\n;; Mixing destructuring + named bindings\n(chain (iota 5)\n  ([_ . rest] rest)              ;; drop first element\n  (xs (map (cut * <> 2) xs))     ;; double remaining\n  (string-join (map number->string <>) \"-\"))\n;; => \"2-4-6-8\"",
    "notes": "chain from :std/sugar is a powerful pipeline macro. Three stage forms: (1) (expr <>): <> is replaced by the pipe value, (2) (name expr): binds pipe value to name for use in expr, (3) ([pat ...] expr): destructures the pipe value. When a stage is just a symbol (like string-downcase), it's treated as a unary function applied to the pipe value. Starting with <> creates a lambda for point-free style.",
    "related": [
      "collect-results-with-for-collect"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "is-predicate-factory",
    "title": "Smart predicate factory with 'is' macro",
    "tags": [
      "is",
      "predicate",
      "filter",
      "find",
      "sugar",
      "accessor",
      "compare",
      "lambda"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": "(import :std/sugar)\n\n;; (is accessor value) creates a predicate: (lambda (x) (equal? (accessor x) value))\n;; Auto-selects comparator based on value type:\n;;   numbers -> =, characters -> eqv?, strings -> string=?, else -> equal?\n\n;; Find by accessor + value\n(find (is car 'target) '((a . 1) (target . 2) (c . 3)))\n;; => (target . 2)\n\n;; Filter by accessor + predicate\n(filter (is cdr positive?) '((a . -1) (b . 5) (c . -2) (d . 3)))\n;; => ((b . 5) (d . 3))\n\n;; Compose accessor + comparison\n(filter (is string-length 3) '(\"hi\" \"foo\" \"x\" \"bar\" \"ab\"))\n;; => (\"foo\" \"bar\")\n\n;; With numeric comparison (uses =)\n(filter (is car 42) '((42 . a) (1 . b) (42 . c)))\n;; => ((42 . a) (42 . c))\n\n;; Accessor + predicate (tests result of accessor)\n(filter (is car symbol?) '((a . 1) (\"b\" . 2) (c . 3)))\n;; => ((a . 1) (c . 3))\n\n;; Identity accessor (is identity value) or just (is value)\n(filter (is identity even?) '(1 2 3 4 5 6))\n;; => (2 4 6)\n\n;; Custom test: keyword\n(find (is car 'x test: eq?) '((a 1) (x 2) (b 3)))\n;; => (x 2)",
    "notes": "The 'is' macro from :std/sugar generates compact predicate closures. When the second argument is a procedure, it's treated as a predicate applied to the accessor result: (is accessor pred?) => (lambda (x) (pred? (accessor x))). When it's a value, it's compared using auto-detected equality. This makes filter/find expressions very concise. Use test: keyword to override the equality comparator.",
    "related": [
      "chain-advanced-pipeline",
      "destructure-hash-tables-with-let-hash"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "custom-iterator-protocol",
    "title": "Implement custom :iter protocol for any type",
    "tags": [
      "iterator",
      "iter",
      "custom",
      "protocol",
      "for",
      "iterable",
      "defmethod",
      "generator",
      "make-iterator"
    ],
    "imports": [
      ":std/iter"
    ],
    "code": "(import :std/iter)\n\n;; To make any type iterable with for/for-collect/for-fold,\n;; implement the :iter method that returns a make-iterator object.\n\n;; Example: make a \"range-set\" iterable\n(defstruct range-set (ranges) transparent: #t)  ;; list of (lo . hi) pairs\n\n(defmethod (:iter (rs range-set))\n  (let (all-ranges (range-set-ranges rs))\n    ;; State: (current-value . remaining-ranges)\n    (def (next it)\n      (using (it :- iterator)\n        (match it.e\n          ([(? (lambda (p) (< (car p) (cdr p)))) . rest]\n           (let* ((current (caar it.e))\n                  (lo (caar it.e))\n                  (hi (cdar it.e)))\n             (if (< lo hi)\n               (begin\n                 (set! (caar it.e) (+ lo 1))\n                 lo)\n               ;; Move to next range\n               (if (pair? rest)\n                 (begin\n                   (set! it.e rest)\n                   (next it))\n                 iter-end))))\n          (_ iter-end))))\n    (if (pair? all-ranges)\n      (make-iterator all-ranges next)\n      (make-iterator '() (lambda (it) iter-end)))))\n\n;; Now it works with all for forms:\n(def rs (make-range-set '((0 . 3) (10 . 12))))\n(for/collect (x rs) x)  ;; => (0 1 2 10 11)\n\n;; Simpler example: iterator from a thunk (generator-style)\n(def (in-producer thunk)\n  (def (next it)\n    (let (v (thunk))\n      (if (eof-object? v) iter-end v)))\n  (make-iterator #f next))\n\n;; Iterator with cleanup (e.g., file handle)\n(def (in-file-lines path)\n  (let (port (open-input-file path))\n    (def (next it)\n      (let (line (read-line port))\n        (if (eof-object? line) iter-end line)))\n    (def (fini it)\n      (close-input-port port))\n    (make-iterator port next fini)))\n\n;; With cleanup, resources are freed even if loop exits early\n(for (line (in-file-lines \"/etc/hostname\"))\n  (displayln line))",
    "notes": "The iterator protocol requires: (1) define a :iter method on your type via defmethod, (2) return a make-iterator with state, next-fn, and optional fini-fn. The next function receives the iterator itself — access state via it.e (using (it :- iterator) for typed access). Return iter-end to signal completion. The fini function is called when iteration completes (even early exit). Register fini with make-will for GC cleanup of abandoned iterators. iter-end is a singleton — use iter-end? to test.",
    "related": [
      "collect-results-with-for-collect",
      "reduce-with-for-fold"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "coroutine-generator-pattern",
    "title": "Coroutine generators with yield for lazy sequences",
    "tags": [
      "coroutine",
      "generator",
      "yield",
      "lazy",
      "sequence",
      "continue",
      "producer",
      "stream"
    ],
    "imports": [
      ":std/coroutine"
    ],
    "code": "(import :std/coroutine)\n\n;; Basic generator with yield\n(def gen (coroutine (lambda ()\n  (yield 1)\n  (yield 2)\n  (yield 3)\n  'done)))\n\n(continue gen)  ;; => 1\n(continue gen)  ;; => 2\n(continue gen)  ;; => 3\n(continue gen)  ;; => done (return value)\n\n;; Generator with arguments\n(def (fibonacci)\n  (let loop ((a 0) (b 1))\n    (yield a)\n    (loop b (+ a b))))\n\n(def fib (coroutine fibonacci))\n(continue fib)  ;; => 0\n(continue fib)  ;; => 1\n(continue fib)  ;; => 1\n(continue fib)  ;; => 2\n(continue fib)  ;; => 3\n\n;; Iterate a coroutine with for (via :iter protocol)\n(import :std/iter)\n(def (range-gen start end)\n  (let loop ((i start))\n    (when (< i end)\n      (yield i)\n      (loop (+ i 1)))))\n\n(for/collect (x (in-coroutine range-gen 0 5))\n  (* x x))\n;; => (0 1 4 9 16)\n\n;; Cothread: thread-safe coroutine (heavier but concurrent)\n(def ct (cothread (lambda ()\n  (yield \"from thread 1\")\n  (yield \"from thread 2\"))))\n(continue ct)  ;; => \"from thread 1\"\n(cothread-stop! ct)  ;; clean shutdown\n\n;; Two-way communication: continue can pass values back to yield\n(def echo (coroutine (lambda ()\n  (let loop ()\n    (let (msg (yield 'ready))\n      (yield (string-append \"echo: \" msg))\n      (loop))))))\n(continue echo)           ;; => ready\n(continue echo \"hello\")   ;; => echo: hello\n(continue echo \"world\")   ;; => ready (next yield)\n(continue echo \"!\")        ;; => echo: !",
    "notes": "Coroutines are lightweight (single-threaded, continuation-based). yield suspends execution and returns a value to the caller. continue resumes the coroutine and optionally passes a value back into yield. Coroutines are NOT thread-safe — use cothreads for cross-thread generators. in-coroutine wraps a procedure into an iterator that terminates when the procedure returns. The return value of the procedure becomes the final iter-end signal.",
    "related": [
      "custom-iterator-protocol",
      "channel-based-communication"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "event-sync-select",
    "title": "Event system: sync and select for waiting on multiple sources",
    "tags": [
      "event",
      "sync",
      "select",
      "wait",
      "timeout",
      "concurrency",
      "multiplex",
      "condition-variable"
    ],
    "imports": [
      ":std/event"
    ],
    "code": "(import :std/event)\n\n;; wait: block on a single selector with optional timeout (seconds)\n(def t (spawn (lambda () (thread-sleep! 1) 'done)))\n(wait t 2)       ;; => t (thread completed within 2 seconds)\n\n;; select: race multiple selectors, return first ready\n(def t1 (spawn (lambda () (thread-sleep! 0.1) 'fast)))\n(def t2 (spawn (lambda () (thread-sleep! 1.0) 'slow)))\n(select [t1 t2] 2)  ;; => t1 (ready first)\n\n;; Wait on a condition variable (mutex+condvar pair)\n(def mx (make-mutex))\n(def cv (make-condition-variable))\n(spawn (lambda ()\n  (thread-sleep! 0.5)\n  (mutex-lock! mx)\n  (condition-variable-signal! cv)\n  (mutex-unlock! mx)))\n(mutex-lock! mx)\n(wait (cons mx cv) 2)  ;; blocks until signaled\n\n;; High-level events with handlers\n;; handle-evt: attach a handler to an event\n(sync (handle-evt always-evt (lambda (_) 'immediate)))  ;; => immediate\n\n;; choice-evt: first-ready-wins among multiple events\n(def result\n  (sync (choice-evt\n          (handle-evt (wrap-evt t1) (lambda (_) 'thread-done))\n          (handle-evt 2 (lambda (_) 'timeout)))))\n\n;; Timeout as event (number = seconds until ready)\n(sync (handle-evt 0.5 (lambda (_) 'timed-out)))  ;; => timed-out after 0.5s\n\n;; never-evt: never fires (useful as default in choice-evt)\n(sync never-evt 0)  ;; => #f (immediate timeout)\n\n;; Pattern: multiplexed I/O + timeout\n(def (read-with-timeout port seconds)\n  (let (ready (sync (choice-evt\n                      (wrap-evt port)\n                      (handle-evt seconds (lambda (_) #f)))))\n    (if ready\n      (read-line port)\n      'timeout)))",
    "notes": "The event system unifies threads, condition variables, and I/O readiness under one API. wait/select are low-level selectors. sync works with high-level events (wrap-evt, handle-evt, choice-evt). Selectors: threads (ready when terminated), (cons mutex condvar) pairs, I/O ports. Events: always-evt, never-evt, time values (seconds), wrap-evt (raw selector -> event), handle-evt (event + handler fn), choice-evt (OR of events). sync spawns internal threads to race selectors and cleans up after first fires.",
    "related": [
      "channel-based-communication",
      "barrier-synchronization"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "syntax-eval-compile-time",
    "title": "Compile-time computation with syntax-eval",
    "tags": [
      "syntax-eval",
      "macro",
      "compile-time",
      "precompute",
      "constant",
      "sugar"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": "(import :std/sugar)\n\n;; syntax-eval evaluates an expression at compile time (macro expansion)\n;; and embeds the result as a literal in the compiled code.\n\n;; Precompute a lookup table at compile time\n(def powers-of-2\n  (syntax-eval\n    (list->vector (map (lambda (i) (expt 2 i)) (iota 16)))))\n;; At runtime, powers-of-2 is just a constant vector:\n;; #(1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768)\n(vector-ref powers-of-2 10)  ;; => 1024 (instant, no computation)\n\n;; Precompute a string table\n(def hex-chars\n  (syntax-eval\n    (list->vector\n      (map (lambda (i)\n             (string (string-ref \"0123456789abcdef\" i)))\n           (iota 16)))))\n\n;; syntax-call: call a function with the syntax context\n;; Useful for accessing source location info at compile time\n;; (syntax-call (lambda (stx)\n;;   (let ((src (stx-source stx)))\n;;     (if src (source-location->string src) \"unknown\"))))\n\n;; Pattern: embed file contents at compile time\n;; (def sql-schema\n;;   (syntax-eval\n;;     (call-with-input-file \"schema.sql\"\n;;       (lambda (p) (read-line p #f)))))\n\n;; Pattern: build dispatch table at compile time\n(def char-type-table\n  (syntax-eval\n    (let ((v (make-vector 128 'other)))\n      (for-each (lambda (c) (vector-set! v (char->integer c) 'digit))\n                (string->list \"0123456789\"))\n      (for-each (lambda (c) (vector-set! v (char->integer c) 'alpha))\n                (string->list \"abcdefghijklmnopqrstuvwxyz\"))\n      (vector-set! v (char->integer #\\space) 'space)\n      (vector-set! v (char->integer #\\newline) 'space)\n      v)))",
    "notes": "syntax-eval from :std/sugar evaluates an expression during macro expansion (compile time) and embeds the result as a literal constant. The expression must evaluate to a value that can be serialized as a datum (numbers, strings, vectors, lists, booleans). Use for lookup tables, precomputed data, and constants that are expensive to compute at runtime. The expression runs in the expander's environment — it can use standard Scheme functions but NOT runtime-only bindings. syntax-call is similar but receives the syntax object as an argument, allowing access to source location metadata.",
    "related": [
      "with-id-identifier-generation"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "with-destroy-raii",
    "title": "RAII resource cleanup with with-destroy",
    "tags": [
      "with-destroy",
      "destroy",
      "raii",
      "cleanup",
      "resource",
      "finally",
      "unwind",
      "close"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": "(import :std/sugar)\n\n;; with-destroy ensures {destroy obj} is called on exit, even on exception\n;; The object must have a 'destroy' method\n\n(defclass connection (handle)\n  constructor: :init!)\n\n(defmethod {:init! connection}\n  (lambda (self handle:)\n    (set! self.handle handle)\n    (displayln \"opened connection \" handle)))\n\n(defmethod {destroy connection}\n  (lambda (self)\n    (displayln \"closing connection \" self.handle)\n    (set! self.handle #f)))\n\n;; Usage: guaranteed cleanup\n(def conn (make-connection handle: 42))\n(with-destroy conn\n  (displayln \"using connection \" conn.handle)\n  ;; even if this throws, destroy is called\n  (do-something-with conn))\n\n;; Multiple resources (nested)\n(with-destroy (make-connection handle: 1)\n  (lambda (c1)\n    (with-destroy (make-connection handle: 2)\n      (lambda (c2)\n        (use-both c1 c2)))))\n\n;; Equivalent to:\n;; (try (use resource) (finally {destroy resource}))",
    "notes": "with-destroy is from :std/sugar. It calls {destroy obj} in a finally clause. The object must implement a destroy method. This is Gerbil's equivalent of Python's context managers or C++ RAII. Common uses: database connections, file handles, network sockets, FFI resources. The destroy method should be idempotent (safe to call multiple times).",
    "related": [
      "completion-async-value"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "function-composition-combinators",
    "title": "Function composition and predicate combinators",
    "tags": [
      "compose",
      "rcompose",
      "every-of",
      "any-of",
      "predicate",
      "combinator",
      "func",
      "higher-order"
    ],
    "imports": [
      ":std/misc/func"
    ],
    "code": "(import :std/misc/func)\n\n;; compose1: right-to-left composition (single-value)\n(def add1-then-double (compose1 (cut * <> 2) 1+))\n(add1-then-double 3)  ;; => 8 ((3+1)*2)\n\n;; rcompose1: left-to-right composition (more readable)\n(def inc-double (rcompose1 1+ (cut * <> 2)))\n(inc-double 3)  ;; => 8\n\n;; compose/values: threads multiple return values\n(def (swap-and-add a b) (values b (+ a b)))\n(def transform (compose/values swap-and-add values))\n\n;; @compose1: macro version (no closure allocation, inlined)\n(def fast-fn (@compose1 string->number 1+ number->string))\n\n;; every-of: all predicates must match (AND combinator)\n(def valid-age? (every-of number? positive? (cut < <> 150)))\n(valid-age? 25)    ;; => #t\n(valid-age? -5)    ;; => #f\n(valid-age? \"hi\")  ;; => #f\n\n;; any-of: at least one predicate must match (OR combinator)\n(def number-like? (any-of number? string->number))\n(number-like? 42)    ;; => #t\n(number-like? \"42\")  ;; => 42 (truthy)\n(number-like? \"hi\")  ;; => #f\n\n;; pred-limit: predicate that matches only N times\n(def first-3-evens (pred-limit even? 3))\n(filter first-3-evens '(1 2 3 4 5 6 7 8 9 10))\n;; => (2 4 6)  -- only first 3 matches\n\n;; pred-sequence: match elements in order\n(def match-seq (pred-sequence '(1 2 3)))\n(match-seq 1)  ;; => #t\n(match-seq 2)  ;; => #t\n(match-seq 2)  ;; => #f (expected 3)\n\n;; repeat: apply function N times\n(repeat string-upcase 1 \"hello\")  ;; => \"HELLO\"",
    "notes": ":std/misc/func provides function composition and predicate combinators. compose1/rcompose1 are for single-value functions. compose/rcompose handle multi-value (values) returns. @compose1/@rcompose1 are macro versions that inline the composition — no closure allocated, better for hot paths. every-of/any-of create compound predicates from lists. pred-limit creates stateful predicates that only match a fixed number of times. pred-sequence matches elements in a specific order across calls.",
    "related": [
      "is-predicate-factory",
      "chain-advanced-pipeline"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "lazy-evaluation-delay-force",
    "title": "Lazy evaluation with lazy, force, and delay",
    "tags": [
      "lazy",
      "delay",
      "force",
      "thunk",
      "memoize",
      "deferred",
      "evaluation"
    ],
    "imports": [
      ":std/lazy"
    ],
    "code": "(import :std/lazy)\n\n;; lazy: wrap an expression for deferred evaluation\n(def expensive (lazy (begin (displayln \"computing...\") (* 6 7))))\n\n;; force: evaluate the lazy value (computed only once, then cached)\n(force expensive)  ;; prints \"computing...\" => 42\n(force expensive)  ;; => 42 (no print, cached)\n\n;; delay: alternative form (equivalent to lazy for simple cases)\n(def later (delay (+ 1 2)))\n(force later)  ;; => 3\n\n;; Lazy lists (recursive lazy evaluation)\n(def (lazy-range n)\n  (if (> n 0)\n    (lazy (cons n (lazy-range (- n 1))))\n    (lazy '())))\n\n(def r (lazy-range 5))\n(car (force r))           ;; => 5\n(car (force (cdr (force r)))) ;; => 4\n\n;; Pattern: lazy configuration loading\n(def config\n  (lazy (call-with-input-file \"config.json\" read-json)))\n\n;; Config is only loaded when first accessed\n(def (get-config key)\n  (hash-ref (force config) key))\n\n;; Pattern: memoized expensive computation\n(def (make-lazy-cache compute-fn)\n  (let (cache (make-hash-table))\n    (lambda (key)\n      (unless (hash-key? cache key)\n        (hash-put! cache key (lazy (compute-fn key))))\n      (force (hash-ref cache key)))))",
    "notes": ":std/lazy implements R7RS-style lazy evaluation. lazy wraps an expression — it won't be evaluated until force is called. Results are memoized: subsequent force calls return the cached value. The internal representation uses tagged cons cells: (lazy . thunk), (eager . promise), (resolved . value). delay is syntactic sugar for lazy. Cyclic force detection prevents infinite loops. Lazy values are useful for deferred initialization, infinite data structures, and expensive computations that may not be needed.",
    "related": [
      "coroutine-generator-pattern"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "amb-nondeterministic-search",
    "title": "Nondeterministic computation with amb (backtracking search)",
    "tags": [
      "amb",
      "nondeterministic",
      "backtracking",
      "search",
      "constraint",
      "choice",
      "puzzle",
      "solver"
    ],
    "imports": [
      ":std/amb"
    ],
    "code": "(import :std/amb)\n\n;; amb picks one of the choices; backtracks if amb-fail is called\n;; amb-find returns the first solution, amb-collect returns all\n\n;; Basic: find a value satisfying a constraint\n(amb-find\n  (let (x (amb 1 2 3 4 5))\n    (when (even? x) (amb-fail))  ;; reject even numbers\n    x))\n;; => 1 (first odd number)\n\n;; Collect all solutions\n(amb-collect\n  (let (x (amb 1 2 3 4 5))\n    (when (even? x) (amb-fail))\n    x))\n;; => (1 3 5)\n\n;; Constraint satisfaction: find Pythagorean triples\n(amb-collect\n  (let ((a (amb 1 2 3 4 5 6 7 8 9 10))\n        (b (amb 1 2 3 4 5 6 7 8 9 10))\n        (c (amb 1 2 3 4 5 6 7 8 9 10)))\n    (unless (and (<= a b) (= (+ (* a a) (* b b)) (* c c)))\n      (amb-fail))\n    (list a b c)))\n;; => ((3 4 5) (6 8 10))\n\n;; amb-assert: shorthand for (unless test (amb-fail))\n(amb-find\n  (let ((x (amb 1 2 3 4 5))\n        (y (amb 1 2 3 4 5)))\n    (amb-assert (= (+ x y) 6))\n    (amb-assert (> x y))\n    (list x y)))\n;; => (4 2) or (5 1)\n\n;; Custom strategy: shuffle choices for randomized search\n(parameterize ((amb-strategy shuffle))\n  (amb-find\n    (let (x (amb 1 2 3 4 5))\n      (amb-assert (odd? x))\n      x)))\n;; => random odd number from 1,3,5",
    "notes": ":std/amb implements McCarthy's ambiguous operator for nondeterministic programming. amb chooses one value from its arguments. If subsequent computation calls amb-fail, amb backtracks and tries the next choice. amb-find returns the first successful result. amb-collect gathers all solutions. amb-assert is sugar for (unless test (amb-fail)). amb-strategy controls iteration order: identity (default, left-to-right) or shuffle (randomized). Internally uses continuations (let/cc) for backtracking, running in a dedicated thread.",
    "related": [
      "coroutine-generator-pattern"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "generic-multi-dispatch",
    "title": "Type-based method dispatch with defgeneric/defmethod",
    "tags": [
      "generic",
      "defgeneric",
      "defmethod",
      "dispatch",
      "multimethod",
      "polymorphism",
      "type"
    ],
    "imports": [
      ":std/generic"
    ],
    "code": "(import :std/generic)\n\n;; Define a generic function\n(defgeneric stringify)\n\n;; Add methods for specific types\n(defmethod {stringify fixnum}\n  (lambda (n) (number->string n)))\n\n(defmethod {stringify string}\n  (lambda (s) (string-append \"\\\"\" s \"\\\"\")))\n\n(defmethod {stringify pair}\n  (lambda (p) (string-append \"(\" (stringify (car p))\n                              \" . \" (stringify (cdr p)) \")\")))\n\n;; Default method for any type\n(defmethod {stringify :t}\n  (lambda (obj) (call-with-output-string (lambda (p) (write obj p)))))\n\n;; Dispatch is automatic based on first argument's type\n(stringify 42)           ;; => \"42\"\n(stringify \"hello\")      ;; => \"\\\"hello\\\"\"\n(stringify '(1 . \"a\"))   ;; => \"(1 . \\\"a\\\")\"\n(stringify #t)           ;; => \"#t\" (default :t method)\n\n;; Works with user-defined types\n(defstruct point (x y) transparent: #t)\n\n(defmethod {stringify point}\n  (lambda (p) (format \"Point(~a, ~a)\" (point-x p) (point-y p))))\n\n(stringify (make-point 3 4))  ;; => \"Point(3, 4)\"\n\n;; Multi-arity generic (dispatch on first arg only)\n(defgeneric combine)\n\n(defmethod {combine fixnum}\n  (lambda (a b) (+ a b)))\n\n(defmethod {combine string}\n  (lambda (a b) (string-append a b)))\n\n(combine 1 2)         ;; => 3\n(combine \"hi \" \"lo\")  ;; => \"hi lo\"\n\n;; Type names for defmethod:\n;; fixnum, flonum, string, pair, vector, symbol, boolean, keyword,\n;; char, null (:t = any type / default fallback)\n;; For structs/classes: use the struct name directly (e.g. point)",
    "notes": ":std/generic provides CLOS-style single-dispatch generic functions. defgeneric declares the generic; defmethod adds a type-specialized implementation. Dispatch is on the FIRST argument's type. Method syntax: {method-name type-name}. Type resolution uses the class hierarchy — more specific types (fixnum) take priority over general types (number). :t is the catch-all default type. Thread-safe: method binding uses mutex protection. Methods are cached per-arity for fast dispatch. For dispatch on multiple arguments, use pattern matching or defclass with interfaces instead.",
    "related": [
      "interface-contracts",
      "defstruct-positional-args"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "deque-double-ended-queue",
    "title": "Double-ended queue (deque) with O(1) front/back operations",
    "tags": [
      "deque",
      "double-ended",
      "queue",
      "push",
      "pop",
      "front",
      "back",
      "data-structure"
    ],
    "imports": [
      ":std/misc/deque"
    ],
    "code": "(import :std/misc/deque)\n\n;; Create a double-ended queue\n(def dq (make-deque))\n\n;; Push to front or back\n(push-front! dq 'a)\n(push-front! dq 'b)\n(push-back! dq 'c)\n;; deque is now: [b a c]\n\n;; Peek without removing\n(peek-front dq)   ;; => b\n(peek-back dq)    ;; => c\n\n;; Pop from front or back\n(pop-front! dq)   ;; => b\n(pop-back! dq)    ;; => c\n;; deque is now: [a]\n\n;; Pop with default (when empty)\n(pop-front! dq)        ;; => a\n(pop-front! dq 'empty) ;; => empty\n\n;; Check emptiness\n(deque-empty? dq)  ;; => #t\n(deque-length dq)  ;; => 0\n\n;; Convert to list\n(push-back! dq 1)\n(push-back! dq 2)\n(push-back! dq 3)\n(deque->list dq)   ;; => (1 2 3)\n\n;; Pattern: sliding window\n(def window (make-deque))\n(def window-size 3)\n(def (add-to-window! val)\n  (push-back! window val)\n  (when (> (deque-length window) window-size)\n    (pop-front! window)))\n\n(for-each add-to-window! '(1 2 3 4 5))\n(deque->list window)  ;; => (3 4 5)",
    "notes": "Deque from :std/misc/deque uses a doubly-linked list internally. All operations (push-front!, push-back!, pop-front!, pop-back!, peek-front, peek-back) are O(1). Nodes have prev/next pointers; #f indicates unlinked boundaries. NOT thread-safe — wrap with mutex for concurrent access. Useful for sliding windows, BFS, and work-stealing patterns.",
    "related": [
      "priority-queue-heap",
      "list-builder-efficient-append"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "run-process-subprocess",
    "title": "Run external processes and capture output",
    "tags": [
      "process",
      "subprocess",
      "exec",
      "command",
      "shell",
      "capture",
      "output",
      "pipe",
      "run"
    ],
    "imports": [
      ":std/misc/process"
    ],
    "code": "(import :std/misc/process)\n\n;; Run a command and capture stdout as string\n(run-process [\"ls\" \"-la\"] stdout-redirection: #t\n             coprocess: read-all-as-string)\n;; => \"total 42\\ndrwxr-xr-x ...\"\n\n;; Run with check-status (raises on non-zero exit)\n(run-process [\"grep\" \"-r\" \"pattern\" \"src/\"]\n             stdout-redirection: #t\n             coprocess: read-all-as-string\n             check-status: #t)\n\n;; Run a batch command (inherits stdin/stdout/stderr)\n(run-process/batch [\"make\" \"build\"])\n\n;; Filter: pipe input string through a command\n(filter-with-process [\"sort\" \"-n\"] \"3\\n1\\n2\\n\")\n;; => \"1\\n2\\n3\\n\"\n\n;; Custom coprocess: process output line by line\n(run-process [\"find\" \".\" \"-name\" \"*.ss\"]\n             stdout-redirection: #t\n             coprocess: (lambda (port)\n               (let loop ((lines []))\n                 (let (line (read-line port))\n                   (if (eof-object? line)\n                     (reverse lines)\n                     (loop (cons line lines)))))))\n\n;; Pass environment variables\n(run-process [\"env\"]\n             stdout-redirection: #t\n             coprocess: read-all-as-string\n             environment: (cons \"MY_VAR=hello\"\n                                (##command-line)))\n\n;; Invoke: simplified API for fire-and-forget\n(invoke \"echo\" [\"hello\" \"world\"])\n\n;; Getting exit status without exception\n(def proc (open-process [path: \"grep\" arguments: [\"-q\" \"pattern\" \"file.txt\"]]))\n(process-status proc)  ;; => 0 or 1",
    "notes": ":std/misc/process wraps Gambit's open-process. run-process is the main entry point: pass the command as a list [program arg ...]. stdout-redirection: #t captures stdout. coprocess receives the process port and returns a value (default: read-all-as-string). check-status: #t raises an exception on non-zero exit. run-process/batch inherits all I/O (for interactive or build commands). filter-with-process feeds a string to stdin and captures stdout. For Gambit-level control, use open-process directly with path: and arguments: keywords.",
    "related": [
      "read-file-to-string"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "repr-evaluable-printing",
    "title": "Evaluable object printing with repr (Python-style repr)",
    "tags": [
      "repr",
      "print",
      "display",
      "debug",
      "representation",
      "pr",
      "prn",
      "inspect"
    ],
    "imports": [
      ":std/misc/repr"
    ],
    "code": "(import :std/misc/repr)\n\n;; repr: convert any object to a string representation\n(repr 42)          ;; => \"42\"\n(repr \"hello\")     ;; => \"\\\"hello\\\"\"\n(repr '(1 2 3))    ;; => \"(1 2 3)\"\n(repr (hash (\"a\" 1) (\"b\" 2)))  ;; => \"(hash (\\\"a\\\" 1) (\\\"b\\\" 2))\"\n\n;; pr: print representation to a port (default: current-output-port)\n(pr 42)            ;; prints: 42\n(pr \"hello\")       ;; prints: \"hello\"\n\n;; prn: print representation + newline\n(prn '(1 2 3))     ;; prints: (1 2 3)\\n\n\n;; Custom repr for your structs via :pr method\n(defstruct point (x y) transparent: #t)\n\n(defmethod {:pr point}\n  (lambda (self port options)\n    (fprintf port \"(make-point ~a ~a)\" (point-x self) (point-y self))))\n\n(repr (make-point 3 4))  ;; => \"(make-point 3 4)\"\n\n;; display-separated: format lists with custom delimiters\n(display-separated '(1 2 3)\n  port: (current-output-port)\n  prefix: \"[\"\n  separator: \", \"\n  suffix: \"]\")\n;; prints: [1, 2, 3]\n\n;; Useful for debugging: print and return\n(def (debug-print label value)\n  (display label)\n  (display \": \")\n  (prn value)\n  value)\n\n(debug-print \"result\" (+ 1 2))  ;; prints: result: 3, returns 3",
    "notes": ":std/misc/repr provides Python-style repr for all Gerbil objects. The output is designed to be evaluable Scheme code when possible. For custom types, implement the :pr method (receives self, port, and options hash). Hash tables are printed in (hash ...) literal syntax. display-separated is useful for custom formatting with delimiters. If no :pr method exists, repr uses #<N #;\\\"obj\\\"> syntax with a serial number.",
    "related": [
      "chain-advanced-pipeline"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "assert-with-diagnostics",
    "title": "Assert with automatic sub-expression diagnostics",
    "tags": [
      "assert",
      "check",
      "debug",
      "diagnostic",
      "test",
      "invariant",
      "error-message"
    ],
    "imports": [
      ":std/assert"
    ],
    "code": "(import :std/assert)\n\n;; assert! checks a condition and reports sub-expression values on failure\n(def x 5)\n(def y 10)\n(assert! (< x y))  ;; passes silently\n\n;; On failure, reports values of all sub-expressions:\n(def a 10)\n(def b 3)\n;; (assert! (< (* a 2) b))\n;; Error: Assertion failed (< (* a 2) b)\n;;   a => 10\n;;   b => 3\n;;   (* a 2) => 20\n\n;; Custom error message\n;; (assert! (positive? x) \"x must be positive\")\n\n;; Pattern: function preconditions\n(def (divide a b)\n  (assert! (not (zero? b)))  ;; shows b's value on failure\n  (/ a b))\n\n;; Pattern: invariant checking in data structures\n(def (sorted? lst)\n  (or (null? lst) (null? (cdr lst))\n      (and (<= (car lst) (cadr lst))\n           (sorted? (cdr lst)))))\n\n(def (binary-search vec target)\n  (assert! (sorted? (vector->list vec)))\n  ;; ... search implementation\n  )",
    "notes": ":std/assert provides assert! which automatically extracts sub-expressions from the assertion condition and binds them to temporary variables. On failure, it reports each sub-expression and its value, making debugging much easier than a plain assertion. The macro uses compile-time analysis (split-sub-exprs) to identify which expressions to capture. Built-in identifiers are not rebound. Source location is preserved for error reporting.",
    "related": [
      "is-predicate-factory"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "actor-message-passing",
    "title": "Actor message passing with send, receive, and reply",
    "tags": [
      "actor",
      "message",
      "send",
      "receive",
      "reply",
      "mailbox",
      "concurrent",
      "defmessage",
      "rpc"
    ],
    "imports": [
      ":std/actor"
    ],
    "code": "(import :std/actor)\n\n;; Define message types\n(defmessage !ping ())\n(defmessage !echo (text))\n(defmessage !shutdown ())\n(defmessage !ok (value))\n\n;; Simple actor with message loop\n(def (my-actor)\n  (let/cc exit\n    (while #t\n      (<-  ;; receive and pattern match on messages\n        ((!ping)\n         (--> (!ok 'pong)))     ;; reply to sender\n\n        ((!echo text)\n         (--> (!ok (string-append \"Echo: \" text))))\n\n        ((!shutdown)\n         (-->? (!ok 'bye))      ;; reply only if expected\n         (exit 'shutdown))\n\n        (unexpected\n         (displayln \"unknown: \" @message))))))\n\n;; Start the actor server and spawn actor\n(def srv (start-actor-server! cookie: (make-random-cookie)))\n(def actor-thread (spawn/name 'my-actor my-actor))\n\n;; One-way send (fire and forget)\n(-> actor-thread (!ping))\n\n;; Request-reply (blocks until response or timeout)\n(def reply (->> actor-thread (!echo \"hello\") timeout: 5))\n;; reply => (!ok \"Echo: hello\")\n\n;; Context variables available inside <- handlers:\n;; @message       - the received message\n;; @source        - sender thread/handle\n;; @nonce         - message ID\n;; @reply-expected? - whether sender expects a reply\n;; @envelope      - full envelope struct\n\n;; Shutdown the actor\n(->> actor-thread (!shutdown) timeout: 5)",
    "notes": "Gerbil actors use thread mailboxes for message passing. defmessage defines a struct type for messages. <- receives and pattern-matches. -> sends one-way (fire-and-forget). ->> sends and waits for reply (RPC-style). --> sends a reply (only works inside <- handler). -->? sends reply only if the sender expects one. Context syntax parameters (@source, @nonce, etc.) are bound inside <- handlers via syntax-parameterize. Actors are just threads — spawn/name creates them. start-actor-server! is needed for remote/ensemble actors.",
    "related": [
      "channel-based-communication",
      "event-sync-select"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "port-utilities-file-io",
    "title": "File I/O utilities: read/write files, strings, lines, bytes",
    "tags": [
      "port",
      "file",
      "read",
      "write",
      "string",
      "lines",
      "bytes",
      "io",
      "utility"
    ],
    "imports": [
      ":std/misc/ports"
    ],
    "code": "(import :std/misc/ports)\n\n;; Read entire file as string\n(def content (read-file-string \"path/to/file.txt\"))\n\n;; Read file as list of lines\n(def lines (read-file-lines \"path/to/file.txt\"))\n\n;; Read from port as string\n(def text (call-with-input-file \"file.txt\" read-all-as-string))\n\n;; Read from port as u8vector (binary)\n(def bytes (call-with-input-file \"file.bin\" read-all-as-u8vector))\n\n;; Write string to file\n(write-file-string \"output.txt\" \"hello world\\n\")\n\n;; Write lines to file\n(write-file-lines \"output.txt\" '(\"line 1\" \"line 2\" \"line 3\"))\n\n;; Macro forms with automatic port binding\n(with-input \"file.txt\"\n  (read-line))  ;; reads from file bound to current-input-port\n\n(with-output \"out.txt\"\n  (displayln \"hello\"))  ;; writes to file\n\n;; Copy between ports\n(call-with-input-file \"source.txt\"\n  (lambda (in)\n    (call-with-output-file \"dest.txt\"\n      (lambda (out)\n        (copy-port in out)))))\n\n;; Functional forms\n(call-with-input \"file.txt\" (lambda (port) (read-json port)))\n(call-with-output \"file.txt\" (lambda (port) (write-json data port)))",
    "notes": ":std/misc/ports provides convenience wrappers for common file I/O patterns. read-file-string and read-file-lines are the most commonly needed. write-file-string and write-file-lines handle opening/closing automatically. copy-port auto-detects byte vs character ports. with-input/with-output are macros that parameterize current-input-port/current-output-port. For binary I/O, use read-all-as-u8vector. All functions handle port closing on exceptions.",
    "related": [
      "read-file-to-string",
      "read-file-as-list-of-lines"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "interface-contracts",
    "title": "Define and implement interfaces with type contracts",
    "tags": [
      "interface",
      "contract",
      "type",
      "protocol",
      "defmethod",
      "polymorphism",
      "using",
      "typed"
    ],
    "imports": [
      ":std/interface"
    ],
    "code": "(import :std/interface)\n\n;; Define an interface\n(interface Printable\n  (to-string)\n  (display-to port))\n\n(interface Comparable\n  (compare-to other))\n\n;; Implement for a struct\n(defstruct point (x y) transparent: #t)\n\n(defmethod {to-string point}\n  (lambda (self)\n    (format \"Point(~a, ~a)\" (point-x self) (point-y self))))\n\n(defmethod {display-to point}\n  (lambda (self port)\n    (display (to-string self) port)))\n\n(defmethod {compare-to point}\n  (lambda (self other)\n    (let ((d1 (+ (* (point-x self) (point-x self))\n                  (* (point-y self) (point-y self))))\n          (d2 (+ (* (point-x other) (point-x other))\n                  (* (point-y other) (point-y other)))))\n      (- d1 d2))))\n\n;; Use interface as type contract in function signatures\n(def (print-it (obj : Printable))\n  (displayln {obj.to-string}))\n\n(def (sort-items (items : :list))\n  (sort items (lambda (a b)\n    (< {a.compare-to b} 0))))\n\n;; 'using' for typed, optimized access (no dynamic dispatch)\n(def (fast-print (p :- point))\n  (using (p :- point)\n    (displayln \"x=\" p.x \" y=\" p.y)))\n\n;; Multiple typed bindings\n(def (add-points (p1 :- point) (p2 :- point))\n  (using ((p1 :- point) (p2 :- point))\n    (make-point (+ p1.x p2.x) (+ p1.y p2.y))))\n\n(print-it (make-point 3 4))  ;; => Point(3, 4)\n(fast-print (make-point 1 2)) ;; => x=1 y=2",
    "notes": "Interfaces define a protocol (set of methods) that types can implement. Use (obj : InterfaceName) in function signatures for runtime type checking. Use (obj :- StructType) with 'using' for compile-time optimized access without dynamic dispatch — this inlines field accesses. Interface methods are called via {obj.method args} syntax. Interfaces compose: a type can implement multiple interfaces. Type contracts raise errors at call time if the wrong type is passed.",
    "related": [
      "generic-multi-dispatch",
      "with-destroy-raii"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "defmethod-alias-multi-name",
    "title": "Create method aliases with defmethod/alias",
    "tags": [
      "defmethod",
      "alias",
      "method",
      "rename",
      "multiple-names",
      "dispatch",
      "oop"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": "(import :std/sugar)\n\n;; defmethod/alias: one implementation, multiple method names\n(defclass animal (name sound) transparent: #t)\n\n(defmethod/alias {speak (talk say) animal}\n  (lambda (self)\n    (string-append (@ self name) \" says \" (@ self sound))))\n\n;; All three names dispatch to the same implementation\n(def dog (make-animal \"Rex\" \"woof\"))\n{speak dog}    ;; => \"Rex says woof\"\n{talk dog}     ;; => \"Rex says woof\"\n{say dog}      ;; => \"Rex says woof\"\n\n;; Useful for API compatibility: provide both short and long names\n(defclass logger (level) transparent: #t)\n\n(defmethod/alias {log (write-log emit) logger}\n  (lambda (self msg)\n    (when (>= (@ self level) 1)\n      (displayln \"[LOG] \" msg))))\n\n(def lg (make-logger 1))\n{log lg \"hello\"}        ;; => [LOG] hello\n{write-log lg \"world\"}  ;; => [LOG] world\n{emit lg \"!\"}           ;; => [LOG] !",
    "notes": "defmethod/alias from :std/sugar maps multiple method names to a single implementation. Syntax: {primary-name (alias1 alias2 ...) ClassName}. All names create separate method entries in the dispatch table, but they all point to the same lambda. Useful for providing backwards-compatible names or short/long variants of the same operation.",
    "related": [
      "generic-multi-dispatch",
      "interface-contracts"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "awhen-anaphoric-conditional",
    "title": "Anaphoric when (awhen) for concise null-checking",
    "tags": [
      "awhen",
      "anaphoric",
      "when",
      "null-check",
      "optional",
      "binding",
      "sugar"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": "(import :std/sugar)\n\n;; awhen: bind a value, execute body only if truthy\n;; (awhen (var expr) body ...) => (let (var expr) (when var body ...))\n\n;; Common pattern: lookup and use\n(def table (hash (\"key1\" 42) (\"key2\" \"hello\")))\n\n(awhen (v (hash-get table \"key1\"))\n  (displayln \"found: \" v))  ;; prints: found: 42\n\n(awhen (v (hash-get table \"missing\"))\n  (displayln \"found: \" v))  ;; does nothing (#f from hash-get)\n\n;; Chain of lookups\n(def config (hash (\"db\" (hash (\"host\" \"localhost\") (\"port\" 5432)))))\n\n(awhen (db (hash-get config \"db\"))\n  (awhen (host (hash-get db \"host\"))\n    (displayln \"connecting to \" host)))\n\n;; With side effects\n(awhen (pid (find-process \"myapp\"))\n  (kill-process pid)\n  (displayln \"killed process \" pid))\n\n;; Compare with verbose alternative:\n;; (let (v (hash-get table \"key1\"))\n;;   (when v\n;;     (displayln \"found: \" v)))",
    "notes": "awhen from :std/sugar is shorthand for let + when. The bound variable is available in the body. Returns void if the expression is #f. This is much more concise than the let+when pattern for optional value handling. Works well with hash-get (returns #f on missing keys), find (returns #f if not found), and other functions that return #f for absence.",
    "related": [
      "destructure-hash-tables-with-let-hash",
      "is-predicate-factory"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "shuffle-random-permutation",
    "title": "Fisher-Yates shuffle for random permutations",
    "tags": [
      "shuffle",
      "random",
      "permutation",
      "randomize",
      "vector",
      "list",
      "sample"
    ],
    "imports": [
      ":std/misc/shuffle"
    ],
    "code": "(import :std/misc/shuffle)\n\n;; Shuffle a list (returns new list)\n(shuffle '(1 2 3 4 5))  ;; => (3 1 5 2 4) (random order)\n\n;; Shuffle a vector (returns new vector)\n(vector-shuffle #(a b c d e))  ;; => #(c a e b d)\n\n;; Shuffle vector in-place (mutates)\n(def v #(1 2 3 4 5))\n(vector-shuffle! v)  ;; v is now randomly permuted\n\n;; Custom random number generator\n(import :std/crypto)\n(shuffle '(1 2 3 4 5) random-integer)\n\n;; Pattern: random sampling (take first N after shuffle)\n(def (random-sample lst n)\n  (take (shuffle lst) (min n (length lst))))\n\n(random-sample '(a b c d e f g) 3)  ;; => e.g. (d a f)",
    "notes": ":std/misc/shuffle implements Fisher-Yates (Knuth) shuffle, which produces uniformly distributed random permutations. shuffle copies the list to a vector, shuffles in-place, then converts back. vector-shuffle returns a new vector; vector-shuffle! mutates. An optional second argument provides a custom RNG: (lambda (n) -> integer in [0, n)). Default uses Gambit's random-integer.",
    "related": [
      "amb-nondeterministic-search"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "with-id-identifier-generation",
    "title": "Generate identifiers at macro time with with-id",
    "tags": [
      "with-id",
      "macro",
      "identifier",
      "generate",
      "metaprogramming",
      "syntax",
      "defsyntax",
      "hygiene"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": "(import :std/sugar)\n\n;; with-id generates new identifiers by concatenating strings/symbols\n;; at macro expansion time. Useful for defining families of related functions.\n\n;; Example: generate getter/setter pairs from a name\n(defrules define-property ()\n  ((_ name initial)\n   (with-id name ((getter #'name)\n                  (setter #'name \"-set!\"))\n     (begin\n       (def getter initial)\n       (def (setter v) (set! getter v))))))\n\n(define-property my-counter 0)\nmy-counter          ;; => 0\n(my-counter-set! 5)\nmy-counter          ;; => 5\n\n;; with-id syntax: (with-id context-id ((new-id parts ...) ...) body)\n;; parts can be: #'identifier, \"string\", or 'symbol\n;; They're concatenated to form the new identifier name\n\n;; Example: defvar macro for indexed memory access\n(defrules defvar ()\n  ((_ name n vec)\n   (with-id name ((idx #'name \"@\")\n                  (get #'name \"-get\")\n                  (set! #'name \"-set!\"))\n     (begin\n       (def idx n)\n       (def (get) (vector-ref vec idx))\n       (def (set! v) (vector-set! vec idx v))))))\n\n(def mem (make-vector 10 0))\n(defvar x 0 mem)\n(defvar y 1 mem)\n(x-set! 42)\n(y-set! 99)\n(x-get)   ;; => 42\nx@        ;; => 0 (the index)\n\n;; with-id/expr: same but wraps body in (let () ...) for expression context\n;; Use when you need the result as a value, not at top level",
    "notes": "with-id from :std/sugar is for advanced macro writing where you need to create related identifier names programmatically. The context identifier determines the hygiene scope — new identifiers are created in the same scope as the context. Parts are concatenated as strings to form the new name: #'id extracts the symbol name, \"string\" is literal, 'symbol converts to string. with-id/expr wraps in (let () ...) so it can be used in expression position.",
    "related": [
      "syntax-eval-compile-time"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "if-let-when-let-conditional-bind",
    "title": "Conditional binding with if-let and when-let (short-circuit on #f)",
    "tags": [
      "if-let",
      "when-let",
      "conditional",
      "binding",
      "optional",
      "short-circuit",
      "sugar",
      "guard"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": "(import :std/sugar)\n\n;; if-let: bind variables, run then-branch if ALL are truthy\n;; If any binding is #f, immediately run else-branch\n(def ht (hash (\"name\" \"Alice\") (\"age\" 30)))\n\n(if-let ((name (hash-get ht \"name\"))\n         (age (hash-get ht \"age\")))\n  (format \"~a is ~a years old\" name age)\n  \"missing data\")\n;; => \"Alice is 30 years old\"\n\n(if-let ((name (hash-get ht \"name\"))\n         (email (hash-get ht \"email\")))  ;; #f — not found\n  (format \"~a: ~a\" name email)\n  \"missing data\")\n;; => \"missing data\" (short-circuited at email)\n\n;; when-let: like if-let but no else branch (returns void if #f)\n(when-let ((name (hash-get ht \"name\")))\n  (displayln \"Hello, \" name \"!\"))\n;; prints: Hello, Alice!\n\n(when-let ((email (hash-get ht \"email\")))\n  (send-notification email))\n;; does nothing (email is #f)\n\n;; Single binding form\n(if-let (x (find even? '(1 3 5 7)))\n  (displayln \"found even: \" x)\n  (displayln \"no even numbers\"))\n\n;; Chaining lookups\n(if-let ((config (load-config))\n         (db (hash-get config \"database\"))\n         (host (hash-get db \"host\")))\n  (connect host)\n  (error \"incomplete configuration\"))",
    "notes": "if-let and when-let from :std/sugar provide conditional binding that short-circuits on #f. Each binding is tested in order — if any evaluates to #f, the else branch (for if-let) runs immediately without evaluating subsequent bindings. This is implemented using let/cc for early exit. Perfect for chaining optional lookups (hash-get, find, etc.) where any step might fail. when-let returns void when the condition is false.",
    "related": [
      "awhen-anaphoric-conditional",
      "destructure-hash-tables-with-let-hash"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "alet-star-anaphoric-let",
    "title": "alet/alet* — anaphoric let that short-circuits on #f",
    "tags": [
      "alet",
      "alet*",
      "and-let",
      "short-circuit",
      "pipeline",
      "optional",
      "binding",
      "chained"
    ],
    "imports": [],
    "code": ";; alet* is a built-in (no import needed) that works like let*\n;; but short-circuits to #f if any binding evaluates to #f\n\n;; Chained lookups — returns #f if any step fails\n(def config (hash (\"db\" (hash (\"host\" \"localhost\") (\"port\" 5432)))))\n\n(alet* ((db (hash-get config \"db\"))\n        (host (hash-get db \"host\"))\n        (port (hash-get db \"port\")))\n  (string-append host \":\" (number->string port)))\n;; => \"localhost:5432\"\n\n(alet* ((db (hash-get config \"db\"))\n        (ssl (hash-get db \"ssl\")))  ;; #f - not found\n  (displayln \"SSL: \" ssl))\n;; => #f (short-circuited, body never runs)\n\n;; Works like a null-safe navigation chain (?.operator in other langs)\n(alet* ((user (find-user id))\n        (address (user-address user))\n        (city (address-city address)))\n  city)\n;; Returns city or #f if any step fails\n\n;; alet (non-star): bindings are independent (like let, not let*)\n(alet ((x (hash-get ht \"x\"))\n       (y (hash-get ht \"y\")))\n  (+ x y))\n\n;; and-let* is the SRFI-2 equivalent\n;; (and-let* ((x expr1) (y expr2)) body)\n;; Same semantics: short-circuit on #f",
    "notes": "alet* is built into Gerbil core (no import needed). It behaves like let* but returns #f immediately if any binding evaluates to #f, without evaluating subsequent bindings or the body. This is Gerbil's answer to null-safe navigation (like ?. in Kotlin/Swift). alet is the parallel binding version (like let). and-let* from SRFI-2 has similar semantics. Use alet* for chaining operations that may return #f (hash-get, find, assoc, etc.).",
    "related": [
      "if-let-when-let-conditional-bind",
      "awhen-anaphoric-conditional"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "logger-per-source-config",
    "title": "Structured logging with per-source level configuration",
    "tags": [
      "logger",
      "logging",
      "debug",
      "info",
      "warn",
      "error",
      "verbose",
      "level",
      "source"
    ],
    "imports": [
      ":std/logger"
    ],
    "code": "(import :std/logger)\n\n;; Basic logging (uses current-logger-options)\n(errorf \"critical: ~a\" \"disk full\")     ;; ERROR level\n(warnf \"caution: ~a\" \"low memory\")      ;; WARN level\n(infof \"status: ~a\" \"running\")          ;; INFO level\n(debugf \"detail: ~a\" \"processing x\")    ;; DEBUG level\n(verbosef \"trace: ~a\" \"entered fn\")     ;; VERBOSE level\n\n;; Set global log level (0=ERROR, 1=WARN, 2=INFO, 3=DEBUG, 4=VERBOSE)\n(current-logger-options (make-logger-options 2))  ;; INFO and above\n\n;; Per-source log levels\n(def opts (make-logger-options\n            2  ;; default: INFO\n            (hash ('network 4)    ;; network: VERBOSE\n                  ('database 1)))) ;; database: WARN only\n\n(current-logger-options opts)\n\n;; Now logging uses source-specific levels:\n(debugf \"~a\" \"general debug\")          ;; suppressed (default=INFO)\n(verbosef source: 'network \"~a\" \"x\")   ;; printed (network=VERBOSE)\n(debugf source: 'database \"~a\" \"y\")    ;; suppressed (database=WARN)\n(warnf source: 'database \"~a\" \"z\")     ;; printed\n\n;; Log level names to numbers\n;; (log-level 'ERROR)   => 0\n;; (log-level 'WARN)    => 1\n;; (log-level 'INFO)    => 2\n;; (log-level 'DEBUG)   => 3\n;; (log-level 'VERBOSE) => 4\n\n;; Pattern: per-module logger\n(def (my-module-log msg . args)\n  (apply debugf source: 'my-module msg args))",
    "notes": ":std/logger provides printf-style logging with five levels. current-logger-options is a parameter holding the logger configuration. make-logger-options takes a default level and optional hash of source-specific overrides. Source is a symbol identifying the subsystem. All log functions (errorf, warnf, infof, debugf, verbosef) accept an optional source: keyword. Messages below the configured level are suppressed. Thread-local caching is used for performance.",
    "related": [
      "repr-evaluable-printing"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "getopt-cli-parsing",
    "title": "Command-line argument parsing with getopt",
    "tags": [
      "getopt",
      "cli",
      "command-line",
      "argument",
      "option",
      "flag",
      "subcommand",
      "parse"
    ],
    "imports": [
      ":std/getopt"
    ],
    "code": "(import :std/getopt)\n\n;; Define CLI options\n(def my-opts\n  (getopt\n    (flag 'verbose \"-v\" \"--verbose\"\n      help: \"Enable verbose output\")\n    (option 'output \"-o\" \"--output\"\n      help: \"Output file path\"\n      default: \"out.txt\")\n    (option 'count \"-n\" \"--count\"\n      help: \"Number of iterations\"\n      value: string->number\n      default: 1)\n    (argument 'input\n      help: \"Input file\")\n    (optional-argument 'extra\n      help: \"Optional extra file\"\n      default: #f)))\n\n;; Parse arguments\n(def args (call-with-getopt \"myapp\" my-opts\n            (lambda (opt) opt)   ;; handler receives parsed options hash\n            args: '(\"-v\" \"-n\" \"5\" \"-o\" \"result.txt\" \"input.txt\")))\n;; args => hash with: verbose=#t, output=\"result.txt\", count=5, input=\"input.txt\"\n\n;; With subcommands\n(def cli\n  (getopt\n    (command 'build\n      help: \"Build the project\"\n      (flag 'release \"--release\" help: \"Release build\")\n      (option 'target \"-t\" help: \"Target platform\"))\n    (command 'test\n      help: \"Run tests\"\n      (flag 'verbose \"-v\" help: \"Verbose output\")\n      (rest-arguments 'files help: \"Test files\"))))\n\n;; call-with-getopt handles help display and error reporting\n(def (main . args)\n  (call-with-getopt \"myapp\" cli\n    (lambda (cmd opt)\n      (case cmd\n        ((build) (do-build opt))\n        ((test) (do-test opt))))\n    args: args))\n\n;; Access parsed options\n(def (do-build opt)\n  (let-hash opt\n    (when .?release (displayln \"Release mode\"))\n    (displayln \"Target: \" (or .?target \"default\"))))",
    "notes": ":std/getopt provides declarative CLI argument parsing. flag creates boolean switches. option creates key-value options (value: provides a converter function). argument is a required positional arg. optional-argument is optional. rest-arguments collects remaining args as a list. command creates subcommands. call-with-getopt invokes the handler with parsed results and handles --help display and error messages automatically. Results are returned as a hash table — use let-hash for convenient access.",
    "related": [
      "destructure-hash-tables-with-let-hash"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "csv-parsing-options",
    "title": "CSV parsing with configurable options and predefined standards",
    "tags": [
      "csv",
      "parse",
      "read",
      "write",
      "text",
      "delimiter",
      "rfc4180",
      "options"
    ],
    "imports": [
      ":std/text/csv"
    ],
    "code": "(import :std/text/csv)\n\n;; Read CSV from a file (returns list of lists)\n(def rows\n  (call-with-input-file \"data.csv\"\n    (lambda (port)\n      (read-csv-records port))))\n\n;; Write CSV records\n(call-with-output-file \"output.csv\"\n  (lambda (port)\n    (for-each (lambda (row) (write-csv-record row port))\n              '((\"name\" \"age\" \"city\")\n                (\"Alice\" \"30\" \"NYC\")\n                (\"Bob\" \"25\" \"LA\")))))\n\n;; Custom CSV options\n(def my-opts\n  (make-csv-options\n    separator: #\\tab       ;; tab-separated\n    quote-char: #\\\"        ;; quote character\n    unquoted-quotequote?: #f\n    loose-quote?: #f\n    newline: 'lf))\n\n;; Use custom options via parameterize\n(parameterize ((current-csv-options my-opts))\n  (call-with-input-file \"data.tsv\" read-csv-records))\n\n;; Or with call-with-csv-options\n(call-with-csv-options my-opts\n  (lambda ()\n    (call-with-input-file \"data.tsv\" read-csv-records)))\n\n;; Predefined option sets\n;; csv-options/rfc4180           - strict RFC 4180\n;; csv-options/rfc4180-strict    - stricter variant\n;; csv-options/creativyst        - Creativyst CSV standard\n\n;; Read a single record at a time\n(call-with-input-file \"data.csv\"\n  (lambda (port)\n    (let loop ()\n      (let (record (read-csv-record port))\n        (unless (eof-object? record)\n          (displayln record)\n          (loop))))))\n\n;; Convert CSV to hash tables (first row as headers)\n(def (csv->hashes port)\n  (let* ((headers (read-csv-record port))\n         (records (read-csv-records port)))\n    (map (lambda (row)\n           (let (ht (make-hash-table))\n             (for-each (lambda (h v) (hash-put! ht h v))\n                       headers row)\n             ht))\n         records)))",
    "notes": ":std/text/csv provides RFC 4180 compliant CSV parsing. read-csv-records reads all records from a port. read-csv-record reads one record. write-csv-record writes one record. CSV options are configured via make-csv-options with: separator (default #\\,), quote-char, newline ('lf, 'cr, 'crlf, 'lax). Use current-csv-options parameter or call-with-csv-options for custom settings. Predefined: csv-options/rfc4180 for standard CSV.",
    "related": [
      "port-utilities-file-io"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "in-range-iota-naturals-iterators",
    "title": "Numeric iterators: in-range, in-iota, in-naturals",
    "tags": [
      "in-range",
      "in-iota",
      "in-naturals",
      "iterator",
      "numeric",
      "sequence",
      "loop",
      "range"
    ],
    "imports": [
      ":std/iter"
    ],
    "code": "(import :std/iter)\n\n;; in-range: iterate between bounds (auto-detects step direction)\n(for/collect (x (in-range 5)) x)            ;; => (0 1 2 3 4)\n(for/collect (x (in-range 2 7)) x)          ;; => (2 3 4 5 6)\n(for/collect (x (in-range 0 10 2)) x)       ;; => (0 2 4 6 8)\n(for/collect (x (in-range 5 0)) x)          ;; => (5 4 3 2 1) auto negative step!\n(for/collect (x (in-range 10 0 -3)) x)      ;; => (10 7 4 1)\n\n;; in-iota: fixed count from a start (SRFI-1 iota semantics)\n(for/collect (x (in-iota 5)) x)             ;; => (0 1 2 3 4) — 5 elements from 0\n(for/collect (x (in-iota 3 10)) x)          ;; => (10 11 12) — 3 elements from 10\n(for/collect (x (in-iota 4 0 0.5)) x)       ;; => (0 0.5 1.0 1.5) — step 0.5\n\n;; in-naturals: infinite sequence (must limit with another iterator or when)\n(for/collect ((x (in-naturals))\n              (_ (in-range 5)))  ;; limit to 5\n  x)\n;; => (0 1 2 3 4)\n\n(for/collect (x (in-naturals 10 2) when (< x 20))\n  x)\n;; WARNING: for/collect with in-naturals + when may not terminate!\n;; Use a finite iterator to bound it instead.\n\n;; Combine infinite with finite (stops when shortest ends)\n(for/collect ((i (in-naturals))\n              (ch \"hello\"))\n  (cons i ch))\n;; => ((0 . #\\h) (1 . #\\e) (2 . #\\l) (3 . #\\l) (4 . #\\o))\n\n;; in-indexed: add index to any iterable\n(for/collect ((val idx) (in-indexed '(a b c)))\n  (list idx val))\n;; => ((0 a) (1 b) (2 c))\n\n;; Port iterators\n;; (in-input-lines port)  — iterate lines\n;; (in-input-chars port)  — iterate characters\n;; (in-input-bytes port)  — iterate bytes",
    "notes": "Key differences: in-range takes (end), (start end), or (start end step) and auto-detects direction. in-iota takes (count), (count start), or (count start step) — always count-based. in-naturals is infinite — MUST be bounded by pairing with a finite iterator. When multiple iterators are used in for/collect, iteration stops when the shortest one ends. All three compile to tight loops (no iterator protocol overhead) when used directly in for/for-collect/for-fold.",
    "related": [
      "collect-results-with-for-collect",
      "reduce-with-for-fold"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "path-manipulation-utilities",
    "title": "Path manipulation utilities (string-based, no filesystem)",
    "tags": [
      "path",
      "file",
      "directory",
      "extension",
      "join",
      "subpath",
      "normalize",
      "relative"
    ],
    "imports": [
      ":std/misc/path"
    ],
    "code": "(import :std/misc/path)\n\n;; Join path components\n(subpath \"/home\" \"user\" \"docs\" \"file.txt\")\n;; => \"/home/user/docs/file.txt\"\n\n;; Check if path is under a base\n(subpath? \"/home/user/docs/file.txt\" \"/home/user\")\n;; => #t\n(subpath? \"/etc/passwd\" \"/home/user\")\n;; => #f\n\n;; File extension operations\n(path-extension \"file.txt\")                    ;; => \".txt\"\n(path-strip-extension \"file.txt\")              ;; => \"file\"\n(path-force-extension \"file.txt\" \".md\")        ;; => \"file.md\"\n(path-default-extension \"file\" \".txt\")         ;; => \"file.txt\"\n(path-default-extension \"file.md\" \".txt\")      ;; => \"file.md\" (already has ext)\n\n;; Relative path computation\n(path-enough \"/home/user/docs/file.txt\" \"/home/user\")\n;; => \"docs/file.txt\"\n\n;; Simplify path (remove . and ..)\n(path-simplify \"/home/user/../admin/./docs\")\n;; => \"/home/admin/docs\"\n\n;; Absolute path check\n(path-absolute? \"/home/user\")   ;; => #t\n(path-absolute? \"relative/path\") ;; => #f\n\n;; Gambit built-in (no import needed)\n(path-expand \"~/docs\")            ;; expands ~ to home dir\n(path-normalize \"relative/path\")  ;; resolve to absolute\n(path-directory \"/home/user/file.txt\")  ;; => \"/home/user/\"\n(path-strip-directory \"/home/user/file.txt\")  ;; => \"file.txt\"",
    "notes": ":std/misc/path provides pure string manipulation — no filesystem access. subpath joins components with the OS separator. subpath? checks containment. path-extension includes the dot. path-force-extension replaces any existing extension. path-default-extension only adds if none exists. Gambit also provides path-expand, path-normalize (filesystem-aware), path-directory, and path-strip-directory as built-ins. Use Gambit's for real path resolution, :std/misc/path for string manipulation.",
    "related": [
      "port-utilities-file-io"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "string-utilities-misc",
    "title": "String utility functions: trim, split, substitute, random",
    "tags": [
      "string",
      "trim",
      "split",
      "substitute",
      "replace",
      "prefix",
      "suffix",
      "eol",
      "utility"
    ],
    "imports": [
      ":std/misc/string"
    ],
    "code": "(import :std/misc/string)\n\n;; Remove prefix/suffix\n(string-trim-prefix \"Hello \" \"Hello World\")   ;; => \"World\"\n(string-trim-suffix \".txt\" \"file.txt\")        ;; => \"file\"\n(string-trim-prefix \"X\" \"Hello\")              ;; => \"Hello\" (no match, unchanged)\n\n;; Split on prefix (returns 2 values)\n(defvalues (rest prefix) (string-split-prefix \"http://\" \"http://example.com\"))\n;; rest => \"example.com\", prefix => \"http://\"\n\n;; Trim end-of-line characters\n(string-trim-eol \"hello\\r\\n\")  ;; => \"hello\"\n(string-trim-eol \"hello\\n\")    ;; => \"hello\"\n(string-trim-eol \"hello\\r\")    ;; => \"hello\"\n\n;; String substitution (replace occurrences)\n(string-subst \"old\" \"new\" \"the old old way\")\n;; => \"the new new way\" (replaces all by default)\n\n(string-subst \"old\" \"new\" \"the old old way\" 1)\n;; => \"the new old way\" (count=1, replace first only)\n\n;; Random string generation\n(random-string 16)  ;; => \"a3f7b2c8e1d9f4a0\" (hex chars)\n\n;; str: convert anything to string (like Python's str())\n(str 42)            ;; => \"42\"\n(str 'hello)        ;; => \"hello\"\n(str \"already\")     ;; => \"already\"\n\n;; Lexicographic comparison\n(as-string<? 'apple 'banana)  ;; => #t (compares as strings)\n\n;; Gambit built-ins (no import needed):\n;; (string-contains s1 s2)        — substring search\n;; (string-prefix? pre s)         — check prefix\n;; (string-suffix? suf s)         — check suffix\n;; (string-upcase s)              — uppercase\n;; (string-downcase s)            — lowercase",
    "notes": ":std/misc/string provides common string manipulation beyond R7RS. string-trim-prefix/suffix return the original string unchanged if the prefix/suffix isn't found. string-subst replaces all occurrences by default; pass a count to limit replacements. string-trim-eol handles CR, LF, and CRLF (tries CRLF first). random-string generates random hex characters. str is a generic to-string converter. Gambit provides additional built-ins like string-contains, string-prefix?, string-suffix?.",
    "related": [
      "csv-parsing-options"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "using-typed-access",
    "title": "Optimized typed access with 'using' (no dynamic dispatch)",
    "tags": [
      "using",
      "typed",
      "access",
      "optimization",
      "struct",
      "class",
      "field",
      "slot",
      "inline"
    ],
    "imports": [],
    "code": ";; 'using' tells the compiler the exact type, enabling inlined field access\n;; No import needed — it's a core form\n\n(defstruct point (x y) transparent: #t)\n\n;; Without using: dynamic slot lookup (slower)\n(def (distance-slow p1 p2)\n  (sqrt (+ (expt (- (point-x p1) (point-x p2)) 2)\n           (expt (- (point-y p1) (point-y p2)) 2))))\n\n;; With using: inlined field access (faster, no dispatch)\n(def (distance-fast p1 p2)\n  (using ((p1 :- point) (p2 :- point))\n    (sqrt (+ (expt (- p1.x p2.x) 2)\n             (expt (- p1.y p2.y) 2)))))\n\n;; Dot syntax works with using\n(def (translate p dx dy)\n  (using (p :- point)\n    (make-point (+ p.x dx) (+ p.y dy))))\n\n;; Mutation via set! + using\n(def (move! p dx dy)\n  (using (p :- point)\n    (set! p.x (+ p.x dx))\n    (set! p.y (+ p.y dy))))\n\n;; Using with classes\n(defclass widget (label visible?)\n  transparent: #t)\n\n(def (toggle-visibility! w)\n  (using (w :- widget)\n    (set! w.visible? (not w.visible?))))\n\n;; Using in method bodies for self-access\n(defmethod {area point}\n  (lambda (self)\n    (using (self :- point)\n      (* self.x self.y))))\n\n;; Using with interface types\n(def (print-it (obj : Printable))\n  (using (obj :- Printable)\n    (displayln {obj.to-string})))",
    "notes": "using is a core Gerbil form that provides typed field access. Syntax: (using (var :- Type) body) or (using ((v1 :- T1) (v2 :- T2)) body). Inside using, dot syntax (v.field) compiles to direct struct field access without dynamic dispatch. This is significantly faster in hot loops. set! works with dot syntax inside using for mutation. The type annotation is NOT checked at runtime — it's a promise to the compiler. Wrong types will cause undefined behavior, not errors. Use : (colon) in function signatures for runtime-checked contracts.",
    "related": [
      "interface-contracts"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "list-utilities-advanced",
    "title": "Advanced list utilities: slice, group, split, flatten, duplicates",
    "tags": [
      "list",
      "slice",
      "group",
      "split",
      "flatten",
      "duplicates",
      "unique",
      "butlast",
      "take",
      "drop"
    ],
    "imports": [
      ":std/misc/list"
    ],
    "code": "(import :std/misc/list)\n\n;; Slicing\n(slice '(a b c d e) 1 3)       ;; => (b c d) — from index 1, take 3\n(slice-right '(a b c d e) 1 2) ;; => (d c) — from right, index 1, take 2\n(butlast '(a b c d))           ;; => (a b c) — all but last\n\n;; Flatten nested lists\n(flatten '(1 (2 (3 4) 5) 6))  ;; => (1 2 3 4 5 6) — fully recursive\n(flatten1 '(1 (2 (3 4) 5) 6)) ;; => (1 2 (3 4) 5 6) — one level only\n\n;; Split on predicate\n(split '(1 2 0 3 4 0 5) zero?) ;; => ((1 2) (3 4) (5))\n\n;; Group consecutive equal elements\n(group-consecutive '(1 1 2 2 2 3 1 1))\n;; => ((1 1) (2 2 2) (3) (1 1))\n\n;; Group by N elements\n(group-n-consecutive 3 '(a b c d e f g))\n;; => ((a b c) (d e f) (g))\n\n;; Group by key function\n(group-same '(\"apple\" \"avocado\" \"banana\" \"blueberry\")\n  key: (lambda (s) (string-ref s 0)))\n;; => ((\"apple\" \"avocado\") (\"banana\" \"blueberry\"))\n\n;; Take/drop until predicate\n(take-until even? '(1 3 5 6 7 8))  ;; => (1 3 5) — take while odd\n(drop-until even? '(1 3 5 6 7 8))  ;; => (6 7 8) — drop until even\n\n;; Find duplicates\n(duplicates '(a b c a b a))\n;; => ((a . 3) (b . 2)) — items with count > 1\n\n;; Efficient length checks (short-circuit, no full traversal)\n(length=n? '(a b c) 3)    ;; => #t\n(length<n? '(a b) 5)      ;; => #t\n(length<=n? '(a b c) 2)   ;; => #f\n\n;; Unique (remove duplicates)\n(unique '(3 1 2 1 3 4) =)  ;; => (3 1 2 4)\n\n;; Mutation macros\n(def lst '(1 2 3))\n(push! 0 lst)       ;; lst => (0 1 2 3)\n(pop! lst)           ;; => 0, lst => (1 2 3)",
    "notes": ":std/misc/list provides extensive list utilities beyond SRFI-1. slice is 0-indexed and takes (list start limit). flatten is fully recursive; flatten1 is one level. split divides on predicate matches (like string-split for lists). group-consecutive groups runs of equal adjacent elements. group-same groups by a key function (non-adjacent allowed). length=n?/length<n?/length<=n? are O(min(n,len)) instead of O(len) — use these instead of (= (length lst) n). push!/pop! are mutation macros using set!.",
    "related": [
      "list-builder-efficient-append"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "def-star-multi-arity",
    "title": "Multi-arity function definition with def*",
    "tags": [
      "def*",
      "multi-arity",
      "case-lambda",
      "overload",
      "dispatch",
      "variadic"
    ],
    "imports": [],
    "code": ";; def* defines a function with multiple arities (like case-lambda)\n;; No import needed — it's a core form\n\n(def* my-add\n  ((x) x)                    ;; 1 arg: identity\n  ((x y) (+ x y))            ;; 2 args: add\n  ((x y z) (+ x y z))        ;; 3 args: add three\n  (args (apply + args)))      ;; variadic: add all\n\n(my-add 1)       ;; => 1\n(my-add 1 2)     ;; => 3\n(my-add 1 2 3)   ;; => 6\n(my-add 1 2 3 4) ;; => 10\n\n;; Pattern: optional arguments with different behavior\n(def* connect\n  ((host) (connect host 80))              ;; default port\n  ((host port) (connect host port #f))    ;; default no-ssl\n  ((host port ssl?)\n   (displayln \"Connecting to \" host \":\" port\n              (if ssl? \" (SSL)\" \"\"))))\n\n(connect \"example.com\")          ;; => Connecting to example.com:80\n(connect \"example.com\" 443 #t)   ;; => Connecting to example.com:443 (SSL)\n\n;; Pattern: recursive with base case by arity\n(def* my-map\n  ((f lst) (my-map f lst []))\n  ((f lst acc)\n   (if (null? lst) (reverse acc)\n       (my-map f (cdr lst) (cons (f (car lst)) acc)))))\n\n(my-map 1+ '(1 2 3))  ;; => (2 3 4)",
    "notes": "def* is a core Gerbil form equivalent to defining with case-lambda. Each clause has a parameter list and body. Clauses are tried in order until one matches the call arity. The last clause can be variadic (args without parens) to catch remaining arities. This is cleaner than using optional arguments with defaults when different arities have fundamentally different behavior. def* generates efficient dispatch code.",
    "related": [
      "function-composition-combinators"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "open-process-undocumented-settings",
    "title": "open-process undocumented settings: pseudo-terminal, directory, environment",
    "tags": [
      "open-process",
      "pseudo-terminal",
      "pty",
      "directory",
      "environment",
      "child",
      "process"
    ],
    "imports": [],
    "code": ";; open-process accepts several undocumented/lesser-known settings\n;; beyond the standard path:, arguments:, stdin/stdout/stderr-redirection:\n;; No imports needed — open-process is a Gambit builtin.\n\n;; 1. directory: — set child's working directory\n(let* ((p (open-process (list path: \"/bin/pwd\"\n                              arguments: '()\n                              directory: \"/tmp\"\n                              stdout-redirection: #t)))\n       (cwd (read-line p))\n       (_ (process-status p)))\n  cwd)\n;; => \"/tmp\"\n\n;; 2. environment: — set child's environment (list of \"KEY=val\" strings)\n;; If provided, REPLACES the entire environment (not append!)\n(let* ((p (open-process (list path: \"/usr/bin/env\"\n                              arguments: '()\n                              environment: '(\"FOO=bar\" \"BAZ=quux\")\n                              stdout-redirection: #t)))\n       (lines (let loop ((acc '()))\n                (let ((line (read-line p)))\n                  (if (eof-object? line) (begin (process-status p) (reverse acc))\n                    (loop (cons line acc)))))))\n  lines)\n;; => (\"FOO=bar\" \"BAZ=quux\")\n\n;; 3. pseudo-terminal: #t — allocate a pty for the child\n;; This makes the child think it's running on a real terminal.\n;; Programs that require a tty (less, vim, ssh) will work.\n;; NOTE: Fails with OS exception if no pty is available.\n(with-exception-catcher\n  (lambda (e) (displayln \"pty allocation failed (expected in sandbox)\"))\n  (lambda ()\n    (let ((p (open-process (list path: \"/usr/bin/tty\"\n                                 arguments: '()\n                                 pseudo-terminal: #t\n                                 stdout-redirection: #t))))\n      (let ((tty-name (read-line p)))\n        (process-status p)\n        (displayln \"Child tty: \" tty-name)))))\n;; On real terminal: \"Child tty: /dev/pts/N\"\n\n;; 4. output-width: N — set the port's width (for pretty-printing)\n(let ((p (open-process (list path: \"/bin/echo\" arguments: '(\"ok\")\n                             output-width: 120\n                             stdout-redirection: #t))))\n  (read-line p)\n  (process-status p))",
    "notes": "These settings were verified by testing against Gambit's source code. Key points: (1) environment: REPLACES the entire env, it doesn't merge with the parent's. Pass #f or omit to inherit. (2) pseudo-terminal: #t eliminates the need for FFI openpty/forkpty for most pty use cases — Gambit handles pty allocation internally. (3) directory: lets you avoid cd-ing in the parent just to affect the child. (4) Unknown/misspelled keywords are silently ignored — no error. The child inherits the parent's process group (Gambit does NOT call setpgid).",
    "related": [
      "open-process-stdin-write-read",
      "process-status-decode-waitpid",
      "run-subprocess-custom-env"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "output-port-width-terminal-columns",
    "title": "Get terminal column width with output-port-width (no subprocess needed)",
    "tags": [
      "terminal",
      "columns",
      "width",
      "output-port-width",
      "COLUMNS",
      "tty",
      "size"
    ],
    "imports": [],
    "code": ";; output-port-width returns the terminal column width.\n;; No imports needed — it's a Gambit builtin.\n\n;; Basic usage:\n(output-port-width (current-output-port))\n;; => 80 (default, or actual terminal width on a real tty)\n\n;; On a real terminal, Gambit uses ioctl(TIOCGWINSZ) to get the actual width.\n;; On non-tty ports (files, pipes), it returns the default (80).\n\n;; Useful for shell $COLUMNS variable and line editor wrapping:\n(def (get-terminal-columns)\n  (let ((port (current-output-port)))\n    (if (tty? port)\n      (output-port-width port)\n      80)))\n\n;; NOTE: There is NO output-port-height or equivalent for rows.\n;; For terminal rows, you need either:\n;;   - ioctl(TIOCGWINSZ) via FFI\n;;   - (stty size) via subprocess\n;;   - ANSI escape: write ESC[6n, read cursor position response",
    "notes": "output-port-width is a Gambit builtin (no import needed). Returns terminal columns on a real tty, 80 on non-tty. There is NO height/rows equivalent — only width. For the shell's $COLUMNS, this is sufficient. For $LINES, you'll need ioctl TIOCGWINSZ via FFI or stty subprocess. The width updates automatically when the terminal is resized (Gambit handles SIGWINCH internally).",
    "related": [
      "tty-mode-set-raw-cooked",
      "process-status-decode-waitpid"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "process-times-cpu-usage",
    "title": "Get process CPU times with process-times (for time/times builtins)",
    "tags": [
      "process-times",
      "cpu",
      "time",
      "user",
      "system",
      "real",
      "builtin",
      "times"
    ],
    "imports": [],
    "code": ";; process-times returns an f64vector of 3 elements: user, system, real time.\n;; No imports needed — it's a Gambit builtin.\n\n(let ((t (process-times)))\n  (list 'user:   (f64vector-ref t 0)   ;; user CPU seconds\n        'system: (f64vector-ref t 1)   ;; system CPU seconds  \n        'real:   (f64vector-ref t 2))) ;; wall-clock seconds\n;; => (user: 0.062071 system: 0.017019 real: 0.076280...)\n\n;; Pattern for shell's `time` builtin:\n(def (time-command thunk)\n  (let ((before (process-times)))\n    (thunk)\n    (let ((after (process-times)))\n      (let ((user (- (f64vector-ref after 0) (f64vector-ref before 0)))\n            (sys  (- (f64vector-ref after 1) (f64vector-ref before 1)))\n            (real (- (f64vector-ref after 2) (f64vector-ref before 2))))\n        (fprintf (current-error-port)\n          \"\\nreal\\t~as\\nuser\\t~as\\nsys\\t~as\\n\"\n          real user sys)))))\n\n(time-command (lambda () (thread-sleep! 0.1)))\n;; real  0.1003s\n;; user  0.0001s\n;; sys   0.0000s\n\n;; For shell's `times` builtin (accumulated shell + children times):\n;; process-times gives shell's own times.\n;; ##process-statistics gives a 21-element f64vector with more detail:\n;;   indices 0-2: user/sys/real for the process itself\n;;   indices 3-5: user/sys/real for terminated children",
    "notes": "process-times is a Gambit builtin (no import needed). Returns f64vector(user, system, real) in seconds as floats. For the `time` builtin, measure before/after and subtract. For the `times` builtin, use ##process-statistics which has child process times at indices 3-5. Note: these are cumulative times, not per-command — you must compute deltas yourself.",
    "related": [
      "process-status-decode-waitpid",
      "open-process-undocumented-settings"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "fcntl-f-dupfd-duplicate-fd",
    "title": "Duplicate file descriptor with F_DUPFD via fcntl (partial dup, not dup2)",
    "tags": [
      "fcntl",
      "F_DUPFD",
      "dup",
      "duplicate",
      "fd",
      "file descriptor",
      "redirect"
    ],
    "imports": [
      ":std/os/fcntl",
      ":std/os/fdio",
      ":std/os/pipe"
    ],
    "code": ";; :std/os/fcntl provides F_DUPFD for duplicating file descriptors.\n;; F_DUPFD picks the lowest available fd >= the given minimum.\n;; This is NOT dup2 (which targets a SPECIFIC fd atomically).\n(import :std/os/fcntl :std/os/fdio :std/os/pipe)\n\n;; Create a pipe and duplicate the read end to fd >= 10\n(receive (read-port write-fd) (pipe 'in)\n  (let* ((read-fd 5)  ;; hypothetical; in practice pipe 'none gives raw fds\n         ;; For demo, use the write-fd which IS a raw integer:\n         (new-fd (fcntl write-fd F_DUPFD 10)))\n    ;; new-fd is >= 10, pointing to the same file description as write-fd\n    (displayln \"original: \" write-fd \" new: \" new-fd)\n    ;; Both fds are usable; closing one doesn't affect the other\n    (close new-fd)\n    (close write-fd)\n    (close-port read-port)))\n\n;; Practical example: duplicate a pipe fd to a high range\n(receive (rfd wfd) (pipe 'none)\n  (let ((high-fd (fcntl rfd F_DUPFD 100)))\n    ;; high-fd >= 100, same underlying pipe as rfd\n    (displayln \"low: \" rfd \" high: \" high-fd)\n    ;; => e.g. \"low: 5 high: 100\"\n    (close rfd)\n    (close wfd)\n    (close high-fd)))\n\n;; LIMITATIONS:\n;; - F_DUPFD picks lowest fd >= arg, NOT a specific target fd\n;; - For dup2(old, target) behavior (redirect fd 0/1/2), need FFI\n;; - No F_DUPFD_CLOEXEC available in Gerbil's fcntl exports\n;; - Cannot replace an existing fd atomically (dup2 closes target first)",
    "notes": "F_DUPFD is the only fd duplication available without FFI in Gerbil. It duplicates an fd to the lowest available fd >= the given minimum. This differs from dup2(old, new) which atomically closes 'new' and duplicates 'old' to exactly 'new'. For shell-style redirections (redirecting fd 0, 1, 2 to specific targets), F_DUPFD is insufficient — you need FFI dup2. However, F_DUPFD is useful for moving fds out of the low range (e.g., saving original stdin before redirecting). Missing from Gerbil: F_DUPFD_CLOEXEC (which sets close-on-exec atomically).",
    "related": [
      "os-pipe-create-fd-pair",
      "open-process-undocumented-settings"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "concurrency-pattern-guide",
    "title": "Concurrency pattern decision guide — choose the right primitive",
    "tags": [
      "concurrency",
      "pattern",
      "decision",
      "guide",
      "channel",
      "barrier",
      "completion",
      "atom",
      "rwlock",
      "wg",
      "actor",
      "thread"
    ],
    "imports": [],
    "code": ";; Concurrency Pattern Decision Guide for Gerbil Scheme\n;;\n;; Use case                          → Primitive               → Module\n;; ─────────────────────────────────────────────────────────────────────\n;; Fire-and-forget task              → spawn                   → (builtin)\n;; Multiple producers/consumers      → channel                 → :std/misc/channel\n;; One-shot async result (future)    → completion              → :std/misc/completion\n;; Wait for N tasks to finish        → barrier                 → :std/misc/barrier\n;; Thread pool with task queue       → workgroup (wg)          → :std/misc/wg\n;; Shared mutable state (simple)     → atom                    → :std/misc/atom\n;; Read-heavy shared state           → rwlock                  → :std/misc/rwlock\n;; Message passing / RPC             → actor                   → :std/actor\n;; Race multiple events              → sync/select             → :std/event\n;; Exclusive critical section        → mutex + unwind-protect  → (builtin)\n;;\n;; Quick decision tree:\n;; 1. Need to pass data between threads?\n;;    - Stream of values → channel\n;;    - Single result    → completion\n;; 2. Need to coordinate threads?\n;;    - Wait for all    → barrier or wg\n;;    - Wait for first  → sync/select\n;; 3. Need shared mutable state?\n;;    - Read-heavy      → rwlock\n;;    - Read/write even → atom\n;; 4. Need structured message passing?\n;;    - Request/reply   → actor (->>)\n;;    - Fire-and-forget → actor (->)",
    "notes": "This is a reference guide, not executable code. Each primitive listed here has its own cookbook recipe with working examples. Search for the specific pattern name (e.g., \"channel\", \"barrier\", \"workgroup\") to find detailed examples.",
    "related": [
      "channel-pattern",
      "barrier-synchronization",
      "completion-async-value",
      "workgroup-thread-pool",
      "atom-atomic-reference",
      "rwlock-read-write-lock",
      "actor-message-passing",
      "event-sync-select"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gambit-primitives-inventory",
    "title": "Gambit runtime primitives available without imports",
    "tags": [
      "gambit",
      "builtins",
      "primitives",
      "inventory",
      "discovery",
      "no-import",
      "process",
      "file",
      "environment",
      "terminal"
    ],
    "imports": [],
    "code": ";; Gambit runtime primitives — available without any imports.\n;; These are NOT in :std/* modules; they're from the Gambit runtime.\n;;\n;; ── Process Management ──────────────────────────────────────────\n;; open-process      Create a subprocess (returns a port)\n;;   Settings: path:, arguments:, directory:, environment:,\n;;             stdin-redirection:, stdout-redirection:, stderr-redirection:,\n;;             pseudo-terminal:, output-width:\n;; process-status    Get exit status (blocks until exited); raw waitpid value\n;; process-pid       Get PID of a process port\n;; shell-command     Run a shell command string (returns exit status)\n;;\n;; ── Filesystem ──────────────────────────────────────────────────\n;; file-exists?      Check if file/directory exists\n;; file-info         Get file metadata (like stat): type, mode, size, times\n;; file-info-type    Extract type from file-info (:regular, :directory, etc.)\n;; file-info-size    Extract size from file-info\n;; file-info-mode    Extract permission bits from file-info\n;; rename-file       Rename/move a file (atomic on POSIX)\n;; delete-file       Delete a file\n;; create-directory  Create a directory (mkdir)\n;; delete-directory  Delete an empty directory (rmdir)\n;; directory-files   List directory entries (returns list of strings)\n;; current-directory Get/set current working directory\n;;\n;; ── Path Manipulation ───────────────────────────────────────────\n;; path-normalize       Resolve to absolute path (like realpath)\n;; path-directory       Directory portion (like dirname, with trailing /)\n;; path-strip-directory Filename portion (like basename)\n;; path-extension       File extension (includes dot)\n;; path-strip-extension Remove file extension\n;; path-expand          Expand ~ and environment variables\n;;\n;; ── Environment ─────────────────────────────────────────────────\n;; getenv            Get environment variable (returns #f if unset)\n;; setenv            Set environment variable (Gambit extension)\n;;\n;; ── I/O ─────────────────────────────────────────────────────────\n;; open-input-file   Open file for reading (returns port)\n;; open-output-file  Open file for writing\n;; call-with-input-file   Open, call proc with port, close\n;; call-with-output-file  Open, call proc with port, close\n;; with-input-from-file   Set current-input-port from file\n;; with-output-to-file    Set current-output-port to file\n;; read-line         Read a line from port\n;; read-all          Read all data from port\n;; read-u8           Read a byte\n;; write-u8          Write a byte\n;; display / write / newline / displayln\n;;\n;; ── String I/O ──────────────────────────────────────────────────\n;; open-input-string    Create port from string\n;; open-output-string   Create string accumulator port\n;; get-output-string    Extract string from output port\n;; call-with-output-string  Create string port, call proc, return string\n;; with-output-to-string    Capture display/write output as string\n;;\n;; ── Threading ───────────────────────────────────────────────────\n;; make-thread / thread-start! / thread-join! / thread-yield!\n;; thread-sleep!     Sleep for N seconds (accepts real numbers)\n;; thread-terminate! Terminate a thread (use with-catch around it)\n;; make-mutex / mutex-lock! / mutex-unlock!\n;; make-condition-variable / condition-variable-signal! / condition-variable-broadcast!\n;; current-thread    Get the current thread object\n;;\n;; ── Time ────────────────────────────────────────────────────────\n;; ##current-time    Current time (Gambit time object)\n;; time->seconds     Convert Gambit time to seconds since epoch\n;; seconds->time     Convert seconds to Gambit time\n;;\n;; ── System ──────────────────────────────────────────────────────\n;; ##command-line    Command line arguments as list\n;; exit              Exit the process\n;; error             Raise an error exception",
    "notes": "All of these are Gambit builtins available in any Gerbil program without imports. Some (like setenv) are Gambit extensions not in R7RS. For process management, :std/misc/process provides higher-level wrappers (run-process, filter-with-process). For path manipulation, :std/misc/path provides additional utilities. WARNING: (import :std/srfi/19) shadows time->seconds with an incompatible version that returns a date-component, not epoch seconds.",
    "related": [
      "open-process-settings",
      "directory-listing",
      "gambit-path-builtins",
      "run-external-process"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "hex-escape-semicolon-terminator",
    "title": "Hex escapes in strings require semicolon terminator (\\xNN;)",
    "tags": [
      "hex",
      "escape",
      "string",
      "R7RS",
      "reader",
      "syntax",
      "gotcha"
    ],
    "imports": [],
    "code": ";; WRONG — causes \"Invalid hexadecimal escape\" reader error:\n;; \"\\x1b[K\"    ;; intended: ESC [ K\n;; \"\\x07\"      ;; intended: BEL character\n;; \"\\x0b\"      ;; intended: vertical tab\n\n;; CORRECT — Gerbil/Gambit uses R7RS hex escape syntax with semicolon terminator:\n\"\\x1b;[K\"     ;; ESC [ K  (ANSI clear to end of line)\n\"\\x07;\"       ;; BEL character\n\"\\x0b;\"       ;; vertical tab\n\n;; The semicolon terminates the hex escape, it is NOT a literal character.\n(string-length \"\\x1b;\")   ;; => 1 (just the ESC character)\n(string-length \"\\x1b;[K\") ;; => 3 (ESC, [, K)\n\n;; For ANSI escapes, an alternative is to use (string #\\escape):\n(def ESC-STR (string #\\escape))\n(string-append ESC-STR \"[K\")  ;; equivalent to \"\\x1b;[K\"\n\n;; Or use the character literal directly:\n(string #\\escape #\\[ #\\K)  ;; => \"\\x1b;[K\"",
    "notes": "This is a common gotcha when porting code from other Scheme implementations or C. Most languages use \\xNN without a terminator, but Gerbil/Gambit follows R7RS which requires \\xNN; with a semicolon. Without the semicolon, the reader tries to consume more hex digits and fails with \"Invalid hexadecimal escape\". The alternative (string #\\escape) approach avoids this issue entirely and is more readable for ANSI escape sequences.",
    "related": [
      "tty-mode-set-raw-cooked"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "symbol-reader-special-chars",
    "title": "Symbols with # and , are invalid — use safe names in case/quote",
    "tags": [
      "symbol",
      "reader",
      "quote",
      "hash",
      "comma",
      "unquote",
      "case",
      "gotcha"
    ],
    "imports": [],
    "code": ";; PROBLEM: Some characters are special to the Gerbil reader and cannot\n;; be used in quoted symbols, even inside case clauses.\n\n;; WRONG — these cause reader errors:\n;; '#      ;; # is a reader dispatch character — '# is not a valid datum\n;; '##     ;; same issue\n;; ',      ;; , is unquote — ', becomes (unquote ...)\n;; ',,     ;; double unquote\n\n;; Reader error examples:\n;; (case x ((#) \"hash\"))    ;; Datum expected\n;; (case x ((,) \"comma\"))   ;; reader interprets , as unquote\n;; (case x ((,,) \"dc\"))     ;; Incomplete form, EOF reached\n\n;; CORRECT — use descriptive symbol names instead:\n(case modifier\n  ((prefix-short) \"# — remove shortest prefix\")\n  ((prefix-long)  \"## — remove longest prefix\")\n  ((lc-first)     \", — lowercase first char\")\n  ((lc-all)       \",, — lowercase all chars\")\n  (else \"unknown\"))\n\n;; Characters that WORK fine as symbols:\n'%     ;; => %\n'%%    ;; => %%\n'/     ;; => /\n'//    ;; => //\n'^     ;; => ^\n'^^    ;; => ^^\n':     ;; => :\n':-    ;; => :-\n'+     ;; => +\n'-     ;; => -\n\n;; Characters that DO NOT work as symbols:\n;; '#   — reader dispatch prefix\n;; '##  — Gambit namespace prefix\n;; ',   — unquote\n;; ',,  — double unquote\n;; '`   — quasiquote",
    "notes": "This commonly bites when implementing shell-like DSLs where operators include # and , characters. The workaround is to map these to descriptive symbol names internally (e.g., 'prefix-short for #, 'lc-all for ,,). Character literals (#\\# and #\\,) work fine — the issue is only with quoted symbols.",
    "related": [
      "hex-escape-semicolon-terminator"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "dot-syntax-non-self-class-access",
    "title": "Use explicit accessors (not dot syntax) for non-self class instances",
    "tags": [
      "dot",
      "syntax",
      "slot-ref",
      "class",
      "defclass",
      "accessor",
      "parent",
      "gotcha"
    ],
    "imports": [],
    "code": ";; Inside defmethod, self.field works because self is the class instance.\n;; But other-obj.field can fail during compilation.\n\n(defclass animal (name age) transparent: #t constructor: :init!)\n\n(defmethod {:init! animal}\n  (lambda (self parent: (parent #f))\n    ;; WORKS — self.field is special in defmethod:\n    (set! self.name \"default\")\n    (set! self.age 0)\n\n    ;; MAY FAIL at compile time — parent.name uses unsafe slot-ref:\n    ;; (set! self.name (if parent parent.name \"default\"))\n\n    ;; CORRECT — use the generated accessor function:\n    (set! self.name (if parent (animal-name parent) \"default\"))\n    (set! self.age (if parent (animal-age parent) 0))))\n\n;; General rule:\n;; - self.field      → OK inside defmethod (compiler knows the type)\n;; - (@ obj field)   → OK for dynamic slot access (runtime dispatch)\n;; - (TypeName-field obj) → OK always (generated accessor, no dispatch)\n;; - other-var.field → UNRELIABLE (reader macro, may fail at compile time)\n\n;; For safe access on any variable, use the accessor:\n(def (clone-animal a)\n  (make-animal (animal-name a) (animal-age a)))",
    "notes": "The dot syntax obj.field is a reader macro that expands to (##slot-ref obj 'field) or similar. Inside defmethod bodies, self.field is handled specially by the compiler. For other variables, it uses unsafe slot access that can fail during compilation if the compiler can't verify the type. Always use the defclass/defstruct-generated accessor functions (TypeName-field obj) for non-self access. This is especially important when the variable might be #f (e.g., optional parent parameter).",
    "related": [
      "typed-struct-field-access",
      "use-internal-helper-rebind-conflict"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-qapplication-argc-by-reference",
    "title": "QApplication argc must use static storage (not stack variables)",
    "tags": [
      "qt",
      "qapplication",
      "argc",
      "argv",
      "segfault",
      "by-reference",
      "ffi",
      "c++",
      "static"
    ],
    "imports": [],
    "code": "// PROBLEM: QApplication(int &argc, char **argv) takes argc BY REFERENCE.\n// If you pass a local variable, Qt stores a dangling reference.\n// This causes SIGSEGV in QCoreApplication::arguments() -> strlen()\n// when a window is shown (not during construction!).\n\n// WRONG — argc is a local that goes out of scope:\n// qt_application_t qt_application_create(int argc, char** argv) {\n//     return new QApplication(argc, argv);  // dangling reference!\n// }\n\n// CORRECT — use static storage for argc:\nstatic int    s_argc = 1;\nstatic char   s_arg0[] = \"gerbil-qt\";\nstatic char*  s_argv[] = { s_arg0, nullptr };\n\nextern \"C\" void* qt_application_create(void) {\n    return new QApplication(s_argc, s_argv);\n}\n\n// The crash is deferred — construction works fine, but showing a window\n// triggers QXcbIntegration::wmClass() -> QCoreApplication::arguments()\n// which reads the dangling argc reference -> SIGSEGV in strlen().",
    "notes": "Qt documentation says: \"argc and argv and must remain valid for the entire lifetime of the QApplication object.\" The reference parameter is stored internally. This is a common C++ FFI pitfall because C wrappers typically pass argc by value, but QApplication expects a reference. The segfault is deferred to window show time, making it hard to diagnose. GDB backtrace shows: strlen -> QCoreApplication::arguments -> QXcbIntegration::wmClass -> QXcbWindow::create -> QWidget::show.",
    "related": [
      "gambit-ffi-pointer-types",
      "build-ffi-with-pkg-config"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ffi-const-char-return-cfun-assign-warning",
    "title": "Fix ___CFUN_ASSIGN warning for const char* return types in FFI",
    "tags": [
      "ffi",
      "const",
      "char",
      "return",
      "CFUN_ASSIGN",
      "warning",
      "c-lambda",
      "UTF-8-string"
    ],
    "imports": [
      ":std/foreign"
    ],
    "code": ";; PROBLEM: When a C function returns const char*, binding it with\n;; UTF-8-string return type causes a compiler warning:\n;;\n;;   warning: assignment discards 'const' qualifier from pointer target type\n;;   ___CFUN_ASSIGN(___result, my_get_text(___arg1))\n;;\n;; This is because Gambit's ___CFUN_ASSIGN macro assigns to a char*\n;; variable, but the function returns const char*.\n\n;; WRONG — compiles but produces warning:\n;; (define-c-lambda my_get_text ((pointer void)) UTF-8-string\n;;   \"my_get_text\")\n\n;; CORRECT — use a C wrapper that casts away const:\n(begin-ffi (my_get_text)\n  (c-declare #<<END-C\n#include \"mylib.h\"\n\n/* Wrapper: cast away const to suppress ___CFUN_ASSIGN warning.\n   Safe because Gambit immediately copies into a Scheme string. */\nstatic char* ffi_my_get_text(void* obj) {\n    return (char*)my_get_text(obj);\n}\nEND-C\n  )\n\n  ;; Bind the wrapper, not the original\n  (define-c-lambda my_get_text ((pointer void)) UTF-8-string\n    \"ffi_my_get_text\")\n)",
    "notes": "The cast is safe because Gambit's UTF-8-string handling immediately copies the C string into a Scheme string object — it never writes through the pointer. Without the wrapper, the code works correctly but produces compiler warnings that clutter build output. This pattern is needed for any C function returning const char* when bound with UTF-8-string or char-string return type. Common in Qt (label text getters), GTK, and other C++ libraries with C wrapper APIs.",
    "related": [
      "c-define-char-string-const-mismatch",
      "gambit-ffi-pointer-types"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "hash-literal-symbol-keys-no-quote",
    "title": "Hash literal with symbol keys: do NOT quote keys",
    "tags": [
      "hash",
      "literal",
      "symbol",
      "keys",
      "quote",
      "gotcha",
      "hash-ref"
    ],
    "imports": [],
    "code": ";; GOTCHA: (hash) literal auto-quotes the first element of each pair.\n;; Do NOT add explicit quotes — that creates a LIST key, not a symbol key.\n\n;; WRONG — keys are (quote command) i.e. a 2-element list, not a symbol:\n(def bad (hash ('command #f) ('script #f)))\n(hash-ref bad 'command)  ;; ERROR: UnboundKeyError — key 'command not found!\n;; The actual key is the LIST (quote command), not the SYMBOL command.\n\n;; CORRECT — bare identifiers become symbol keys automatically:\n(def good (hash (command #f) (script #f)))\n(hash-ref good 'command)  ;; => #f — works!\n(hash->list good)  ;; => ((script . #f) (command . #f))\n\n;; For string keys, use string literals:\n(def str-ht (hash (\"name\" \"alice\") (\"age\" 30)))\n(hash-ref str-ht \"name\")  ;; => \"alice\"\n\n;; REMEMBER: hash-put! with symbol keys works fine:\n(hash-put! good 'command \"ls -la\")\n(hash-ref good 'command)  ;; => \"ls -la\"",
    "notes": "The hash literal macro auto-quotes the car of each pair. Writing ('foo val) makes the key (quote foo), a list. Writing (foo val) makes the key 'foo, a symbol. This is a very common source of \"unknown hash key\" errors when initializing hash tables with symbol keys. Use (hash-eq ...) if you specifically want eq? comparison for symbol keys.",
    "related": [
      "hash-table-operations",
      "hash-ref-void-truthy"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "fdopen-three-args",
    "title": "fdopen from :std/os/fd takes 3 arguments: fd, direction, close-on-gc",
    "tags": [
      "fdopen",
      "fd",
      "port",
      "pipe",
      "arity",
      "std/os/fd"
    ],
    "imports": [
      ":std/os/fd",
      ":std/os/fdio",
      ":std/os/fcntl"
    ],
    "code": "(import :std/os/fd :std/os/fdio :std/os/fcntl)\n\n;; fdopen wraps a raw integer fd into a Gambit port.\n;; Signature: (fdopen fd direction close-on-gc?)\n;;   fd          — raw integer file descriptor\n;;   direction   — 'in for input port, 'out for output port\n;;   close-on-gc — #t to close fd when port is GC'd\n\n;; WRONG — only 2 args causes arity mismatch at compile time:\n;; (fdopen read-fd 'in)  ;; ERROR: arity mismatch, expected 3 args\n\n;; CORRECT:\n(let ((fd (open \"/dev/null\" O_RDONLY)))\n  (let ((port (fdopen fd 'in #t)))\n    (input-port? port)  ;; => #t\n    (close-port port)))\n\n;; Typical use with pipe 'none for shell pipelines:\n(import :std/os/pipe)\n(receive (rfd wfd) (pipe 'none)\n  (let ((write-port (fdopen wfd 'out #t))\n        (read-port  (fdopen rfd 'in #t)))\n    (display \"hello\" write-port)\n    (force-output write-port)\n    (close-port write-port)\n    (let ((line (read-line read-port)))\n      (close-port read-port)\n      line)))\n;; => \"hello\"",
    "notes": "fdopen is strictly 3-arity. The third argument (close-on-gc?) should almost always be #t so the fd is cleaned up when the port is garbage collected. Passing #f means you're responsible for closing the fd manually. The direction must be 'in or 'out — there is no 'inout mode for fdopen.",
    "related": [
      "os-pipe-create-fd-pair",
      "open-process-undocumented-settings"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ffi-multi-type-callback-trampolines",
    "title": "Multiple callback trampolines for different signal signatures (void, string, int, bool)",
    "tags": [
      "ffi",
      "callback",
      "trampoline",
      "c-define",
      "signal",
      "multi-type",
      "dispatch",
      "Qt",
      "GUI"
    ],
    "imports": [
      ":std/foreign"
    ],
    "code": ";; PATTERN: When a C library has signals/callbacks with DIFFERENT signatures\n;; (e.g., void(id), void(id, string), void(id, int), void(id, bool)),\n;; use separate dispatch tables and trampolines per signature type.\n;; Shares a single callback ID counter across all tables.\n\n;; Inside begin-ffi:\n\n;; 1. Separate dispatch tables per callback signature\n(define *void-handlers* (make-hash-table))\n(define *string-handlers* (make-hash-table))\n(define *int-handlers* (make-hash-table))\n(define *bool-handlers* (make-hash-table))\n(define *next-callback-id* 0)\n\n;; Register functions return a unique ID across all tables\n(define (register-void-handler! proc)\n  (let ((id *next-callback-id*))\n    (set! *next-callback-id* (+ id 1))\n    (hash-put! *void-handlers* id proc)\n    id))\n\n(define (register-string-handler! proc)\n  (let ((id *next-callback-id*))\n    (set! *next-callback-id* (+ id 1))\n    (hash-put! *string-handlers* id proc)\n    id))\n\n(define (register-int-handler! proc)\n  (let ((id *next-callback-id*))\n    (set! *next-callback-id* (+ id 1))\n    (hash-put! *int-handlers* id proc)\n    id))\n\n(define (register-bool-handler! proc)\n  (let ((id *next-callback-id*))\n    (set! *next-callback-id* (+ id 1))\n    (hash-put! *bool-handlers* id proc)\n    id))\n\n;; 2. Four c-define trampolines — each handles one signature\n(c-define (ffi_void_cb id) (long) void \"ffi_void_cb\" \"\"\n  (let ((h (hash-ref *void-handlers* id #f))) (when h (h))))\n\n(c-define (ffi_string_cb id value) (long UTF-8-string) void \"ffi_string_cb\" \"\"\n  (let ((h (hash-ref *string-handlers* id #f))) (when h (h value))))\n\n(c-define (ffi_int_cb id value) (long int) void \"ffi_int_cb\" \"\"\n  (let ((h (hash-ref *int-handlers* id #f))) (when h (h value))))\n\n(c-define (ffi_bool_cb id value) (long int) void \"ffi_bool_cb\" \"\"\n  (let ((h (hash-ref *bool-handlers* id #f)))\n    (when h (h (not (= value 0))))))  ;; convert C int to Scheme boolean\n\n;; 3. Static C trampolines that forward to the c-define'd functions\n;; (c-declare block — must be in same compilation unit)\n(c-declare #<<END-C\nvoid ffi_void_cb(long id);\nvoid ffi_string_cb(long id, char* value);\nvoid ffi_int_cb(long id, int value);\nvoid ffi_bool_cb(long id, int value);\n\nstatic void void_trampoline(long id) { ffi_void_cb(id); }\nstatic void string_trampoline(long id, const char* v) { ffi_string_cb(id, (char*)v); }\nstatic void int_trampoline(long id, int v) { ffi_int_cb(id, v); }\nstatic void bool_trampoline(long id, int v) { ffi_bool_cb(id, v); }\n\n/* C wrapper connects a specific signal to the appropriate trampoline */\n/* Example: button clicked → void trampoline */\nstatic void ffi_connect_clicked(void* btn, long id) {\n    my_button_on_clicked(btn, void_trampoline, id);\n}\n/* Example: text changed → string trampoline */\nstatic void ffi_connect_text_changed(void* edit, long id) {\n    my_edit_on_text_changed(edit, string_trampoline, id);\n}\nEND-C\n)\n\n;; 4. Bind the connection wrappers\n(define-c-lambda raw_connect_clicked ((pointer void) long) void \"ffi_connect_clicked\")\n(define-c-lambda raw_connect_text_changed ((pointer void) long) void \"ffi_connect_text_changed\")\n\n;; === High-level usage ===\n;; (def (on-clicked! button handler)\n;;   (raw_connect_clicked button (register-void-handler! handler)))\n;;\n;; (def (on-text-changed! edit handler)\n;;   (raw_connect_text_changed edit (register-string-handler! handler)))\n;;\n;; (on-clicked! my-btn (lambda () (displayln \"clicked!\")))\n;; (on-text-changed! my-edit (lambda (text) (displayln \"text: \" text)))",
    "notes": "Extends the single-dispatch-table recipe to handle C libraries (like Qt, GTK) where different signals have different callback signatures. Key points: (1) Share one ID counter across all tables so IDs never collide. (2) The bool trampoline takes int from C and converts to Scheme boolean with (not (= value 0)). (3) Forward declarations for c-define use char* not const char* (Gambit generates char*). (4) Static trampolines cast const char* → char* to bridge the C library's const signatures to Gambit's char* c-define. (5) Each signal connection gets its own C wrapper that passes the right trampoline.",
    "related": [
      "ffi-callback-dispatch-table",
      "c-define-char-string-const-mismatch",
      "ffi-cfun-assign-const-char-fix"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "tty-mode-set-six-args",
    "title": "tty-mode-set! takes 6 arguments, not 5 (port + 4 bools + speed)",
    "tags": [
      "tty-mode-set!",
      "terminal",
      "raw",
      "cooked",
      "arity",
      "six",
      "speed"
    ],
    "imports": [],
    "code": ";; GOTCHA: tty-mode-set! takes 6 arguments, not 5.\n;; The internal ##tty-mode-set! reveals the true signature:\n;;   (tty-mode-set! port allow-special echo output-raw input-raw speed)\n;; The 6th argument is a speed/flags parameter — use 0 for default.\n;;\n;; Evidence from Gambit source (lib/std/misc/ports~0.scm):\n;;   (##tty-mode-set! port '#f '#f '#t '#t '0)  ;; raw mode\n;;   (##tty-mode-set! port '#t '#t '#f '#f '0)  ;; cooked mode\n\n;; WRONG — only 5 args, will throw arity error or silently fail:\n;; (tty-mode-set! port #t #f #f #t)\n\n;; CORRECT — 6 args including speed=0:\n;; Raw mode (for line editor):\n(tty-mode-set! (current-input-port) #t #f #f #t 0)\n\n;; Cooked mode (restore):\n(tty-mode-set! (current-input-port) #t #t #f #f 0)\n\n;; Fully raw (no signal processing):\n(tty-mode-set! (current-input-port) #f #f #t #t 0)\n\n;; Safe pattern with dynamic-wind:\n(def (with-raw-terminal thunk)\n  (let ((port (current-input-port)))\n    (dynamic-wind\n      (lambda () (tty-mode-set! port #t #f #f #t 0))\n      thunk\n      (lambda () (tty-mode-set! port #t #t #f #f 0)))))",
    "notes": "The existing cookbook recipe \"tty-mode-set-raw-cooked\" shows 5 args — that is WRONG for Gerbil v0.19+. gerbil_doc reports arity:6 for tty-mode-set!. The 6th argument (speed) should be 0 for default. Discovered by examining Gambit's own std/misc/ports module which uses ##tty-mode-set! with 6 args including a trailing '0. Without the 6th arg, the call may silently fail or throw a type exception, leaving the terminal in an unexpected state.",
    "related": [
      "tty-mode-set-raw-cooked"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "signal-handler-zero-arity-callback",
    "title": "add-signal-handler! callback takes 0 arguments, not 1",
    "tags": [
      "signal",
      "handler",
      "callback",
      "arity",
      "zero",
      "add-signal-handler!"
    ],
    "imports": [
      ":std/os/signal",
      ":std/os/signal-handler"
    ],
    "code": "(import :std/os/signal :std/os/signal-handler)\n\n;; GOTCHA: The callback passed to add-signal-handler! takes ZERO arguments.\n;; The signal number is NOT passed to the handler.\n;;\n;; The existing cookbook recipe shows (lambda (sig) ...) — that is WRONG\n;; and causes: \"Wrong number of arguments passed to procedure\"\n\n;; WRONG — handler takes 1 arg:\n;; (add-signal-handler! SIGINT (lambda (sig) (displayln \"caught\")))\n;; => ERROR at runtime: Wrong number of arguments passed to procedure\n\n;; CORRECT — handler takes 0 args:\n(add-signal-handler! SIGINT (lambda () (displayln \"caught SIGINT\")))\n\n;; Example: flag signals for later processing\n(def *pending* [])\n\n(add-signal-handler! SIGINT\n  (lambda () (set! *pending* (cons \"INT\" *pending*))))\n\n(add-signal-handler! SIGTERM\n  (lambda () (set! *pending* (cons \"TERM\" *pending*))))\n\n;; Ignore a signal:\n(add-signal-handler! SIGPIPE (lambda () #!void))\n\n;; Remove handler:\n(remove-signal-handler! SIGINT)",
    "notes": "The existing recipe \"signal-handler-register-remove\" shows (lambda (sig) ...) with 1 arg — that is WRONG. The signal dispatcher in :std/os/signal-handler calls the callback with zero arguments. The error message is: \"Wrong number of arguments passed to procedure (#<procedure>)\" and appears asynchronously in the signal-handler-wait thread. Discovered by debugging gsh shell where all signal handlers were failing at runtime.",
    "related": [
      "signal-handler-register-remove"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "c-ffi-isatty-returns-int-not-bool",
    "title": "C FFI isatty returns int (1=true, 0=false); 0 is truthy in Gerbil",
    "tags": [
      "ffi",
      "isatty",
      "truthy",
      "zero",
      "int",
      "boolean",
      "C"
    ],
    "imports": [],
    "code": ";; GOTCHA: C functions bound via c-lambda that return int for boolean\n;; values return 0/1 integers, not #f/#t. In Gerbil, 0 is TRUTHY!\n;; Only #f is falsy.\n\n;; Example FFI binding:\n;; (define-c-lambda ffi-isatty (int) int \"isatty\")\n\n;; WRONG — 0 is truthy, so this is always true:\n;; (if (ffi-isatty 0)\n;;   (displayln \"is a tty\")     ;; ALWAYS taken, even for pipes!\n;;   (displayln \"not a tty\"))\n\n;; CORRECT — compare against 1 explicitly:\n;; (if (= (ffi-isatty 0) 1)\n;;   (displayln \"is a tty\")\n;;   (displayln \"not a tty\"))\n\n;; General pattern for C boolean results:\n;; (def (isatty? fd) (= (ffi-isatty fd) 1))\n\n;; This applies to ALL C functions returning int as boolean:\n;;   isatty(), access(), tcsetattr(), etc.\n;; Always compare with = 1 or wrap in a Scheme predicate.",
    "notes": "This is a subtle but critical bug source. In C, 0 is false and non-zero is true. In Gerbil, only #f is false — 0 is truthy. When binding C functions that return int-as-boolean via c-lambda, you MUST explicitly check (= result 1) or (not (zero? result)). Discovered while debugging gsh: ffi-isatty returned 0 for a pipe, but the shell still entered interactive mode because 0 is truthy.",
    "related": [
      "hash-ref-void-truthy"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "fd-e-extract-raw-fd-from-port",
    "title": "Extract raw integer fd from a Gambit port using fd-e from :std/os/fd",
    "tags": [
      "fd",
      "fd-e",
      "port",
      "file-descriptor",
      "raw-fd",
      "extract",
      "integer"
    ],
    "imports": [
      ":std/os/fd",
      ":std/os/fdio",
      ":std/os/fcntl"
    ],
    "code": ";; fd-e from :std/os/fd extracts the raw integer file descriptor from a Gambit port.\n;; This is essential when you need to pass fds to FFI functions like dup2.\n(import :std/os/fd :std/os/fdio :std/os/fcntl)\n\n;; open from :std/os/fdio returns a Gambit PORT (not a raw integer fd):\n(let ((port (open \"/dev/null\" O_RDONLY)))\n  (list (input-port? port)    ;; => #t  (it's a port!)\n        (fd-e port)           ;; => 5   (the raw integer fd)\n        (fd-type port)))      ;; => file\n;; => (#t 5 file)\n\n;; Typical use case: open a file, get its raw fd for dup2\n(let* ((port (open \"/tmp/output.txt\" (bitwise-ior O_WRONLY O_CREAT O_TRUNC) #o644))\n       (raw-fd (fd-e port)))\n  ;; raw-fd is an integer, usable with FFI dup2\n  (list raw-fd (integer? raw-fd)))\n;; => (5 #t)\n\n;; CAUTION: Gambit still owns the port.\n;; - close-port will close the underlying fd\n;; - If port is GC'd and close-on-gc is set, the fd gets closed\n;; - After dup2(raw-fd, target-fd), closing raw-fd via the port\n;;   does NOT affect the dup'd target-fd\n\n;; Pattern for shell redirections (redirect stdout to a file):\n;; 1. Open file → get port → extract raw fd\n;; 2. dup2(raw-fd, 1) to redirect stdout\n;; 3. close-port the original port (fd 1 still points to the file)\n;; 4. (Gambit builtins: also set current-output-port)",
    "notes": "fd-e is exported from :std/os/fd alongside fdopen, fd-type, and fd-io. fd-type returns a symbol like 'file, 'pipe, 'socket. The open function from :std/os/fdio accepts 2 or 3 args: (open path flags) or (open path flags mode). It always returns a Gambit port, not a raw fd. This is different from C's open() which returns an int. Use fd-e to bridge from Gambit's port world to the raw fd world needed for FFI calls like dup2, dup, close, etc.",
    "related": [
      "fdopen-3-arity",
      "os-pipe-create-fd-pair",
      "fcntl-f-dupfd-partial-dup"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-offscreen-headless-testing",
    "title": "Run Qt FFI tests headless with QT_QPA_PLATFORM=offscreen",
    "tags": [
      "qt",
      "test",
      "headless",
      "offscreen",
      "makefile",
      "segfault",
      "QT_QPA_PLATFORM"
    ],
    "imports": [],
    "code": ";; Qt6 requires a display to create widgets. For headless testing,\n;; set QT_QPA_PLATFORM=offscreen to use Qt's offscreen plugin.\n;; No xvfb-run needed.\n;;\n;; IMPORTANT: The offscreen plugin causes a benign SIGSEGV at process exit\n;; (after all tests complete and results are reported). This means the\n;; process exits with code 139 even though all tests passed.\n;;\n;; Makefile pattern to handle this:\n;;\n;; test: build\n;; \t@QT_QPA_PLATFORM=offscreen LD_LIBRARY_PATH=$(CURDIR)/vendor:$$LD_LIBRARY_PATH \\\n;; \t\tgerbil test ./... > /tmp/gerbil-qt-test.log 2>&1 || true; \\\n;; \tcat /tmp/gerbil-qt-test.log; \\\n;; \tif grep -q \"FAILURE\" /tmp/gerbil-qt-test.log; then \\\n;; \t\texit 1; \\\n;; \tfi\n;;\n;; This captures output, ignores the exit code, displays results,\n;; and only fails if gerbil test actually reported FAILURE.\n;;\n;; Test file pattern — create QApplication once, share across tests:\n\n(import :std/test :my-project/qt)\n(export qt-test)\n\n(def test-app #f)\n(def (ensure-app!)\n  (unless test-app\n    (set! test-app (qt-app-create))))\n\n(def qt-test\n  (test-suite \"qt\"\n    (test-case \"app create\"\n      (ensure-app!)\n      (check (not (eq? test-app #f)) => #t))\n\n    (test-case \"label round-trip\"\n      (let ((l (qt-label-create \"hello\")))\n        (check (qt-label-text l) => \"hello\")\n        (qt-widget-destroy! l)))\n\n    ;; Do NOT destroy app — let process exit handle it.\n    ;; Explicit qt-app-destroy! can cause double-free with offscreen.\n  ))",
    "notes": "Qt's offscreen platform plugin (qt6-base-dev includes it on Ubuntu) creates a minimal rendering backend without a display server. The SIGSEGV at exit is a known Qt issue with the offscreen plugin during QApplication destruction — it happens after all test reporting is complete. Do NOT explicitly call qt-app-destroy! in test cleanup when using offscreen — it can cause the segfault to happen mid-test instead of at exit. The Makefile pattern checks for the string \"FAILURE\" in gerbil test output rather than relying on exit code, which elegantly handles the benign crash.",
    "related": [
      "write-tests-with-std-test",
      "ffi-callback-dispatch-table",
      "qt-application-argc-static"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ffi-signal-wrapper-returns-void",
    "title": "FFI signal connection wrappers return void — don't test return value",
    "tags": [
      "ffi",
      "callback",
      "signal",
      "void",
      "return",
      "test",
      "qt",
      "gtk"
    ],
    "imports": [],
    "code": ";; GOTCHA: When wrapping C signal-connection functions, the high-level\n;; wrapper typically calls a void C function as its last expression.\n;; In Scheme, this returns #!void — NOT the callback ID.\n;;\n;; Example:\n;; (def (qt-on-clicked! button handler)\n;;   (let ((id (register-qt-void-handler! handler)))\n;;     (raw_qt_push_button_on_clicked button id)))\n;;     ;; ^^^ this is a void c-lambda — returns #!void, not id\n;;\n;; WRONG in tests:\n;; (let ((id (qt-on-clicked! btn (lambda () #t))))\n;;   (check (number? id) => #t))   ;; FAILS: id is #!void\n;;\n;; CORRECT — just verify no crash:\n;; (qt-on-clicked! btn (lambda () #t))\n;; ;; no assertion on return value\n;;\n;; If you NEED the callback ID returned, restructure:\n;; (def (qt-on-clicked! button handler)\n;;   (let ((id (register-qt-void-handler! handler)))\n;;     (raw_qt_push_button_on_clicked button id)\n;;     id))  ;; <-- explicitly return id",
    "notes": "This bites you when writing tests for FFI callback registration. The register-*-handler! function returns an integer ID, but the void c-lambda called after it returns #!void, which becomes the return value of the let form. (number? #!void) => #f. Fix either by adding an explicit return of id, or by not asserting on the return value in tests. The pattern affects any wrapper where register → connect is done in a let body.",
    "related": [
      "ffi-callback-dispatch-table",
      "multiple-callback-trampolines",
      "write-tests-with-std-test"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "character-port-from-raw-fd-via-dev-fd",
    "title": "Create Gambit character port from raw fd via /dev/fd/N",
    "tags": [
      "fd",
      "port",
      "character",
      "raw",
      "dev",
      "redirect",
      "pipe",
      "display",
      "write"
    ],
    "imports": [],
    "code": ";; fdopen from :std/os/fd creates BYTE ports, which CANNOT be used with\n;; display, write-char, read-char, read-line, etc. (causes type-exception).\n;; Instead, use /dev/fd/N to create proper Gambit character ports from raw fds.\n;; This works on Linux (and most Unix systems).\n\n;; Example: create read/write character ports from pipe fds\n;; (Assuming ffi-pipe-raw returns two raw integer fds)\n(import :gsh/ffi)  ;; for ffi-pipe-raw\n\n(let-values (((read-fd write-fd) (ffi-pipe-raw)))\n  ;; Create a character output port for the write end\n  (let ((out (open-output-file (string-append \"/dev/fd/\" (number->string write-fd)))))\n    (display \"hello from pipe\" out)  ;; display works!\n    (newline out)\n    (force-output out)\n    (close-port out))\n  (ffi-close-fd write-fd)  ;; close raw fd too\n\n  ;; Create a character input port for the read end\n  (let ((in (open-input-file (string-append \"/dev/fd/\" (number->string read-fd)))))\n    (let ((line (read-line in)))  ;; read-line works!\n      (close-port in)\n      (ffi-close-fd read-fd)\n      line)))\n;; => \"hello from pipe\"\n\n;; WRONG — fdopen creates byte ports that fail with display:\n;; (let ((p (fdopen write-fd 'out #t)))\n;;   (display \"hello\" p))  ;; ERROR: Character OUTPUT PORT expected\n\n;; This pattern is essential for:\n;; - Shell command substitution (capture stdout via pipe)\n;; - Shell pipeline builtins (set current-output-port to pipe)\n;; - Any case where Gambit's display/read-line needs to use a raw fd",
    "notes": "fdopen from :std/os/fd creates Gerbil byte ports (raw I/O), but Gambit's standard I/O functions (display, write, read-char, read-line) require character ports. The /dev/fd/N virtual filesystem on Linux lets you create a proper Gambit character port from any open raw fd. Always close both the Gambit port AND the raw fd when done. This pattern was discovered while implementing shell command substitution and pipeline support.",
    "related": [
      "fd-e-extract-raw-fd-from-port",
      "fdopen-3-arity",
      "os-pipe-create-fd-pair"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "break-circular-import-with-make-parameter",
    "title": "Break circular imports with make-parameter callback",
    "tags": [
      "circular",
      "import",
      "dependency",
      "parameter",
      "callback",
      "module"
    ],
    "imports": [],
    "code": ";; Problem: module A needs to call a function from module B,\n;; but module B imports module A — circular dependency.\n;;\n;; Solution: use make-parameter as a callback slot in a shared module.\n;; The \"upper\" module sets the parameter at startup.\n\n;; --- shared.ss (imported by both) ---\n;; (export #t)\n;; (def *execute-fn* (make-parameter #f))\n\n;; --- lower.ss (needs to call the function) ---\n;; (import :mypackage/shared)\n;; (def (do-eval input env)\n;;   (let ((exec-fn (*execute-fn*)))\n;;     (if exec-fn\n;;       (exec-fn input env)\n;;       (error \"executor not initialized\"))))\n\n;; --- upper.ss (defines the function, imports lower.ss) ---\n;; (import :mypackage/shared :mypackage/lower)\n;; (def (execute-input input env)\n;;   ... uses lower.ss functions ...)\n;;\n;; ;; At startup, wire the callback:\n;; (*execute-fn* (lambda (input env) (execute-input input env)))\n\n;; This pattern is essential for shells, REPLs, and plugin systems\n;; where eval/source/command-substitution need to call back into\n;; the main executor without creating circular imports.",
    "notes": "The key insight is that make-parameter creates a thread-local mutable binding that can be set at runtime, breaking the compile-time circular dependency. The parameter starts as #f and gets set during initialization. Always check for #f before calling to handle the case where init hasn't run yet. This is the standard Scheme pattern for dependency inversion.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ffi-posix-syscall-begin-ffi",
    "title": "Wrap POSIX syscalls (dup, dup2, open, close, pipe) via begin-ffi",
    "tags": [
      "ffi",
      "begin-ffi",
      "posix",
      "syscall",
      "dup2",
      "open",
      "close",
      "pipe",
      "c-lambda",
      "c-declare"
    ],
    "imports": [
      ":std/foreign"
    ],
    "code": ";; Gerbil lacks built-in dup2, raw open(), and waitpid with WUNTRACED.\n;; Use begin-ffi + c-declare + define-c-lambda to wrap POSIX libc calls.\n\n(import :std/foreign)\n\n(begin-ffi (ffi-dup ffi-dup2 ffi-close-fd ffi-open-raw ffi-isatty)\n\n  ;; Include required C headers in c-declare with heredoc syntax\n  (c-declare #<<END-C\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\nEND-C\n  )\n\n  ;; Simple 1:1 wrappers — just name the C function\n  (define-c-lambda ffi-dup (int) int \"dup\")\n  (define-c-lambda ffi-dup2 (int int) int \"dup2\")\n  (define-c-lambda ffi-close-fd (int) int \"close\")\n  (define-c-lambda ffi-isatty (int) int \"isatty\")\n\n  ;; C's open() — returns raw integer fd (not a Gambit port!)\n  ;; flags: O_RDONLY=0, O_WRONLY=1, O_RDWR=2\n  ;;        O_CREAT=64, O_TRUNC=512, O_APPEND=1024 (Linux)\n  ;; mode: file permission bits e.g. #o666\n  (define-c-lambda ffi-open-raw (char-string int int) int \"open\")\n)\n\n;; Usage: open a file, dup2 onto stdout, then restore\n;; (let ((saved (ffi-dup 1)))          ;; save real fd 1\n;;   (let ((fd (ffi-open-raw \"/tmp/out.txt\"\n;;               (bitwise-ior 1 64 512)  ;; O_WRONLY|O_CREAT|O_TRUNC\n;;               #o666)))\n;;     (ffi-dup2 fd 1)                  ;; redirect stdout to file\n;;     (ffi-close-fd fd))               ;; close extra fd\n;;   ;; ... run command (inherits redirected fd 1) ...\n;;   (ffi-dup2 saved 1)                 ;; restore stdout\n;;   (ffi-close-fd saved))              ;; close saved copy\n\n;; For multi-value returns (e.g. waitpid), use static vars + helper:\n;; (c-declare \"static int _status; ...\")\n;; (define-c-lambda _do_waitpid (int int) int \"ffi_do_waitpid\")\n;; (define-c-lambda _get_status () int \"ffi_get_status\")",
    "notes": "Key points: (1) begin-ffi's first arg is the list of Scheme symbols to export from the FFI block. (2) c-declare uses Gambit's heredoc syntax #<<TAG ... TAG for multi-line C code. (3) define-c-lambda maps Scheme types to C: int↔int, char-string↔const char*. (4) For functions returning multiple values (like waitpid with status), use C static vars and multiple c-lambda getters. (5) MUST include <fcntl.h> for open(), otherwise you get 'implicit declaration' warnings. (6) O_* flag values are Linux-specific — for portability, define them in C code using the actual macros.",
    "related": [
      "fd-e-extract-raw-fd-from-port",
      "character-port-from-raw-fd-via-dev-fd",
      "fcntl-f-dupfd-partial-dup"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "pipeline-fd-closing-pattern",
    "title": "Pipeline fd management: close write-end in parent to avoid hangs",
    "tags": [
      "pipeline",
      "pipe",
      "fd",
      "close",
      "hang",
      "EOF",
      "dup2",
      "parent",
      "child"
    ],
    "imports": [],
    "code": ";; CRITICAL PATTERN: When implementing cmd1 | cmd2, the parent process\n;; must close its copy of the pipe write-end IMMEDIATELY after launching\n;; the producer (cmd1). Otherwise cmd2 never sees EOF and hangs forever.\n;;\n;; WRONG — hangs:\n;; (let-values (((rfd wfd) (pipe-raw)))\n;;   (launch cmd1 with stdout→wfd)\n;;   (launch cmd2 with stdin→rfd)\n;;   ;; Parent still holds wfd open!\n;;   ;; cmd2 reads from rfd, never gets EOF, HANGS\n;;   (close wfd)   ;; too late — cmd2 is already blocking\n;;   (close rfd))\n;;\n;; CORRECT — works:\n;; (let-values (((rfd wfd) (pipe-raw)))\n;;   ;; Save original fds\n;;   (let ((saved-stdout (ffi-dup 1)))\n;;     ;; Redirect stdout to pipe write-end\n;;     (ffi-dup2 wfd 1)\n;;     (ffi-close-fd wfd)           ;; close original wfd in parent\n;;     ;; Launch cmd1 (inherits redirected fd 1)\n;;     (launch-cmd1)\n;;     ;; Restore stdout\n;;     (ffi-dup2 saved-stdout 1)\n;;     (ffi-close-fd saved-stdout))\n;;   ;; Now only cmd1 holds the write-end — when cmd1 exits, cmd2 gets EOF\n;;   (let ((saved-stdin (ffi-dup 0)))\n;;     (ffi-dup2 rfd 0)\n;;     (ffi-close-fd rfd)           ;; close original rfd in parent\n;;     (launch-cmd2)\n;;     (ffi-dup2 saved-stdin 0)\n;;     (ffi-close-fd saved-stdin))\n;;   (wait-for-both))\n;;\n;; The key insight: after dup2(wfd, 1), the pipe write-end is now fd 1.\n;; Closing the original wfd means only the child process (cmd1) holds\n;; the write-end. When cmd1 exits, its fd 1 closes, and cmd2 gets EOF.\n;;\n;; For N-command pipelines: create N-1 pipes upfront, close each pipe's\n;; write-end right after launching the command that writes to it, and\n;; close each pipe's read-end right after launching the command that\n;; reads from it. Use set-car!/set-cdr! or similar to track which fds\n;; have been closed to avoid double-close.",
    "notes": "This is the #1 cause of pipeline hangs in shell implementations. The POSIX rule: a pipe read returns EOF only when ALL write-end file descriptors are closed. If the parent process forks a child and doesn't close its own copy of the write-end, the pipe has 2 writers (parent + child), so closing just the child's copy on exit still leaves the parent's copy open. The reader blocks forever. The dup2 approach (dup2 pipe-fd onto 0/1, then close the original) is cleaner than trying to pass extra fds to children, especially since Gambit's open-process closes all fds > 2 in the child.",
    "related": [
      "os-pipe-create-fd-pair",
      "ffi-posix-syscall-begin-ffi",
      "character-port-from-raw-fd-via-dev-fd"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "unix-timestamp-to-formatted-date",
    "title": "Convert Unix timestamp to formatted date string via SRFI-19",
    "tags": [
      "srfi-19",
      "unix",
      "timestamp",
      "date",
      "format",
      "make-time",
      "time-utc->date"
    ],
    "imports": [
      ":std/srfi/19"
    ],
    "code": "(import :std/srfi/19)\n\n;; Convert a Unix timestamp (integer seconds) to a formatted date string.\n;; Three steps: make-time -> time-utc->date -> date->string\n\n;; Basic pattern:\n(def (format-unix-timestamp unix-ts fmt)\n  (let* ((secs (inexact->exact (floor unix-ts)))\n         (t (make-time time-utc 0 secs))       ;; make-time takes: type nanoseconds seconds\n         (d (time-utc->date t 0)))              ;; 0 = UTC offset\n    (date->string d fmt)))\n\n;; Examples:\n(format-unix-timestamp 1609459200 \"~H:~M\")        ;; => \"00:00\"\n(format-unix-timestamp 1609459200 \"~b ~d\")         ;; => \"Jan 01\"\n(format-unix-timestamp 1609459200 \"~m/~d ~H:~M\")  ;; => \"01/01 00:00\"\n(format-unix-timestamp 1609459200 \"~Y-~m-~d\")      ;; => \"2021-01-01\"\n\n;; Adaptive time axis formatter (choose format based on data range):\n(def (make-time-format-fn range-seconds)\n  (let ((fmt (cond\n               ((>= range-seconds (* 365 86400)) \"~b ~d\")       ;; >= 1 year\n               ((>= range-seconds (* 30 86400))  \"~b ~d\")       ;; >= 30 days\n               ((>= range-seconds (* 7 86400))   \"~m/~d\")       ;; >= 7 days\n               ((>= range-seconds 86400)          \"~m/~d ~H:~M\") ;; >= 1 day\n               (else                              \"~H:~M\"))))    ;; < 1 day\n    (lambda (unix-ts)\n      (format-unix-timestamp unix-ts fmt))))",
    "notes": "make-time arity is 3: (make-time type nanoseconds seconds). time-utc->date arity is 2: (time-utc->date time tz-offset). The tz-offset 0 means UTC. If SRFI-19 is imported and you also need Gambit's current-time, use ##current-time to bypass the shadow. Common format directives: ~Y (4-digit year), ~m (2-digit month), ~d (2-digit day), ~H (24h hour), ~M (minute), ~b (abbreviated month name like \"Jan\").",
    "related": [
      "date-time-formatting-srfi-19",
      "srfi-19-current-time-shadows-gambit",
      "current-time-seconds"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "format-tilde-escape-pitfall",
    "title": "std/format uses tilde as escape — avoid tilde in dynamic strings",
    "tags": [
      "format",
      "tilde",
      "escape",
      "string-append",
      "promql",
      "hang",
      "freeze"
    ],
    "imports": [
      ":std/format"
    ],
    "code": "(import :std/format)\n\n;; Gerbil's (format) from :std/format uses ~ as the escape character.\n;; If your format string contains literal tildes, format will try to\n;; interpret them as directives and may HANG or crash.\n\n;; WRONG — hangs/crashes because ~\" is interpreted as a format directive:\n;; (format \"{__name__=~\\\"~a.*\\\"}\" \"node_\")  ;; HANGS!\n\n;; WRONG — even ~~ (literal tilde) before a quote can cause issues:\n;; (format \"{__name__=~~\\\"~a.*\\\"}\" \"node_\")  ;; may still hang\n\n;; CORRECT — use string-append instead when the template contains tildes:\n(string-append \"{__name__=~\\\"\" \"node_\" \".*\\\"}\")\n;; => \"{__name__=~\\\"node_.*\\\"}\"\n\n;; RULE OF THUMB:\n;; - Use (format \"~a ~a\" x y) for simple value interpolation\n;; - Use string-append when the template itself contains ~ characters\n;;   (common in PromQL regex match syntax: =~ )\n;; - ~~ produces a literal tilde, but mixing with quotes can confuse the parser\n\n;; Safe format usage:\n(format \"value: ~a, count: ~a\" 42 10)  ;; => \"value: 42, count: 10\"\n(format \"~aK\" 1.5)                      ;; => \"1.5K\"\n(format \"~ae~a\" 1.2 6)                  ;; => \"1.2e6\"",
    "notes": "This is especially dangerous because format may silently hang rather than error, making it hard to diagnose. PromQL queries commonly use =~ for regex matching, which conflicts with format's ~ escape. Always prefer string-append for building query strings that may contain special characters.",
    "related": [
      "string-subst-argument-order"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "sort-filter-not-builtin",
    "title": "sort, filter, delete-duplicates require imports — not builtins",
    "tags": [
      "sort",
      "filter",
      "delete-duplicates",
      "import",
      "builtin",
      "srfi-1",
      "std/sort"
    ],
    "imports": [
      ":std/sort",
      ":std/srfi/1"
    ],
    "code": ";; Common list operations that are NOT builtins and require explicit imports:\n\n;; sort — requires :std/sort\n(import :std/sort)\n(sort '(3 1 2) <)                       ;; => (1 2 3)\n(sort '(\"c\" \"a\" \"b\") string<?)          ;; => (\"a\" \"b\" \"c\")\n\n;; filter — requires :std/srfi/1\n(import :std/srfi/1)\n(filter odd? '(1 2 3 4 5))             ;; => (1 3 5)\n(delete-duplicates '(\"a\" \"b\" \"a\") equal?)  ;; => (\"a\" \"b\")\n\n;; If you want to avoid importing :std/srfi/1 for a one-off dedup,\n;; use a hash-table-based manual approach:\n(def (dedup-strings lst)\n  (let ((seen (make-hash-table)))\n    (let loop ((rest lst) (acc []))\n      (cond\n        ((null? rest) (reverse acc))\n        ((hash-get seen (car rest))\n         (loop (cdr rest) acc))\n        (else\n         (hash-put! seen (car rest) #t)\n         (loop (cdr rest) (cons (car rest) acc)))))))\n(dedup-strings '(\"a\" \"b\" \"a\" \"c\"))  ;; => (\"a\" \"b\" \"c\")\n\n;; THESE ARE builtins (no import needed):\n;; map, for-each, append, reverse, length, assoc, member,\n;; list->vector, vector->list, string->list, list->string,\n;; apply, values, call-with-values, make-hash-table, hash-put!, hash-get,\n;; iota, create-directory*",
    "notes": "This is a common gotcha — sort and filter feel like they should be builtins but aren't. sort is in :std/sort, filter and delete-duplicates are in :std/srfi/1. The error message is \"Unbound variable: sort\" (or filter). Also note: iota IS a builtin in Gerbil (from Gambit), and create-directory* is also a builtin.",
    "related": [
      "sort-a-list",
      "advanced-list-utilities"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "when-returns-void-in-boolean-context",
    "title": "Never use (when ...) as a boolean-returning function — use (if ... #t #f)",
    "tags": [
      "when",
      "void",
      "truthy",
      "boolean",
      "bug",
      "gotcha",
      "cond",
      "predicate"
    ],
    "imports": [],
    "code": ";; GOTCHA: (when cond body) returns #!void when cond is false.\n;; #!void is TRUTHY in Gerbil! Only #f is falsy.\n;;\n;; This commonly causes infinite loops or wrong branches in cond:\n\n;; WRONG — this function always returns truthy:\n(def (try-consume! state expected)\n  (when (match? state expected)  ;; returns #!void when false = truthy!\n    (advance! state)\n    #t))\n\n;; Used in cond, the wrong branch is always taken:\n(cond\n  ((try-consume! state \"+\") (handle-plus))  ;; ALWAYS taken!\n  ((try-consume! state \"-\") (handle-minus))\n  (else (handle-default)))\n\n;; CORRECT — use if with explicit #f:\n(def (try-consume! state expected)\n  (if (match? state expected)\n    (begin (advance! state) #t)\n    #f))",
    "notes": "This caused an infinite loop in gsh's arithmetic parser: arith-consume-op! used (when ...) and always returned truthy, causing parse-unary to infinitely recurse on the \"+\" branch. The fix was changing (when ...) to (if ... #t #f). Rule: any function whose return value will be tested for truthiness must NEVER use (when ...) — always use (if ... ... #f).",
    "related": [
      "hash-ref-void-truthy",
      "ffi-isatty-int-truthy"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-modal-dialog-offscreen-hang",
    "title": "Qt modal dialogs (QFontDialog, QColorDialog) hang in offscreen mode",
    "tags": [
      "qt",
      "modal",
      "dialog",
      "offscreen",
      "hang",
      "blocking",
      "QFontDialog",
      "QColorDialog",
      "test"
    ],
    "imports": [],
    "code": ";; GOTCHA: Qt blocking modal dialogs hang forever in offscreen mode.\n;; QFontDialog::getFont() and QColorDialog::getColor() use exec()\n;; which blocks waiting for user interaction. With QT_QPA_PLATFORM=offscreen,\n;; there is no user — the dialog blocks forever, hanging your test suite.\n;;\n;; AFFECTED METHODS:\n;;   QFontDialog::getFont(bool *ok, QWidget *parent)\n;;   QColorDialog::getColor(QColor initial, QWidget *parent)\n;;   QInputDialog::getText/getInt/getDouble/getItem\n;;   QFileDialog::getOpenFileName/getSaveFileName (sometimes)\n;;   QMessageBox::exec() (sometimes — static methods may work)\n;;\n;; DO NOT test these in offscreen mode:\n;; (test-case \"font dialog\"           ;; HANGS FOREVER\n;;   (let ((font (qt-font-dialog app win)))\n;;     (check (eq? font #f) => #t)))\n;;\n;; CORRECT — skip modal dialog tests in offscreen mode:\n;; ;; Comment explaining why these tests are excluded:\n;; ;; QFontDialog/QColorDialog use blocking exec() — cannot be tested\n;; ;; in offscreen mode (no user to accept/cancel). Test via examples instead.\n;;\n;; WORKAROUND for CI: Test the non-blocking parts separately:\n;; - Test QFont creation, property access, round-trips (non-modal)\n;; - Test QColor creation, channel queries, hex output (non-modal)\n;; - Test the C shim functions directly (create/destroy/query)\n;; - Leave the actual dialog popup for manual example programs\n;;\n;; The API wrappers are typically simple pass-throughs:\n;; (def (qt-font-dialog app parent)\n;;   (let ((result (raw_qt_font_dialog_get_font parent)))\n;;     (if (not result) #f result)))  ;; returns QFont or #f if cancelled",
    "notes": "This applies to ANY Qt static dialog method that calls exec() internally. The root cause is that exec() enters a modal event loop that processes events until the dialog is accepted or rejected. In offscreen mode, no user can interact with the dialog, so exec() never returns. This is not a bug — it's inherent to blocking dialogs. The only safe approach is to skip these tests in headless/offscreen CI environments and test them manually via example programs.",
    "related": [
      "qt-offscreen-headless-testing",
      "qt-application-argc-static"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-event-filter-no-moc",
    "title": "Qt event filter pattern without MOC (QObject::eventFilter override)",
    "tags": [
      "qt",
      "event",
      "filter",
      "eventFilter",
      "QObject",
      "MOC",
      "keyboard",
      "drag",
      "drop"
    ],
    "imports": [],
    "code": "// PATTERN: Intercept Qt events via QObject::eventFilter — no MOC needed.\n// This avoids Q_OBJECT macro, moc compilation, and signal/slot overhead.\n// Used for: keyboard events, drag-and-drop, mouse events, focus events.\n//\n// C++ shim pattern (in qt_shim.cpp):\n\nclass KeyPressFilter : public QObject {\n    // No Q_OBJECT macro — pure C++ virtual override\n    qt_callback_void m_callback;\n    long m_callback_id;\n    int m_last_key;\n    int m_last_modifiers;\n    char m_last_text[256];\n\npublic:\n    KeyPressFilter(QObject* parent, qt_callback_void cb, long id)\n        : QObject(parent), m_callback(cb), m_callback_id(id),\n          m_last_key(0), m_last_modifiers(0) {\n        m_last_text[0] = '\\0';\n    }\n\n    // Override eventFilter — this is a normal virtual method, no MOC\n    bool eventFilter(QObject* obj, QEvent* event) override {\n        if (event->type() == QEvent::KeyPress) {\n            QKeyEvent* ke = static_cast<QKeyEvent*>(event);\n            m_last_key = ke->key();\n            m_last_modifiers = static_cast<int>(ke->modifiers());\n            QByteArray utf8 = ke->text().toUtf8();\n            strncpy(m_last_text, utf8.constData(), sizeof(m_last_text) - 1);\n            m_last_text[sizeof(m_last_text) - 1] = '\\0';\n            if (m_callback) m_callback(m_callback_id);\n        }\n        return QObject::eventFilter(obj, event);  // pass to default\n    }\n\n    int lastKey() const { return m_last_key; }\n    int lastModifiers() const { return m_last_modifiers; }\n    const char* lastText() const { return m_last_text; }\n};\n\n// Install on a widget:\n// auto* filter = new KeyPressFilter(widget, callback, id);\n// widget->installEventFilter(filter);\n\n// SAME PATTERN works for DragEnter/Drop events:\n// class DropFilter : public QObject {\n//     bool eventFilter(QObject*, QEvent* event) override {\n//         if (event->type() == QEvent::DragEnter) { ... acceptProposedAction(); }\n//         if (event->type() == QEvent::Drop) { ... get mimeData()->text(); }\n//     }\n// };\n\n// KEY POINTS:\n// 1. No Q_OBJECT macro → no MOC step in build\n// 2. eventFilter is a normal C++ virtual method on QObject\n// 3. Store last event data in member variables → query from Scheme later\n// 4. Fire callback to notify Scheme, then Scheme queries the stored data\n// 5. Return false from eventFilter to let the event propagate normally",
    "notes": "This pattern is used in gerbil-qt for both keyboard events (KeyPressFilter) and drag-and-drop (DropFilter). The key insight is that QObject::eventFilter is a regular C++ virtual method override — it does NOT require the MOC (Meta-Object Compiler) or the Q_OBJECT macro. This makes it perfect for FFI bindings where running MOC is impractical. The \"fire callback + query\" pattern (instead of passing event data directly in the callback) avoids complex multi-argument callbacks and works with the simple void trampoline.",
    "related": [
      "multiple-callback-trampolines",
      "qt-application-argc-static",
      "qt-offscreen-headless-testing"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-painter-onto-pixmap",
    "title": "QPainter draw onto QPixmap then display on QLabel (no paintEvent override)",
    "tags": [
      "qt",
      "QPainter",
      "QPixmap",
      "draw",
      "canvas",
      "paint",
      "label",
      "FFI",
      "graphics"
    ],
    "imports": [],
    "code": ";; PATTERN: Use QPainter to draw onto a QPixmap, then display via QLabel.\n;; This avoids needing to override QWidget::paintEvent (which requires\n;; a C++ subclass + virtual method override — very complex from FFI).\n;;\n;; Steps:\n;; 1. Create a blank QPixmap (canvas)\n;; 2. Create QPainter targeting that pixmap\n;; 3. Draw shapes, text, etc.\n;; 4. Call painter-end to flush\n;; 5. Set pixmap on a QLabel for display\n;; 6. Destroy painter (separate from pixmap)\n\n;; Example (using gerbil-qt high-level API):\n(let* ((canvas (qt-pixmap-create-blank 400 300))\n       (p (qt-painter-create canvas)))\n\n  ;; Fill background\n  (qt-pixmap-fill! canvas 30 30 30)  ;; dark gray\n\n  ;; Enable antialiasing\n  (qt-painter-set-antialiasing! p #t)\n\n  ;; Draw shapes\n  (qt-painter-set-pen-color! p 255 0 0)\n  (qt-painter-set-pen-width! p 2)\n  (qt-painter-draw-rect! p 10 10 100 80)\n\n  (qt-painter-set-brush-color! p 0 0 255 alpha: 128)\n  (qt-painter-fill-rect! p 50 50 100 80 0 0 255)\n\n  (qt-painter-set-pen-color! p 255 255 255)\n  (qt-painter-draw-text! p 20 180 \"Hello from QPainter!\")\n\n  ;; Save/restore for transforms\n  (qt-painter-save! p)\n  (qt-painter-translate! p 200 150)\n  (qt-painter-rotate! p 45.0)   ;; NOTE: takes double, not int\n  (qt-painter-draw-rect! p -30 -20 60 40)\n  (qt-painter-restore! p)\n\n  ;; CRITICAL: end painting BEFORE using the pixmap elsewhere\n  (qt-painter-end! p)\n  (qt-painter-destroy! p)\n\n  ;; Display on label\n  (qt-label-set-pixmap! label canvas)\n\n  ;; ... later cleanup:\n  ;; (qt-pixmap-destroy! canvas)\n  )\n\n;; C++ shim side (qt_shim.cpp):\n;; QPainter paints onto QPixmap:\n;;   QPainter* painter = new QPainter(pixmap);\n;; QPainter::end() must be called before pixmap is used:\n;;   painter->end();\n;; Safety: qt_painter_destroy calls end() if still active:\n;;   void qt_painter_destroy(QPainter* p) {\n;;       if (p->isActive()) p->end();\n;;       delete p;\n;;   }\n\n;; KEY POINTS:\n;; 1. QPainter is NOT a QWidget — needs explicit destroy\n;; 2. QPixmap is NOT a QWidget — needs explicit destroy\n;; 3. painter->end() MUST be called before pixmap is displayed\n;; 4. rotate() and scale() take double, not int\n;; 5. Brush color alpha controls fill transparency\n;; 6. For animation: repaint by creating new QPainter, drawing, end, set-pixmap",
    "notes": "This \"paint onto pixmap\" approach is the practical way to do custom drawing from FFI without overriding virtual methods. For animation, create a QTimer callback that repaints the pixmap each frame. The alternative (overriding QWidget::paintEvent) requires a C++ subclass with a virtual method override, which is significantly more complex to wire through FFI. Both QPainter and QPixmap need explicit cleanup since they are not Qt-parented widgets.",
    "related": [
      "qt-event-filter-no-moc",
      "qt-modal-dialog-offscreen-hang",
      "qt-application-argc-static"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gxc-exe-in-makefile",
    "title": "Link executable via gxc -exe in Makefile (workaround for defbuild-script exe deadlock)",
    "tags": [
      "exe",
      "gxc",
      "makefile",
      "build",
      "link",
      "rpath",
      "defbuild-script",
      "deadlock",
      "workaround"
    ],
    "imports": [],
    "code": ";; PROBLEM: defbuild-script exe target deadlocks in the build worker\n;; with \"Completion has already been posted\" error.\n;;\n;; SOLUTION: Remove exe from build.ss, link separately in Makefile.\n;;\n;; ---- build.ss ----\n;; #!/usr/bin/env gxi\n;; (import :std/build-script)\n;; (defbuild-script\n;;   '(\"module-a\"\n;;     \"module-b\"\n;;     \"main\"))  ;; NO exe target here\n;;\n;; ---- Makefile ----\n;; LOCAL_LIB := $(CURDIR)/.gerbil/lib\n;; DEP_LIB ?= $(HOME)/mine/my-dep/.gerbil/lib\n;; export GERBIL_LOADPATH := $(LOCAL_LIB):$(DEP_LIB)\n;;\n;; CAIRO_LDFLAGS := $(shell pkg-config --libs cairo libpng16)\n;; OPENSSL_LDFLAGS := $(shell pkg-config --libs openssl)\n;; OPENSSL_LIBDIR := $(shell pkg-config --variable=libdir openssl)\n;; CAIRO_LIBDIR := $(shell pkg-config --variable=libdir cairo)\n;;\n;; build:\n;; \tgerbil build\n;; \tmkdir -p .gerbil/bin\n;; \tgxc -exe -o .gerbil/bin/my-app \\\n;; \t  -ld-options \"$(CAIRO_LDFLAGS) $(OPENSSL_LDFLAGS) -Wl,-rpath,$(OPENSSL_LIBDIR) -Wl,-rpath,$(CAIRO_LIBDIR)\" \\\n;; \t  main.ss\n;;\n;; KEY POINTS:\n;; 1. LOCAL_LIB must be in GERBIL_LOADPATH so gxc can find same-package modules\n;; 2. -Wl,-rpath,<libdir> embeds library path in binary (no LD_LIBRARY_PATH needed)\n;; 3. Use pkg-config --variable=libdir to get the library directory for rpath\n;; 4. build.ss must be chmod +x",
    "notes": "The defbuild-script exe target uses a build worker that can deadlock with a \"Completion has already been posted\" error. This workaround compiles modules normally via `gerbil build` then links the exe separately via `gxc -exe` in the Makefile. Critical: the project's own .gerbil/lib must be in GERBIL_LOADPATH for gxc to resolve same-package imports like :mypackage/module.",
    "related": [
      "static-exe-with-deps",
      "openssl-version-mismatch-patchelf",
      "gerbil-build-loadpath"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "rpath-via-gxc-ld-options",
    "title": "Embed rpath in gxc -exe to avoid LD_LIBRARY_PATH and patchelf",
    "tags": [
      "rpath",
      "gxc",
      "ld-options",
      "openssl",
      "cairo",
      "patchelf",
      "linker",
      "runtime",
      "library",
      "pkg-config"
    ],
    "imports": [],
    "code": ";; PROBLEM: Compiled Gerbil executable can't find Homebrew/Linuxbrew\n;; shared libraries at runtime:\n;;   error: libcrypto.so.3: version `OPENSSL_3.4.0' not found\n;;\n;; SOLUTION: Pass -Wl,-rpath,<libdir> in gxc -exe -ld-options.\n;; This embeds the library search path directly in the binary at link time.\n;; No patchelf or LD_LIBRARY_PATH needed.\n;;\n;; PATTERN (in Makefile):\n;;\n;; CAIRO_LDFLAGS := $(shell pkg-config --libs cairo libpng16)\n;; OPENSSL_LDFLAGS := $(shell pkg-config --libs openssl)\n;; OPENSSL_LIBDIR := $(shell pkg-config --variable=libdir openssl)\n;; CAIRO_LIBDIR := $(shell pkg-config --variable=libdir cairo)\n;;\n;; build:\n;; \tgerbil build\n;; \tgxc -exe -o .gerbil/bin/my-app \\\n;; \t  -ld-options \"$(CAIRO_LDFLAGS) $(OPENSSL_LDFLAGS) \\\n;; \t    -Wl,-rpath,$(OPENSSL_LIBDIR) -Wl,-rpath,$(CAIRO_LIBDIR)\" \\\n;; \t  main.ss\n;;\n;; PATTERN (in build.ss with defbuild-script):\n;;\n;; (import :std/build-script :std/make)\n;; (defbuild-script\n;;   `(\"my-module\"\n;;     \"main\"\n;;     (exe: \"main\" bin: \"my-app\"\n;;           \"-ld-options\" ,(string-append\n;;                            (ldflags \"cairo\" \"-lcairo\") \" \"\n;;                            (ldflags \"openssl\" \"-lssl -lcrypto\") \" \"\n;;                            \"-Wl,-rpath,\" (pkg-config-libs \"openssl\") \" \"\n;;                            \"-Wl,-rpath,\" (pkg-config-libs \"cairo\")))))\n;;\n;; VERIFY with:\n;;   patchelf --print-rpath .gerbil/bin/my-app\n;;   ldd .gerbil/bin/my-app | grep ssl\n;;\n;; KEY: Use pkg-config --variable=libdir (not --libs) to get the\n;; directory path for -Wl,-rpath. --libs returns \"-L/path -lfoo\"\n;; but rpath needs just the directory \"/path\".",
    "notes": "This is the preferred approach over patchelf for Gerbil executables. Pass -Wl,-rpath,<libdir> directly to gxc -exe via -ld-options to embed library paths at link time. Use `pkg-config --variable=libdir <pkg>` to get the directory path (not --libs which returns flags). Works for any library installed via Homebrew/Linuxbrew that differs from the system version (commonly openssl, cairo, libpng). On macOS, use -Wl,-rpath,<libdir> as well (same syntax with Apple's ld).",
    "related": [
      "openssl-version-mismatch-patchelf",
      "gxc-exe-in-makefile",
      "build-ffi-pkg-config",
      "static-exe-with-deps"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ffi-double-via-string-trampoline",
    "title": "Pass double values through string callback trampoline (avoid adding new callback type)",
    "tags": [
      "ffi",
      "double",
      "float",
      "callback",
      "trampoline",
      "string",
      "snprintf",
      "string->number"
    ],
    "imports": [],
    "code": ";; PATTERN: When you have N callback trampoline types (void, string, int, bool)\n;; and need to pass a double/float value, convert to string in C++ and back\n;; in Scheme — avoids adding a 5th trampoline type for a single signal.\n;;\n;; C++ side (in the signal connection wrapper):\n;; void qt_double_spin_box_on_value_changed(void* dsb, qt_callback_string cb, long id) {\n;;     QObject::connect(static_cast<QDoubleSpinBox*>(dsb),\n;;         QOverload<double>::of(&QDoubleSpinBox::valueChanged),\n;;         [cb, id](double value) {\n;;             char buf[64];\n;;             snprintf(buf, sizeof(buf), \"%.17g\", value);  // full precision\n;;             cb(id, buf);  // fire the STRING trampoline with stringified double\n;;         });\n;; }\n;;\n;; Scheme high-level wrapper:\n;; (def (qt-on-double-value-changed! dsb handler)\n;;   (let ((id (register-qt-string-handler!\n;;              (lambda (str) (handler (string->number str))))))\n;;     (raw_qt_double_spin_box_on_value_changed dsb id)))\n;;\n;; The handler receives a proper Scheme number (flonum), not a string.\n;; \"%.17g\" preserves full double precision (17 significant digits).\n;;\n;; Same pattern works for date/time signals:\n;; - QDateEdit::dateChanged → convert QDate to ISO string \"2025-06-15\"\n;; - QTimeEdit::timeChanged → convert QTime to ISO string \"14:30:45\"\n;; These naturally produce strings, so handler receives string directly.\n;;\n;; KEY INSIGHT: Adding a new callback type (double trampoline) requires:\n;; - New c-define, new dispatch table, new register function, new C trampoline\n;; - All for ONE signal type. String conversion is 2 lines of C++ and\n;;   1 line of Scheme, reusing the existing string infrastructure.",
    "notes": "snprintf \"%.17g\" is the standard way to round-trip a double through a string without precision loss. 17 significant digits is the maximum needed for IEEE 754 double. The Scheme string->number converts back to an exact or inexact number. This pattern is used in gerbil-qt Phase 9 for QDoubleSpinBox::valueChanged(double). The same approach works for any C callback that passes a double — convert to string in the C lambda, fire the string trampoline, convert back in the Scheme wrapper.",
    "related": [
      "multiple-callback-trampolines",
      "ffi-callback-dispatch-table"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "process-status-reaping-race-job-control",
    "title": "Gambit process-status reaps child: ffi-waitpid race in job control",
    "tags": [
      "process-status",
      "waitpid",
      "reap",
      "race",
      "job-control",
      "background",
      "WNOHANG",
      "gambit"
    ],
    "imports": [],
    "code": ";; GOTCHA: Gambit's (process-status port) blocks until the child exits\n;; and then REAPS it internally (via its own SIGCHLD handler / waitpid).\n;; After process-status returns, the child PID no longer exists for waitpid.\n;;\n;; This means: if you call (process-status port) and then try to call\n;; ffi-waitpid with WNOHANG to poll the child's status, waitpid returns 0\n;; (\"no status change\") because Gambit already reaped the child.\n;;\n;; WRONG pattern (job-wait that never marks jobs as done):\n;;   (for-each\n;;     (lambda (proc)\n;;       (when (eq? (job-process-status proc) 'running)\n;;         (let ((port (job-process-port proc)))\n;;           (when port (process-status port)))))   ;; ← reaps child\n;;     (job-processes job))\n;;   (ffi-waitpid-pid pid WNOHANG)  ;; ← returns 0! child already gone\n;;   ;; job-update-status! never transitions from 'running to 'exited\n;;\n;; CORRECT pattern: extract status directly from process-status return value\n;; and set the process status immediately, bypassing ffi-waitpid:\n(for-each\n  (lambda (proc)\n    (when (eq? (job-process-status proc) 'running)\n      (let ((port (job-process-port proc)))\n        (when port\n          (let ((raw (with-catch (lambda (e) 0)\n                       (lambda () (process-status port)))))\n            ;; Set status DIRECTLY — don't rely on ffi-waitpid afterward\n            (cond\n              ((WIFEXITED raw)\n               (set! (job-process-status proc) 'exited))\n              ((WIFSIGNALED raw)\n               (set! (job-process-status proc) 'signaled))\n              (else\n               (set! (job-process-status proc) 'exited))))))))\n  (job-processes job))",
    "notes": "This is critical for implementing job control in Gerbil. The root cause is that Gambit's SIGCHLD handler (or process-status itself) calls waitpid internally, consuming the child's exit status. Any subsequent waitpid call — whether via FFI or otherwise — will find no child to reap. The fix is to treat process-status's return value as the definitive status and update your job table immediately. Also applies to job cleanup: after process-status returns, the job should be marked done/killed so it can be removed from the table. Related pattern: use (close-port proc) after process-status to release the Gambit process port.",
    "related": [
      "process-status-decode-waitpid",
      "open-process-settings"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-text-browser-anchor-clicked",
    "title": "QTextBrowser: must disable openLinks before connecting anchorClicked",
    "tags": [
      "qt",
      "QTextBrowser",
      "anchorClicked",
      "setOpenLinks",
      "hyperlink",
      "signal",
      "gotcha"
    ],
    "imports": [],
    "code": ";; GOTCHA: QTextBrowser handles link clicks internally by default.\n;; If you connect anchorClicked WITHOUT calling setOpenLinks(false) first,\n;; the signal never fires — Qt intercepts the click and tries to navigate.\n;;\n;; In the C++ shim, the on_anchor_clicked function must:\n;; 1. Call setOpenLinks(false) BEFORE connecting the signal\n;; 2. Convert QUrl to std::string via url.toString().toStdString()\n;; 3. Use string trampoline (ffi_string_trampoline)\n;;\n;; C++ pattern:\n;; void qt_text_browser_on_anchor_clicked(qt_text_browser_t tb, int id,\n;;                                         qt_callback_string callback) {\n;;   auto *browser = static_cast<QTextBrowser*>(tb);\n;;   browser->setOpenLinks(false);  // CRITICAL — must come first\n;;   QObject::connect(browser, &QTextBrowser::anchorClicked,\n;;     [id, callback](const QUrl &url) {\n;;       callback(id, url.toString().toStdString().c_str());\n;;     });\n;; }\n;;\n;; Scheme usage:\n;; (qt-on-anchor-clicked! browser\n;;   (lambda (url) (displayln \"Clicked: \" url)))",
    "notes": "Without setOpenLinks(false), QTextBrowser silently handles links internally and the anchorClicked signal is never emitted. The QUrl is converted to string via toString().toStdString() in the C++ lambda. If you also want external browser launch, call qt-text-browser-set-open-external-links! separately.",
    "related": [
      "ffi-callback-dispatch-table"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-dialog-button-box-bitwise-flags",
    "title": "QDialogButtonBox: combine standard buttons with bitwise-ior",
    "tags": [
      "qt",
      "QDialogButtonBox",
      "bitwise-ior",
      "buttons",
      "dialog",
      "standard-buttons"
    ],
    "imports": [],
    "code": ";; QDialogButtonBox standard button flags are powers of 2 — combine with bitwise-ior.\n;;\n;; Constants (matching Qt::StandardButton enum):\n;; QT_BUTTON_OK       = 0x00000400\n;; QT_BUTTON_CANCEL   = 0x00400000\n;; QT_BUTTON_YES      = 0x00004000\n;; QT_BUTTON_NO       = 0x00010000\n;; QT_BUTTON_APPLY    = 0x02000000\n;; QT_BUTTON_CLOSE    = 0x00200000\n;; QT_BUTTON_RESET    = 0x04000000\n;; QT_BUTTON_HELP     = 0x01000000\n;; QT_BUTTON_SAVE     = 0x00000800\n;; QT_BUTTON_DISCARD  = 0x00800000\n;;\n;; Button roles for custom buttons:\n;; QT_BUTTON_ACCEPT_ROLE = 0, REJECT_ROLE = 1, RESET_ROLE = 7,\n;; APPLY_ROLE = 8, HELP_ROLE = 4\n;;\n;; Create with combined flags:\n;; (qt-button-box-create (bitwise-ior QT_BUTTON_SAVE QT_BUTTON_CANCEL))\n;;\n;; Get individual button handle:\n;; (qt-button-box-button bb QT_BUTTON_SAVE)  ;; returns QPushButton*\n;;\n;; Connect signals:\n;; (qt-on-accepted! bb (lambda () (displayln \"Save clicked\")))\n;; (qt-on-rejected! bb (lambda () (displayln \"Cancel clicked\")))\n;;\n;; The clicked(QAbstractButton*) signal fires for ANY button — use void\n;; trampoline and ignore the button pointer. Query which button was\n;; clicked by checking the button box state in the handler.",
    "notes": "QDialogButtonBox arranges buttons in platform-correct order (e.g. OK/Cancel on Windows vs Cancel/OK on macOS). The button() method takes a StandardButton constant and returns the QPushButton* handle, which can be used with qt-push-button-set-text! etc. The clicked signal passes QAbstractButton* which we ignore — use accepted/rejected for standard behavior.",
    "related": [
      "ffi-callback-dispatch-table"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-calendar-date-signals",
    "title": "QCalendarWidget: selectionChanged vs clicked signal patterns",
    "tags": [
      "qt",
      "QCalendarWidget",
      "calendar",
      "date",
      "selectionChanged",
      "clicked",
      "signal"
    ],
    "imports": [],
    "code": ";; QCalendarWidget has TWO date-related signals with different patterns:\n;;\n;; 1. selectionChanged() — NO arguments\n;;    Fires when the selected date changes (keyboard nav, API call, click).\n;;    Use void trampoline, then QUERY the date afterward:\n;;    (qt-on-selection-changed! cal\n;;      (lambda ()\n;;        (let ((date (qt-calendar-selected-date-string cal)))\n;;          (displayln \"Selected: \" date))))\n;;\n;; 2. clicked(QDate) — passes the date\n;;    Fires only on mouse click. C++ lambda converts QDate to ISO string:\n;;    date.toString(Qt::ISODate).toStdString().c_str()\n;;    Uses string trampoline:\n;;    (qt-on-calendar-clicked! cal\n;;      (lambda (iso-date)\n;;        (displayln \"Clicked: \" iso-date)))\n;;\n;; Day-of-week constants for setFirstDayOfWeek:\n;; QT_MONDAY=1 QT_TUESDAY=2 QT_WEDNESDAY=3 QT_THURSDAY=4\n;; QT_FRIDAY=5 QT_SATURDAY=6 QT_SUNDAY=7\n;; (These match Qt::DayOfWeek enum values)",
    "notes": "selectionChanged fires more broadly (any selection change including programmatic), while clicked only fires on user mouse click. For most UIs, selectionChanged + query is the safer pattern. The ISO date string format is \"YYYY-MM-DD\". Individual components available via qt-calendar-selected-year/month/day.",
    "related": [
      "ffi-callback-dispatch-table"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-shortcut-explicit-destroy",
    "title": "QShortcut needs explicit destroy — QObject but not QWidget",
    "tags": [
      "qt",
      "QShortcut",
      "shortcut",
      "keyboard",
      "destroy",
      "memory",
      "QObject"
    ],
    "imports": [],
    "code": ";; QShortcut is a QObject (not a QWidget). Like QTimer, QButtonGroup,\n;; and QSystemTrayIcon, it needs explicit destroy.\n;;\n;; Create with key sequence string + parent widget:\n;; (def sc (qt-shortcut-create \"Ctrl+S\" parent-widget))\n;;\n;; Connect activated signal (void trampoline):\n;; (qt-on-shortcut-activated! sc (lambda () (save-file!)))\n;;\n;; Enable/disable:\n;; (qt-shortcut-set-enabled! sc #f)  ;; disable\n;; (qt-shortcut-enabled? sc)         ;; query\n;;\n;; Change key:\n;; (qt-shortcut-set-key! sc \"Ctrl+Shift+S\")\n;;\n;; MUST destroy explicitly when done:\n;; (qt-shortcut-destroy! sc)\n;;\n;; QObjects that need explicit destroy in gerbil-qt:\n;; - QTimer        → qt-timer-destroy!\n;; - QButtonGroup  → qt-button-group-destroy!\n;; - QSystemTrayIcon → qt-system-tray-icon-destroy!\n;; - QShortcut     → qt-shortcut-destroy!",
    "notes": "Key sequence strings use Qt format: \"Ctrl+S\", \"Ctrl+Shift+N\", \"Alt+F4\", \"F5\", etc. QShortcut differs from QAction shortcuts — QAction is tied to menus/toolbars, QShortcut is standalone and can be attached to any widget. The parent widget determines the shortcut's context (which window must be active).",
    "related": [
      "ffi-callback-dispatch-table"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-view-signal-thread-local-query",
    "title": "Qt Model/View: avoid QModelIndex in FFI with thread-local query pattern",
    "tags": [
      "qt",
      "model",
      "view",
      "signal",
      "QModelIndex",
      "thread-local",
      "ffi",
      "callback"
    ],
    "imports": [],
    "code": "// PATTERN: Qt view signals pass QModelIndex — a C++ value type that is\n// impractical to expose through FFI. Instead, capture row/col in thread-local\n// storage in the C++ lambda, fire a void callback, then query from Scheme.\n//\n// C++ shim (qt_shim.cpp):\nstatic thread_local int s_last_view_row = -1;\nstatic thread_local int s_last_view_col = -1;\n\nextern \"C\" void qt_view_on_clicked(void* view,\n                                    void (*callback)(long), long id) {\n    auto* v = static_cast<QAbstractItemView*>(static_cast<QWidget*>(view));\n    QObject::connect(v, &QAbstractItemView::clicked,\n        [callback, id](const QModelIndex& idx) {\n            s_last_view_row = idx.row();\n            s_last_view_col = idx.column();\n            callback(id);  // void trampoline\n        });\n}\n\nextern \"C\" int qt_view_last_clicked_row(void) { return s_last_view_row; }\nextern \"C\" int qt_view_last_clicked_col(void) { return s_last_view_col; }\n\n// Scheme high-level usage:\n// (qt-on-view-clicked! table-view\n//   (lambda ()\n//     (let ((row (qt-view-last-clicked-row))\n//           (col (qt-view-last-clicked-col)))\n//       (displayln \"Clicked: row=\" row \" col=\" col))))\n//\n// ALSO works for: doubleClicked, activated signals (same QModelIndex pattern)\n// selectionChanged connects to QItemSelectionModel::selectionChanged instead",
    "notes": "This is the same pattern used for keyboard events (Phase 6) — fire void callback, then query stored data. It avoids exposing QModelIndex (a complex C++ value type with model pointer, internal ID, parent reference) to Scheme. Thread-local ensures thread safety. The -1 initial values indicate \"nothing clicked yet\". For selectionChanged, connect to view->selectionModel()->selectionChanged() instead of a view signal.",
    "related": [
      "multiple-callback-trampolines",
      "qt-event-filter-no-moc",
      "ffi-callback-dispatch-table"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-view-sorting-dynamic-cast",
    "title": "Qt: setSortingEnabled requires dynamic_cast — not on QAbstractItemView",
    "tags": [
      "qt",
      "sorting",
      "QTableView",
      "QTreeView",
      "dynamic_cast",
      "QAbstractItemView",
      "ffi"
    ],
    "imports": [],
    "code": "// GOTCHA: QAbstractItemView does NOT have setSortingEnabled().\n// Only QTableView and QTreeView do. If you write a generic \"view\"\n// function that takes QAbstractItemView*, you must dynamic_cast.\n//\n// C++ shim:\nextern \"C\" void qt_view_set_sorting_enabled(void* view, int val) {\n    // Try QTableView first\n    auto* tv = dynamic_cast<QTableView*>(static_cast<QWidget*>(view));\n    if (tv) { tv->setSortingEnabled(val != 0); return; }\n    // Then QTreeView\n    auto* trv = dynamic_cast<QTreeView*>(static_cast<QWidget*>(view));\n    if (trv) { trv->setSortingEnabled(val != 0); }\n    // QListView doesn't support sorting — silently ignored\n}\n\n// This pattern applies to other view-specific methods too.\n// QHeaderView access also needs dynamic_cast to find the right header:\nstatic QHeaderView* get_header(void* view, int horizontal) {\n    if (horizontal) {\n        auto* tv = dynamic_cast<QTableView*>(static_cast<QWidget*>(view));\n        if (tv) return tv->horizontalHeader();\n        auto* trv = dynamic_cast<QTreeView*>(static_cast<QWidget*>(view));\n        if (trv) return trv->header();  // tree only has horizontal header\n    } else {\n        auto* tv = dynamic_cast<QTableView*>(static_cast<QWidget*>(view));\n        if (tv) return tv->verticalHeader();\n        // QTreeView has no vertical header\n    }\n    return nullptr;\n}",
    "notes": "This is a common Qt API asymmetry — many methods that feel like they belong on QAbstractItemView are actually only on concrete subclasses. setSortingEnabled, horizontalHeader, verticalHeader are all examples. The dynamic_cast approach works because our void* handles are still valid QObject pointers with RTTI. Use nullptr return for graceful degradation when a view type doesn't support the operation.",
    "related": [
      "qt-view-signal-thread-local-query",
      "qt-event-filter-no-moc"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "lexer-raw-char-bypass-tokenizer",
    "title": "Read raw characters from lexer input bypassing shell tokenization",
    "tags": [
      "lexer",
      "parser",
      "raw",
      "character",
      "bypass",
      "arithmetic",
      "tokenizer"
    ],
    "imports": [],
    "code": ";; When building a shell parser, arithmetic expressions inside (( )) and\n;; for (( )) contain operators like <, >, |, & that the shell lexer would\n;; incorrectly treat as redirection/pipe/background operators.\n;;\n;; Solution: read raw characters directly from the lexer's input string,\n;; bypassing shell tokenization entirely.\n;;\n;; Given a lexer struct with (input pos len) fields:\n\n(defstruct lexer (input pos len ...) transparent: #t)\n\n;; Helper: get current char from lexer, or #f at end\n(def (lexer-raw-char lex)\n  (if (>= (lexer-pos lex) (lexer-len lex))\n    #f\n    (string-ref (lexer-input lex) (lexer-pos lex))))\n\n;; Helper: advance lexer position by 1\n(def (lexer-raw-advance! lex)\n  (set! (lexer-pos lex) (+ 1 (lexer-pos lex))))\n\n;; CRITICAL: clear any peeked tokens from parser AND lexer\n;; before switching to raw reading — stale tokens would cause\n;; the lexer to re-read already-consumed input.\n(def (parser-clear-peeked! ps)\n  (set! (parser-state-peeked ps) #f)\n  (set! (lexer-peeked (parser-state-lexer ps)) #f))\n\n;; Example: read arithmetic expression until )) tracking nested parens\n(def (read-arith-body ps)\n  (parser-clear-peeked! ps)\n  (let ((lex (parser-state-lexer ps))\n        (buf (open-output-string)))\n    (let loop ((depth 0))\n      (let ((ch (lexer-raw-char lex)))\n        (cond\n          ((not ch) (error \"parse error: expected '))\"))\n          ((char=? ch #\\x28)  ;; open paren: (\n           (lexer-raw-advance! lex)\n           (display ch buf)\n           (loop (+ depth 1)))\n          ((char=? ch #\\x29)  ;; close paren: )\n           (if (> depth 0)\n             (begin (lexer-raw-advance! lex)\n                    (display ch buf)\n                    (loop (- depth 1)))\n             ;; depth=0: check for second )\n             (begin\n               (lexer-raw-advance! lex)\n               (let ((ch2 (lexer-raw-char lex)))\n                 (if (and ch2 (char=? ch2 #\\x29))\n                   (begin (lexer-raw-advance! lex)\n                          (get-output-string buf))  ;; done!\n                   (begin (display \")\" buf)\n                          (loop depth)))))))\n          (else\n           (lexer-raw-advance! lex)\n           (display ch buf)\n           (loop depth)))))))",
    "notes": "Key insight: shell lexers treat < > | & as operators, but inside arithmetic expressions these are comparison/bitwise operators. Reading raw chars avoids this conflict. Always clear peeked tokens before switching from token-based to raw reading. After raw reading completes, the lexer position is past the consumed text, so subsequent token reads continue from the right place. Track nested paren depth so (a+b)*(c+d) inside (( )) doesn't prematurely close. Use char->integer hex codes (#\\x28 = '(', #\\x29 = ')') to avoid Gerbil reader issues with #\\\\( and #\\\\) character literals.",
    "related": [
      "avoid-bracket-char-literals"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "break-continue-exception-levels-pattern",
    "title": "Handle break/continue exceptions with levels for nested loops",
    "tags": [
      "break",
      "continue",
      "exception",
      "loop",
      "nested",
      "levels",
      "with-catch"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": ";; Shell-style break/continue with nested loop levels.\n;; \"break 2\" breaks out of 2 enclosing loops, not just 1.\n;;\n;; Define exception types with a 'levels' field:\n(defstruct break-exception (levels) transparent: #t)\n(defstruct continue-exception (levels) transparent: #t)\n\n;; Builtins create exceptions:\n;; (raise (make-break-exception 1))      ;; break (1 level)\n;; (raise (make-break-exception 2))      ;; break 2\n;; (raise (make-continue-exception 1))   ;; continue\n\n;; Each loop catches break/continue and decrements levels.\n;; If levels > 1 after decrement, re-raise for outer loop.\n(def (execute-loop body-fn update-fn test-fn env)\n  (let loop ((status 0))\n    (if (not (test-fn))\n      status\n      (with-catch\n       (lambda (e)\n         (cond\n           ((break-exception? e)\n            (if (> (break-exception-levels e) 1)\n              ;; Decrement and re-raise for outer loop\n              (raise (make-break-exception (- (break-exception-levels e) 1)))\n              ;; levels=1: break THIS loop, return current status\n              status))\n           ((continue-exception? e)\n            (if (> (continue-exception-levels e) 1)\n              ;; Decrement and re-raise for outer loop\n              (raise (make-continue-exception (- (continue-exception-levels e) 1)))\n              ;; levels=1: skip rest of body, run update, continue loop\n              (begin (update-fn) (loop status))))\n           (else (raise e))))\n       (lambda ()\n         (let ((new-status (body-fn)))\n           (update-fn)\n           (loop new-status)))))))\n\n;; WRONG — using (values 'break ...) with with-catch:\n;; with-catch returns the handler's return value, but 'values'\n;; returns a multiple-value object, not a pair. Checking with\n;; (pair? result) won't work. Use the exception levels pattern instead.",
    "notes": "Critical: with-catch returns the handler's return value as a single value. Do NOT use (values 'break status) inside a with-catch handler — the result is a multiple-value object that can't be inspected with pair?. Instead, the handler should either: (1) re-raise a decremented exception, (2) return a status value and loop, or (3) return a status value to exit the loop. The continue handler should run any update expression before looping, since continue skips the rest of the body but the loop update still needs to happen (e.g., i++ in a C-style for loop).",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-graphics-scene-view-items",
    "title": "QGraphicsScene/View: create scene, add movable items, display in view",
    "tags": [
      "qt",
      "graphics",
      "scene",
      "view",
      "diagram",
      "item",
      "movable",
      "selectable"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; PATTERN: QGraphicsScene is a 2D scene graph. Add shapes as items,\n;; configure their visual properties and interaction flags, then display\n;; the scene in a QGraphicsView widget.\n;;\n;; Scene OWNS items — destroying scene destroys all items.\n;; QGraphicsItem is NOT a QWidget — items live in scene, not widget tree.\n;; QGraphicsScene is NOT a QWidget — needs explicit destroy.\n;; QGraphicsView IS a QWidget — parent-child ownership applies.\n\n(import :gerbil-qt/qt)\n\n(with-qt-app app\n  (let* ((scene (qt-graphics-scene-create 0 0 800 600))\n         (view (qt-graphics-view-create scene)))\n\n    ;; Add shapes — each returns an item handle\n    (let ((rect (qt-graphics-scene-add-rect! scene 50 50 120 80))\n          (circle (qt-graphics-scene-add-ellipse! scene 250 80 100 100))\n          (line (qt-graphics-scene-add-line! scene 170 90 250 130))\n          (text (qt-graphics-scene-add-text! scene \"Hello Scene\")))\n\n      ;; Style items\n      (qt-graphics-item-set-brush! rect 100 150 255)     ;; blue fill\n      (qt-graphics-item-set-pen! rect 40 80 180 2)       ;; dark blue outline, 2px\n      (qt-graphics-item-set-brush! circle 100 220 100)   ;; green fill\n      (qt-graphics-item-set-pen! line 80 80 80 2)        ;; gray line\n\n      ;; Make items movable and selectable (combine flags with bitwise-ior)\n      (qt-graphics-item-set-flags! rect\n        (bitwise-ior QT_ITEM_MOVABLE QT_ITEM_SELECTABLE))\n      (qt-graphics-item-set-flags! circle\n        (bitwise-ior QT_ITEM_MOVABLE QT_ITEM_SELECTABLE))\n\n      ;; Position, z-order, tooltip\n      (qt-graphics-item-set-pos! text 200 20)\n      (qt-graphics-item-set-zvalue! line -1.0)   ;; behind shapes\n      (qt-graphics-item-set-tooltip! rect \"Drag me!\")\n\n      ;; Configure the view\n      (qt-graphics-view-set-render-hint! view QT_RENDER_ANTIALIASING)\n      (qt-graphics-view-set-drag-mode! view QT_DRAG_RUBBER_BAND)\n      (qt-graphics-scene-set-background! scene 245 245 245)\n\n      ;; Zoom and center\n      (qt-graphics-view-scale! view 1.5 1.5)\n      (qt-graphics-view-center-on! view 200 150)\n\n      ;; Remove/clear\n      ;; (qt-graphics-scene-remove-item! scene rect)  ;; removes + deletes\n      ;; (qt-graphics-scene-clear! scene)              ;; removes all items\n      ;; (qt-graphics-scene-items-count scene)         ;; number of items\n\n      ;; View is a QWidget — add to layouts normally\n      ;; (qt-layout-add-widget! layout view)\n\n      (qt-widget-show! view)\n      (qt-app-exec! app)\n\n      ;; Cleanup: destroy view first (QWidget), then scene\n      (qt-widget-destroy! view)\n      (qt-graphics-scene-destroy! scene))))",
    "notes": "QGraphicsScene coordinates use double (exact->inexact conversion in high-level API). Item flag constants: QT_ITEM_MOVABLE (0x1), QT_ITEM_SELECTABLE (0x2), QT_ITEM_FOCUSABLE (0x4). Drag modes: QT_DRAG_NONE (0), QT_DRAG_SCROLL (1), QT_DRAG_RUBBER_BAND (2). Render hints: QT_RENDER_ANTIALIASING (0x01). set_pen uses dynamic_cast to QAbstractGraphicsShapeItem or QGraphicsLineItem. set_brush only works on shape items (not lines). remove_item does both removeItem + delete in C++. Can also add pixmap items via qt-graphics-scene-add-pixmap!.",
    "related": [
      "qt-paint-widget-custom-paintevent",
      "qt-painter-draw-pixmap",
      "qt-event-filter-no-moc"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-paint-widget-custom-paintevent",
    "title": "PaintWidget: custom QWidget with paintEvent override for live Scheme-driven painting",
    "tags": [
      "paint",
      "widget",
      "QPainter",
      "paintEvent",
      "custom",
      "drawing",
      "canvas",
      "PaintWidget"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; PATTERN: PaintWidget is a custom QWidget subclass that overrides paintEvent()\n;; and fires a Scheme callback. Inside the callback, use qt-paint-widget-painter\n;; to get the active QPainter, then draw with existing QPainter API functions.\n;;\n;; This is BETTER than paint-onto-pixmap for:\n;; - Proper resize handling (repaint at new size)\n;; - Hardware-accelerated rendering\n;; - No intermediate pixmap allocation\n;;\n;; CRITICAL: The painter is only valid INSIDE the paint callback.\n;; Do NOT store it for later use.\n\n(import :gerbil-qt/qt)\n\n(with-qt-app app\n  (let ((canvas (qt-paint-widget-create)))\n    ;; Set minimum size for the paint area\n    (qt-widget-set-minimum-size! canvas 400 300)\n\n    ;; Register paint callback — fires during every paintEvent\n    (qt-paint-widget-on-paint! canvas\n      (lambda ()\n        (let ((painter (qt-paint-widget-painter canvas))\n              (w (qt-paint-widget-width canvas))\n              (h (qt-paint-widget-height canvas)))\n          (when painter  ;; painter is only non-#f inside paintEvent\n            ;; Background — fill-rect! takes color inline (NOT from brush)\n            ;; Signature: (qt-painter-fill-rect! p x y w h r g b [alpha: 255])\n            (qt-painter-fill-rect! painter 0 0 w h 30 30 50)\n\n            ;; Draw shapes using existing QPainter API\n            (qt-painter-set-antialiasing! painter #t)\n            (qt-painter-set-pen-color! painter 255 100 100)\n            (qt-painter-set-pen-width! painter 2)\n            (qt-painter-draw-ellipse! painter 50 50 (- w 100) (- h 100))\n\n            (qt-painter-set-pen-color! painter 200 200 200)\n            (qt-painter-draw-text! painter 20 30 \"Resize me!\")))))\n\n    ;; Request a repaint (triggers paintEvent → callback)\n    (qt-paint-widget-update! canvas)\n\n    ;; PaintWidget IS a QWidget — add to layouts normally\n    ;; (qt-layout-add-widget! layout canvas)\n\n    (qt-widget-show! canvas)\n    (qt-app-exec! app)\n    (qt-widget-destroy! canvas)))\n\n;; GOTCHA: qt-painter-fill-rect! requires explicit color args!\n;; WRONG:  (qt-painter-set-brush-color! p r g b) (qt-painter-fill-rect! p x y w h)\n;; RIGHT:  (qt-painter-fill-rect! p x y w h r g b)\n;; The brush color set by set-brush-color! is NOT used by fill-rect!.",
    "notes": "PaintWidget is a QWidget — parent-child ownership applies, no explicit destroy needed if parented. The paint callback is a void trampoline — uses the same callback dispatch system as all other signals. qt-paint-widget-painter returns #f (null pointer) outside of the paint callback. Width/height use integer (int), but scene coordinates use double. For animation, call qt-paint-widget-update! from a QTimer callback. IMPORTANT: qt-painter-fill-rect! takes color args (r g b) positionally — it does NOT use the current brush color. This is different from QPainter's C++ API where fillRect can use the current brush.",
    "related": [
      "qt-graphics-scene-view-items",
      "qt-painter-draw-pixmap",
      "qt-event-filter-no-moc",
      "multiple-callback-trampolines"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-graphics-item-dynamic-cast-pen-brush",
    "title": "QGraphicsItem set_pen/set_brush uses dynamic_cast for polymorphic item types",
    "tags": [
      "qt",
      "graphics",
      "item",
      "pen",
      "brush",
      "dynamic_cast",
      "shape",
      "line"
    ],
    "imports": [],
    "code": "// C++ PATTERN: QGraphicsItem is the base class, but setPen()/setBrush()\n// are on DIFFERENT subclasses. You must dynamic_cast to the right type.\n//\n// setPen() exists on:\n//   - QAbstractGraphicsShapeItem (covers rect, ellipse, polygon, path)\n//   - QGraphicsLineItem (separate class, not a shape!)\n//\n// setBrush() exists on:\n//   - QAbstractGraphicsShapeItem ONLY (not lines — lines have no fill)\n//\n// QGraphicsTextItem has NEITHER setPen nor setBrush.\n\nextern \"C\" void qt_graphics_item_set_pen(void* item,\n                                          int r, int g, int b, int width) {\n    auto* gi = static_cast<QGraphicsItem*>(item);\n    QPen pen(QColor(r, g, b));\n    pen.setWidth(width);\n    // Try shape item first (covers rect, ellipse, polygon, path)\n    if (auto* shape = dynamic_cast<QAbstractGraphicsShapeItem*>(gi))\n        shape->setPen(pen);\n    else if (auto* line = dynamic_cast<QGraphicsLineItem*>(gi))\n        line->setPen(pen);\n    // Text items: silently ignore (no pen)\n}\n\nextern \"C\" void qt_graphics_item_set_brush(void* item, int r, int g, int b) {\n    auto* gi = static_cast<QGraphicsItem*>(item);\n    if (auto* shape = dynamic_cast<QAbstractGraphicsShapeItem*>(gi))\n        shape->setBrush(QColor(r, g, b));\n    // Lines and text items: silently ignore (no brush)\n}\n\n// Works because:\n// 1. void* handles are still valid QGraphicsItem pointers with RTTI\n// 2. dynamic_cast returns nullptr for wrong types → graceful fallback\n// 3. Covers all items returned by scene->addRect/addEllipse/addLine/addText",
    "notes": "This pattern is used in gerbil-qt's C++ shim for qt_graphics_item_set_pen and qt_graphics_item_set_brush. The same dynamic_cast approach is used for Qt views (setSortingEnabled, header access) where methods exist on subclasses but not the base class. Always use dynamic_cast with nullptr checks for graceful degradation. The #include chain for these classes: QGraphicsRectItem, QGraphicsEllipseItem (both inherit QAbstractGraphicsShapeItem), QGraphicsLineItem (inherits QGraphicsItem directly), QGraphicsTextItem (inherits QGraphicsObject).",
    "related": [
      "qt-graphics-scene-view-items",
      "qt-view-sorting-dynamic-cast"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gambit-sendto-socket-fd-type-caching",
    "title": "Gambit caches fd type at port creation — sendto fails after dup2 changes fd to non-socket",
    "tags": [
      "gambit",
      "sendto",
      "dup2",
      "socket",
      "fd",
      "port",
      "ENOTSOCK",
      "redirect",
      "os-exception"
    ],
    "imports": [],
    "code": ";; CRITICAL GOTCHA: Gambit caches whether a port's underlying fd is a socket\n;; at port creation time. If the port was created on a socket fd, Gambit uses\n;; sendto() for writes. If you later dup2() a regular file fd onto that fd\n;; number, Gambit still uses sendto(), which fails with ENOTSOCK.\n;;\n;; This manifests as: #<os-exception> when writing to stdout after dup2.\n;;\n;; Example scenario: shell running under `timeout` or piped input\n;; - At startup, fd 1 is a socket (from timeout's socketpair)\n;; - Gambit creates stdout port → marks it as \"socket\" → uses sendto(1, ...)\n;; - Shell does: exec 5>file.txt; echo hello >&5\n;;   which does: dup2(5, 1) → fd 1 now points to file\n;; - Gambit still uses sendto(1, ...) → ENOTSOCK!\n;;\n;; STRACE EVIDENCE:\n;;   dup2(5, 1)                      = 1       ;; fd 1 is now a regular file\n;;   sendto(1, \"hello\\n\", 6, 0, NULL, 0) = -1 ENOTSOCK\n;;\n;; FIX: After dup2(source, dest) where dest is 0/1/2 and source is a high fd\n;; (not a standard Gambit port), create a FRESH Gambit port via /dev/fd/N:\n;;\n;;   (ffi-dup2 source-fd dest-fd)\n;;   (when (and (<= 0 dest-fd 2) (> source-fd 2))\n;;     (let ((new-port (open-output-file\n;;                       [path: (string-append \"/dev/fd/\" (number->string dest-fd))\n;;                        append: #t])))\n;;       (current-output-port new-port)))  ;; or current-error-port for fd 2\n;;\n;; The new port opens /dev/fd/1, which creates a NEW internal fd (e.g., fd 7)\n;; pointing to the same file. Gambit detects fd 7 as a regular file and uses\n;; write() instead of sendto().\n;;\n;; IMPORTANT: When restoring the original fd, you MUST:\n;; 1. force-output and close-port the new port FIRST\n;; 2. Then dup2 to restore the original fd\n;; 3. Then restore the original Gambit port\n;; Otherwise the new port's internal fd leaks or flushes at wrong times.",
    "notes": "Discovered via strace while debugging gsh (Gerbil shell). When gsh is run under `timeout` command, fd 0/1/2 are socketpairs. Gambit detects this at startup and uses sendto/recvfrom for I/O instead of read/write. After dup2(file_fd, 1), sendto fails with ENOTSOCK. The fix requires creating a fresh port so Gambit re-detects the fd type. This issue does NOT occur when fds are files/pipes from the start (e.g., running from a terminal).",
    "related": [
      "character-port-from-raw-fd-via-dev-fd",
      "fd-e-extract-raw-fd-from-port",
      "pipeline-fd-management-close-write-end"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-widget-set-font-arity",
    "title": "qt-widget-set-font! takes (widget, font-object) — NOT (widget, family, size)",
    "tags": [
      "qt",
      "font",
      "widget",
      "set-font",
      "arity",
      "gotcha",
      "gerbil-qt"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: qt-widget-set-font! takes exactly 2 arguments:\n;;   (qt-widget-set-font! widget font-object)\n;;\n;; It does NOT take (widget family-string point-size).\n;; You must create a QFont object first, then pass it.\n;;\n;; WRONG — will fail at runtime with wrong number of arguments:\n;; (qt-widget-set-font! my-label \"Monospace\" 10)  ;; ERROR!\n;;\n;; CORRECT — create a QFont object, apply it, then destroy it:\n(import :gerbil-qt/qt)\n\n(let ((mono (qt-font-create \"Monospace\" point-size: 10)))\n  (qt-widget-set-font! my-label mono)\n  (qt-widget-set-font! my-input mono)    ;; reuse for multiple widgets\n  (qt-font-destroy! mono))               ;; cleanup when done\n\n;; qt-font-create signature:\n;;   (qt-font-create family [point-size: N] [weight: W] [italic: BOOL])\n;;\n;; Common font families: \"Monospace\", \"Sans Serif\", \"Serif\"\n;;\n;; After qt-widget-set-font!, Qt copies the font data internally,\n;; so it's safe to destroy the QFont object immediately.",
    "notes": "This is a common mistake because many GUI toolkits allow (set-font widget \"family\" size) as a convenience. In gerbil-qt, fonts are always QFont objects. The qt-font-create function uses keyword arguments for optional properties. After applying to a widget, Qt copies the font internally — the QFont object can be safely destroyed. This applies to ALL widgets: labels, buttons, text edits, plain text edits, line edits, etc.",
    "related": [
      "qt-offscreen-headless-testing",
      "qt-shortcut-explicit-destroy"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-progress-dialog-timer-driven",
    "title": "QProgressDialog with QTimer for non-blocking progress updates",
    "tags": [
      "qt",
      "progress",
      "dialog",
      "timer",
      "cancel",
      "gerbil-qt",
      "async"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; PATTERN: Use QTimer to drive QProgressDialog updates without blocking the UI.\n;; QProgressDialog is modal but non-blocking when driven by timer events.\n;;\n;; Key APIs:\n;;   qt-progress-dialog-create label cancel-text min max [parent: widget]\n;;   qt-progress-dialog-set-value! pd value\n;;   qt-progress-dialog-set-label-text! pd text\n;;   qt-progress-dialog-canceled? pd         ;; check if user clicked Cancel\n;;   qt-progress-dialog-set-minimum-duration! pd ms  ;; delay before showing (0 = immediate)\n;;   qt-progress-dialog-set-auto-close! pd bool      ;; auto-close at 100%\n;;   qt-progress-dialog-set-auto-reset! pd bool       ;; auto-reset value at 100%\n;;   qt-progress-dialog-reset! pd                     ;; reset to initial state\n\n(import :gerbil-qt/qt :std/format)\n\n;; Create dialog (range 0-100)\n(let ((pd (qt-progress-dialog-create \"Processing...\" \"Cancel\" 0 100 parent: win)))\n  (qt-progress-dialog-set-minimum-duration! pd 0)  ;; show immediately\n  (qt-progress-dialog-set-auto-close! pd #f)       ;; don't auto-close\n  (qt-progress-dialog-set-auto-reset! pd #f)       ;; don't auto-reset\n  (qt-widget-show! pd)\n\n  ;; Drive with timer\n  (let ((step 0)\n        (timer (qt-timer-create)))\n    (qt-on-timeout! timer\n      (lambda ()\n        (if (or (>= step 100) (qt-progress-dialog-canceled? pd))\n          (begin\n            (qt-timer-stop! timer)\n            (qt-timer-destroy! timer)\n            (if (qt-progress-dialog-canceled? pd)\n              (displayln \"Canceled!\")\n              (displayln \"Done!\"))\n            (qt-progress-dialog-reset! pd)\n            (qt-widget-close! pd))\n          (begin\n            (set! step (+ step 2))\n            (qt-progress-dialog-set-value! pd step)\n            (qt-progress-dialog-set-label-text! pd\n              (format \"Processing item ~a of 100...\" step))))))\n    (qt-timer-start! timer 50)))  ;; 50ms interval",
    "notes": "QProgressDialog is a QWidget — if parented, Qt handles cleanup. auto-close and auto-reset default to #t; set both to #f if you want explicit control. The timer pattern is essential because calling a blocking loop would freeze the GUI. qt-progress-dialog-canceled? checks if the Cancel button was clicked. Always call qt-timer-stop! and qt-timer-destroy! when done. The dialog should be shown with qt-widget-show! after configuration.",
    "related": [
      "qt-offscreen-headless-testing",
      "qt-shortcut-explicit-destroy"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-system-tray-icon-pattern",
    "title": "QSystemTrayIcon with custom icon, context menu, and balloon messages",
    "tags": [
      "qt",
      "tray",
      "system-tray",
      "icon",
      "balloon",
      "notification",
      "gerbil-qt",
      "context-menu"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; PATTERN: QSystemTrayIcon — system tray with icon, context menu, and notifications.\n;;\n;; IMPORTANT: Check qt-system-tray-available? before creating!\n;; Not all platforms/desktop environments support system tray.\n;;\n;; QSystemTrayIcon is NOT a QWidget — needs explicit destroy.\n\n(import :gerbil-qt/qt)\n\n;; 1. Check availability\n(when (qt-system-tray-available?)\n\n  ;; 2. Create a custom icon (pixmap → icon)\n  (let* ((pix (qt-pixmap-create-blank 32 32))\n         (_ (qt-pixmap-fill! pix 52 152 219))  ;; blue background\n         (icon (qt-icon-create-from-pixmap pix))\n         (tray (qt-system-tray-icon-create icon)))\n\n    ;; 3. Set tooltip\n    (qt-system-tray-icon-set-tooltip! tray \"My App\")\n\n    ;; 4. Create context menu (right-click menu)\n    ;; Use a QMenu from the menu bar as context menu\n    (let ((ctx-menu (qt-menu-bar-add-menu (qt-main-window-menu-bar win) \"ctx\"))\n          (show-action (qt-action-create \"Show Window\" win))\n          (quit-action (qt-action-create \"Quit\" win)))\n      (qt-on-triggered! show-action\n        (lambda () (qt-widget-show-normal! win)))\n      (qt-on-triggered! quit-action\n        (lambda ()\n          (qt-system-tray-icon-hide! tray)\n          (qt-app-quit! app)))\n      (qt-menu-add-action! ctx-menu show-action)\n      (qt-menu-add-separator! ctx-menu)\n      (qt-menu-add-action! ctx-menu quit-action)\n      (qt-system-tray-icon-set-context-menu! tray ctx-menu))\n\n    ;; 5. Handle tray activation (click events)\n    (qt-on-tray-activated! tray\n      (lambda (reason)\n        (cond\n          ((= reason QT_TRAY_TRIGGER) (qt-widget-show-normal! win))\n          ((= reason QT_TRAY_DOUBLE_CLICK) (displayln \"double click\"))\n          ((= reason QT_TRAY_CONTEXT) (displayln \"right click\"))\n          ((= reason QT_TRAY_MIDDLE_CLICK) (displayln \"middle click\")))))\n\n    ;; 6. Show balloon notification\n    (qt-system-tray-icon-show-message! tray\n      \"Title\" \"Message body\"\n      icon-type: QT_TRAY_INFO   ;; QT_TRAY_INFO, QT_TRAY_WARNING, QT_TRAY_CRITICAL\n      timeout: 3000)             ;; milliseconds\n\n    ;; 7. Show/hide tray icon\n    (qt-system-tray-icon-show! tray)\n    ;; (qt-system-tray-icon-hide! tray)\n\n    ;; 8. Cleanup — MUST destroy explicitly\n    ;; (qt-system-tray-icon-destroy! tray)\n    ;; (qt-icon-destroy! icon)\n    ;; (qt-pixmap-destroy! pix)\n    ))",
    "notes": "QSystemTrayIcon activation reason constants: QT_TRAY_TRIGGER (single click), QT_TRAY_DOUBLE_CLICK, QT_TRAY_CONTEXT (right-click), QT_TRAY_MIDDLE_CLICK. Balloon icon types: QT_TRAY_INFO, QT_TRAY_WARNING, QT_TRAY_CRITICAL, QT_TRAY_NO_ICON. Always check qt-system-tray-available? first — Wayland/some Linux DEs don't support it. The tray icon, underlying QIcon, and QPixmap all need explicit destroy since they're not QWidgets. qt-widget-show-normal! restores a minimized window.",
    "related": [
      "qt-shortcut-explicit-destroy",
      "qt-widget-set-font-arity"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-input-dialog-all-types",
    "title": "QInputDialog: get-text, get-int, get-double, get-item (all return #f on cancel)",
    "tags": [
      "qt",
      "input",
      "dialog",
      "get-text",
      "get-int",
      "get-double",
      "get-item",
      "gerbil-qt"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; PATTERN: QInputDialog static methods — all return #f if user cancels.\n;;\n;; All four variants use keyword arguments for optional parameters.\n;; parent: is optional but recommended (centers dialog over parent window).\n\n(import :gerbil-qt/qt)\n\n;; Text input\n(let ((result (qt-input-dialog-get-text \"Title\" \"Prompt:\"\n                default: \"initial value\" parent: win)))\n  (if result\n    (displayln \"Got: \" result)\n    (displayln \"Cancelled\")))\n\n;; Integer input (with range and step)\n(let ((result (qt-input-dialog-get-int \"Title\" \"Pick a number:\"\n                value: 42 min: 0 max: 100 step: 5 parent: win)))\n  (if result\n    (displayln \"Got: \" result)   ;; result is an integer\n    (displayln \"Cancelled\")))\n\n;; Double input (with range and decimal places)\n(let ((result (qt-input-dialog-get-double \"Title\" \"Temperature:\"\n                value: 98.6 min: -100.0 max: 200.0 decimals: 2 parent: win)))\n  (if result\n    (displayln \"Got: \" result)   ;; result is a flonum\n    (displayln \"Cancelled\")))\n\n;; Item selection (dropdown list)\n(let ((result (qt-input-dialog-get-item \"Title\" \"Choose:\"\n                [\"Option A\" \"Option B\" \"Option C\"]\n                current: 0 parent: win)))\n  (if result\n    (displayln \"Got: \" result)   ;; result is the selected string\n    (displayln \"Cancelled\")))",
    "notes": "All QInputDialog methods are blocking/modal — they hang in offscreen mode (QT_QPA_PLATFORM=offscreen). Only test these in interactive example programs, not in CI tests. The return value is the actual typed/selected value on accept, or #f on cancel. get-item takes a list of strings and returns the selected string (not the index). get-double uses the string trampoline internally (snprintf \"%.17g\") to pass double values through FFI.",
    "related": [
      "qt-offscreen-headless-testing",
      "qt-progress-dialog-timer-driven"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "github-actions-ci-gerbil-ffi",
    "title": "GitHub Actions CI workflow for Gerbil FFI projects",
    "tags": [
      "github",
      "actions",
      "CI",
      "workflow",
      "build",
      "test",
      "FFI",
      "gerbil"
    ],
    "imports": [],
    "code": ";; .github/workflows/ci.yml — GitHub Actions CI for a Gerbil FFI project\n;;\n;; This YAML workflow builds Gerbil from source, installs system C library\n;; dependencies, builds the project, and runs tests.\n;;\n;; Key points:\n;; - Gerbil must be built from source (no apt package)\n;; - Cache the Gerbil installation to speed up subsequent runs\n;; - Set GERBIL_HOME, GERBIL_LOADPATH, and PATH for gerbil/gxi/gxc\n;; - For Qt projects: QT_QPA_PLATFORM=offscreen for headless testing\n;; - For FFI projects: PKG_CONFIG_PATH must include system pkgconfig dir\n;;\n;; name: CI\n;; on:\n;;   push:\n;;     branches: [master]\n;;   pull_request:\n;;     branches: [master]\n;;\n;; jobs:\n;;   build-and-test:\n;;     runs-on: ubuntu-24.04\n;;     steps:\n;;       - uses: actions/checkout@v4\n;;\n;;       - name: Install system dependencies\n;;         run: |\n;;           sudo apt-get update\n;;           sudo apt-get install -y \\\n;;             libgambit \\       # Gambit Scheme runtime\n;;             autoconf git \\    # needed to build Gerbil\n;;             pkg-config g++ \\  # needed for FFI compilation\n;;             <your-c-library-dev-package>\n;;\n;;       - name: Cache Gerbil installation\n;;         uses: actions/cache@v4\n;;         id: cache-gerbil\n;;         with:\n;;           path: ~/gerbil\n;;           key: gerbil-v0.19-${{ runner.os }}-${{ hashFiles('.github/workflows/ci.yml') }}\n;;\n;;       - name: Install Gerbil\n;;         if: steps.cache-gerbil.outputs.cache-hit != 'true'\n;;         run: |\n;;           cd /tmp\n;;           git clone https://github.com/mighty-gerbils/gerbil.git\n;;           cd gerbil/src\n;;           ./configure --prefix=$HOME/gerbil\n;;           make -j$(nproc)\n;;           make install\n;;\n;;       - name: Set up environment\n;;         run: |\n;;           echo \"$HOME/gerbil/bin\" >> $GITHUB_PATH\n;;           echo \"GERBIL_HOME=$HOME/gerbil\" >> $GITHUB_ENV\n;;           echo \"GERBIL_LOADPATH=$HOME/.gerbil/lib\" >> $GITHUB_ENV\n;;\n;;       - name: Build\n;;         run: make build\n;;\n;;       - name: Test\n;;         run: make test",
    "notes": "Gerbil is not available as an apt package — must be built from source. The libgambit package provides the Gambit runtime that Gerbil compiles against. Cache the ~/gerbil directory to avoid rebuilding on every CI run (saves ~3-5 minutes). For Qt FFI projects, add `env: QT_QPA_PLATFORM: offscreen` to the Test step and `qt6-base-dev` to system dependencies. For other C libraries, add the appropriate `-dev` package. The cache key includes the workflow file hash so cache invalidates when CI config changes.",
    "related": [
      "qt-offscreen-headless-testing",
      "build-ffi-module-with-pkg-config"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "lsp-handler-test-pattern",
    "title": "LSP handler integration test pattern with state setup and validation",
    "tags": [
      "lsp",
      "test",
      "handler",
      "integration",
      "validate-response",
      "make-document",
      "state"
    ],
    "imports": [
      ":std/test",
      ":lsp/lsp/types",
      ":lsp/lsp/state",
      ":lsp/lsp/analysis/document",
      ":lsp/lsp/analysis/parser",
      ":lsp/lsp/analysis/symbols",
      ":lsp/lsp/validation"
    ],
    "code": ";; Pattern for testing LSP handlers with proper state setup and cleanup.\n;; 1. Create document + parse + extract symbols + set state\n;; 2. Build LSP params hash\n;; 3. Call handler\n;; 4. Verify response structure + validate against LSP schema\n;; 5. Cleanup state\n\n(test-case \"handle-X: integration test\"\n  (let* ((uri \"file:///test-example.ss\")\n         (text \"(def (add a b) (+ a b))\\n(add 1 2)\")\n         (doc (make-document uri 1 text \"gerbil\"))\n         (forms (parse-source text))\n         (syms (extract-symbols forms)))\n    ;; Setup state\n    (set-document! uri doc)\n    (set-file-symbols! uri syms)\n    ;; Call handler\n    (let* ((params (hash (\"textDocument\" (hash (\"uri\" uri)))\n                         (\"position\" (hash (\"line\" 1) (\"character\" 1)))))\n           (result (handle-hover params)))\n      (check (hash-table? result) => #t)\n      ;; Validate against LSP schema\n      (let ((violations (validate-response \"textDocument/hover\" result)))\n        (check (null? violations) => #t)))\n    ;; Cleanup\n    (remove-document! uri)\n    (remove-file-symbols! uri)))\n\n;; For \"missing document\" tests, handlers return void, empty list, or empty vector:\n(test-case \"handle-X: empty for missing document\"\n  (let* ((params (hash (\"textDocument\" (hash (\"uri\" \"file:///nonexistent.ss\")))\n                       (\"position\" (hash (\"line\" 0) (\"character\" 0)))))\n         (result (handle-some-handler params)))\n    (check (or (void? result)\n               (null? result)\n               (and (vector? result) (= (vector-length result) 0))) => #t)))",
    "notes": "Key points: (1) make-document takes (uri version text language-id). (2) make-sym-info takes 7 args: (name kind line col end-line end-col detail). (3) Handlers for missing documents return void, empty list [], or empty vector — NOT a standardized response, so test for all three. (4) validate-response from :lsp/lsp/validation checks responses against LSP protocol schemas. (5) Always cleanup with remove-document! and remove-file-symbols! to avoid polluting state between tests.",
    "related": [
      "write-tests-with-std-test"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-action-create-parent-keyword",
    "title": "qt-action-create requires parent: keyword arg, not positional",
    "tags": [
      "qt",
      "action",
      "create",
      "parent",
      "keyword",
      "menu",
      "toolbar"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: qt-action-create takes parent: as a KEYWORD argument.\n;; Passing parent as a positional arg silently creates a broken action.\n;;\n;; WRONG — parent passed as positional arg:\n;; (qt-action-create \"Open\" win)  ;; BROKEN! \"win\" treated as unknown positional\n;;\n;; CORRECT — use parent: keyword:\n(qt-action-create \"Open\" parent: win)\n(qt-action-create \"&File\" parent: menu-bar)\n(qt-action-create \"Cut\" parent: toolbar)\n\n;; Full signature:\n;;   (qt-action-create text [parent: widget] [checkable: bool])\n;;\n;; Common usage with menu bar:\n(let* ((menu-bar (qt-main-window-menu-bar win))\n       (file-menu (qt-menu-bar-add-menu! menu-bar \"&File\"))\n       (open-action (qt-action-create \"&Open\" parent: win)))\n  (qt-menu-add-action! file-menu open-action)\n  (qt-on-action-triggered! open-action\n    (lambda () (displayln \"Open!\"))))",
    "notes": "This mistake appeared in multiple example files (mdi.ss, dockable.ss, trayapp.ss). The error is silent — the action is created but may not work correctly because the second positional arg is misinterpreted. Always use parent: keyword.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-layout-requires-parent-widget",
    "title": "qt-hbox-layout-create and qt-vbox-layout-create require a parent widget",
    "tags": [
      "qt",
      "layout",
      "hbox",
      "vbox",
      "parent",
      "widget",
      "create"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: qt-hbox-layout-create and qt-vbox-layout-create require\n;; a parent widget argument. They cannot be called with 0 arguments.\n;;\n;; WRONG — no parent widget:\n;; (qt-hbox-layout-create)  ;; ERROR: wrong number of arguments\n;;\n;; CORRECT — pass a container widget:\n(let* ((container (qt-widget-create))\n       (hbox (qt-hbox-layout-create container)))\n  (qt-layout-add-widget! hbox (qt-label-create \"Left\"))\n  (qt-layout-add-widget! hbox (qt-line-edit-create))\n  ;; Add the container (not the layout) to the parent layout:\n  (qt-layout-add-widget! parent-vbox container))\n\n;; Pattern: filter bar with label + input\n(let* ((filter-row (qt-widget-create))\n       (filter-hbox (qt-hbox-layout-create filter-row))\n       (filter-label (qt-label-create \"Filter:\"))\n       (filter-edit (qt-line-edit-create)))\n  (qt-layout-add-widget! filter-hbox filter-label)\n  (qt-layout-add-widget! filter-hbox filter-edit)\n  ;; Add the container widget to the main layout\n  (qt-layout-add-widget! main-vbox filter-row))",
    "notes": "When adding a sub-layout to a parent layout, you add the CONTAINER WIDGET (not the layout itself) via qt-layout-add-widget!. The layout is associated with the container via the parent arg to qt-hbox-layout-create. This pattern is used whenever you need a horizontal row inside a vertical layout.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-with-qt-app-syntax",
    "title": "with-qt-app macro syntax: bare symbol, not parenthesized",
    "tags": [
      "qt",
      "with-qt-app",
      "macro",
      "syntax",
      "application",
      "main"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: with-qt-app binds a BARE symbol, not a parenthesized form.\n;;\n;; WRONG — parenthesized binding:\n;; (with-qt-app (app)    ;; ERROR! Syntax error\n;;   (qt-widget-show! win)\n;;   (qt-app-exec! app))\n;;\n;; CORRECT — bare symbol:\n(with-qt-app app\n  (let ((win (qt-main-window-create)))\n    (qt-main-window-set-title! win \"Hello\")\n    (qt-widget-show! win)\n    (qt-app-exec! app)))\n\n;; The macro expands to something like:\n;; (let ((app (qt-app-create)))\n;;   (dynamic-wind void\n;;     (lambda () body ...)\n;;     (lambda () (qt-app-destroy! app))))",
    "notes": "Common mistake when coming from other Scheme macros like with-exception-handler or parameterize that use parenthesized binding forms. The with-qt-app macro takes a single bare identifier followed by body expressions.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-mutator-bang-convention",
    "title": "All gerbil-qt mutator functions end with ! (bang)",
    "tags": [
      "qt",
      "mutator",
      "bang",
      "convention",
      "set",
      "naming"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; CONVENTION: ALL gerbil-qt functions that modify state end with !\n;; Missing the ! is a common source of \"unbound identifier\" errors.\n;;\n;; WRONG — missing bangs:\n;; (qt-main-window-set-title win \"Hello\")       ;; UNBOUND\n;; (qt-widget-resize win 800 600)                ;; UNBOUND\n;; (qt-main-window-set-central-widget win panel) ;; UNBOUND\n;; (qt-app-exec app)                             ;; UNBOUND\n;;\n;; CORRECT — all mutators have !:\n(qt-main-window-set-title! win \"Hello\")\n(qt-widget-resize! win 800 600)\n(qt-main-window-set-central-widget! win panel)\n(qt-app-exec! app)\n\n;; Pattern: functions WITHOUT ! are pure queries:\n;; (qt-widget-width w)        ;; query — no !\n;; (qt-label-text label)      ;; query — no !\n;; (qt-check-box-checked? cb) ;; predicate — no !\n;;\n;; Functions WITH ! modify state:\n;; (qt-widget-show! w)        ;; side effect — has !\n;; (qt-label-set-text! l t)   ;; mutation — has !\n;; (qt-widget-destroy! w)     ;; destruction — has !",
    "notes": "This Scheme convention (! for side effects) is strictly followed throughout gerbil-qt. When you get an \"unbound identifier\" error for a qt-* function, first check whether you forgot the trailing !. Common offenders: qt-app-exec!, qt-widget-resize!, qt-main-window-set-title!, qt-main-window-set-central-widget!.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-on-return-pressed-not-line-edit-return",
    "title": "Use qt-on-return-pressed! (not qt-on-line-edit-return!) for Enter key in QLineEdit",
    "tags": [
      "qt",
      "line-edit",
      "return",
      "enter",
      "pressed",
      "callback",
      "signal"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: The signal for Enter key in QLineEdit is qt-on-return-pressed!\n;; There is NO function called qt-on-line-edit-return!\n;;\n;; WRONG — does not exist:\n;; (qt-on-line-edit-return! input (lambda (text) (handle text)))\n;;\n;; CORRECT — void callback (no text argument):\n(qt-on-return-pressed! input\n  (lambda ()\n    (let ((text (qt-line-edit-text input)))\n      (displayln \"User entered: \" text)\n      (qt-line-edit-clear! input))))\n\n;; The callback takes NO arguments (void trampoline).\n;; To get the text, call qt-line-edit-text inside the callback.",
    "notes": "The callback is a void trampoline (no arguments), not a string trampoline. You must explicitly read the line edit's text inside the callback using qt-line-edit-text. This matches Qt's returnPressed() signal which also carries no arguments.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-status-bar-text-via-main-window",
    "title": "Set status bar text via qt-main-window-set-status-bar-text!, not qt-status-bar-show-message!",
    "tags": [
      "qt",
      "status",
      "bar",
      "message",
      "main-window",
      "text"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: There is no qt-main-window-status-bar function to get a\n;; QStatusBar object. Instead, use qt-main-window-set-status-bar-text!\n;; which operates directly on the main window.\n;;\n;; WRONG — these don't exist:\n;; (def sb (qt-main-window-status-bar win))     ;; UNBOUND\n;; (qt-status-bar-show-message! sb \"Ready\")     ;; UNBOUND\n;;\n;; CORRECT — set status bar text via main window:\n(qt-main-window-set-status-bar-text! win \"Ready\")\n(qt-main-window-set-status-bar-text! win \"File saved successfully\")\n\n;; Use in callbacks:\n(qt-on-action-triggered! save-action\n  (lambda ()\n    (save-file!)\n    (qt-main-window-set-status-bar-text! win \"Saved!\")))",
    "notes": "In gerbil-qt, the status bar is not exposed as a separate object. All status bar operations go through the main window. Qt automatically creates the status bar on first use. The message persists until replaced by another call.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-patchelf-rpath-install-makefile",
    "title": "Use patchelf --add-rpath in Makefile install for vendored .so libraries",
    "tags": [
      "qt",
      "patchelf",
      "rpath",
      "install",
      "makefile",
      "vendor",
      "shared-library",
      "ffi"
    ],
    "imports": [],
    "code": ";; PROBLEM: gxc/Gambit drops extra -Wl,-rpath options passed via -ld-options.\n;; Only the FIRST rpath survives compilation. If your project has a vendored\n;; .so (e.g. libqt_shim.so) and you want both a local AND install rpath,\n;; the install rpath gets dropped.\n;;\n;; SOLUTION: Use patchelf --add-rpath in the Makefile install target\n;; to patch the compiled .o1 files AFTER build.\n;;\n;; ---- Makefile pattern ----\n;; INSTALL_DIR = $(HOME)/.gerbil/lib/gerbil-qt\n;;\n;; install: build\n;; \t@mkdir -p $(INSTALL_DIR)\n;; \tcp -f .gerbil/lib/gerbil-qt/* $(INSTALL_DIR)/\n;; \tcp -f vendor/libqt_shim.so $(INSTALL_DIR)/\n;; \t@if command -v patchelf >/dev/null 2>&1; then \\\n;; \t\tfor f in $(INSTALL_DIR)/libqt~0.o*; do \\\n;; \t\t\tpatchelf --add-rpath $(INSTALL_DIR) \"$$f\" 2>/dev/null || true; \\\n;; \t\tdone; \\\n;; \tfi\n;; ---- end ----\n;;\n;; KEY DIFFERENCES from --set-rpath:\n;; - --add-rpath APPENDS to existing RUNPATH (preserves build-time paths)\n;; - --set-rpath REPLACES the entire RUNPATH (may break build-time paths)\n;;\n;; Verify with:\n;;   patchelf --print-rpath ~/.gerbil/lib/gerbil-qt/libqt~0.o1\n;;   # Should show: /path/to/vendor:/home/user/.gerbil/lib/gerbil-qt",
    "notes": "The existing patchelf recipes use --set-rpath which replaces the entire RUNPATH. For FFI libraries with vendored .so files, --add-rpath is better because it preserves the build-time rpath (pointing to vendor/) while adding the install location. The `command -v patchelf` guard makes the install target work even without patchelf installed (just won't patch rpath). The libqt~0.o* glob matches Gambit's compiled output naming convention.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-splitter-create-requires-orientation",
    "title": "qt-splitter-create requires orientation as positional arg",
    "tags": [
      "qt",
      "splitter",
      "create",
      "orientation",
      "QT_VERTICAL",
      "QT_HORIZONTAL",
      "arity"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: qt-splitter-create requires orientation as a mandatory positional arg.\n;; Calling (qt-splitter-create) with 0 args fails with arity mismatch.\n;;\n;; WRONG:\n;; (qt-splitter-create)  ;; ERROR: arity mismatch\n;;\n;; CORRECT — pass orientation constant:\n(qt-splitter-create QT_VERTICAL)     ;; top/bottom split\n(qt-splitter-create QT_HORIZONTAL)   ;; left/right split\n\n;; Full signature:\n;;   (qt-splitter-create orientation [parent: widget])\n;;\n;; Constants: QT_VERTICAL = 2, QT_HORIZONTAL = 1\n;;\n;; Example: table view above, detail panel below\n(let ((splitter (qt-splitter-create QT_VERTICAL)))\n  (qt-splitter-add-widget! splitter table-view)\n  (qt-splitter-add-widget! splitter detail-panel)\n  (qt-splitter-set-sizes! splitter '(500 250))\n  splitter)",
    "notes": "The orientation is positional (not a keyword), and parent: is a keyword. This is unlike most other create functions in gerbil-qt where all args are keywords. The compile error message is cryptic: 'Illegal lambda application; arity mismatch' with detail 3.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-toolbar-create-requires-title",
    "title": "qt-toolbar-create requires title as positional arg",
    "tags": [
      "qt",
      "toolbar",
      "create",
      "title",
      "arity",
      "main-window"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: qt-toolbar-create requires a title string as positional arg.\n;; Calling (qt-toolbar-create) with 0 args fails with arity mismatch.\n;;\n;; WRONG:\n;; (qt-toolbar-create)  ;; ERROR: arity mismatch\n;;\n;; CORRECT:\n(qt-toolbar-create \"Main\")\n(qt-toolbar-create \"Tools\" parent: win)\n\n;; Full signature:\n;;   (qt-toolbar-create title [parent: widget])\n;;\n;; Example with main window:\n(let ((toolbar (qt-toolbar-create \"Main\")))\n  (qt-toolbar-set-movable! toolbar #f)\n  (let ((action (qt-action-create \"Save\")))\n    (qt-toolbar-add-action! toolbar action))\n  (qt-toolbar-add-separator! toolbar)\n  (qt-toolbar-add-widget! toolbar (qt-line-edit-create))\n  (qt-main-window-add-toolbar! win toolbar))",
    "notes": "Title is positional (not keyword), parent: is keyword. Similar pattern to qt-action-create which also requires text as positional.",
    "related": [
      "qt-action-create-requires-parent-keyword"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-file-dialog-open-directory-signature",
    "title": "qt-file-dialog-open-directory takes parent positional, caption/dir as keywords",
    "tags": [
      "qt",
      "file-dialog",
      "directory",
      "open",
      "caption",
      "dialog"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; qt-file-dialog-open-directory signature:\n;;   (qt-file-dialog-open-directory parent [caption: string] [dir: string])\n;;\n;; parent is a required positional arg (the parent window)\n;; caption: defaults to \"Open Directory\"\n;; dir: defaults to \"\" (current directory)\n;;\n;; WRONG — passing caption as positional:\n;; (qt-file-dialog-open-directory win \"Choose Folder\")  ;; ERROR: arity mismatch\n;;\n;; CORRECT — caption as keyword:\n(qt-file-dialog-open-directory win caption: \"Choose Folder\")\n(qt-file-dialog-open-directory win caption: \"Open Database\" dir: \"/home\")\n\n;; Returns a string path, or empty string if canceled\n(let ((path (qt-file-dialog-open-directory win caption: \"Open Database\")))\n  (when (and (string? path) (> (string-length path) 0))\n    (displayln \"Selected: \" path)))",
    "notes": "Similar pattern for qt-file-dialog-open-file and qt-file-dialog-save-file which take parent positional plus keyword args for caption, dir, and filter.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-form-layout-spanning-widget",
    "title": "Use qt-form-layout-add-spanning-widget! for single-widget rows (not add-row-widget!)",
    "tags": [
      "qt",
      "form-layout",
      "spanning",
      "checkbox",
      "widget",
      "row"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: qt-form-layout-add-row-widget! takes 3 args: (layout label-widget field-widget)\n;; It adds a row with TWO widgets (label + field), not a spanning single widget.\n;;\n;; To add a SINGLE widget that spans the entire row (e.g. a checkbox or button bar),\n;; use qt-form-layout-add-spanning-widget! which takes 2 args: (layout widget)\n;;\n;; WRONG — for adding a checkbox that spans the whole row:\n;; (qt-form-layout-add-row-widget! layout my-checkbox)  ;; ERROR: arity mismatch (expects 3 args)\n;;\n;; CORRECT:\n(qt-form-layout-add-spanning-widget! layout my-checkbox)\n\n;; Example: complete form with labels, fields, and a spanning checkbox\n(let* ((dlg (qt-dialog-create parent: win))\n       (layout (qt-form-layout-create parent: dlg))\n       (name-edit (qt-line-edit-create))\n       (email-edit (qt-line-edit-create))\n       (newsletter-check (qt-check-box-create \"Subscribe to newsletter\")))\n  (qt-form-layout-add-row! layout \"Name:\" name-edit)\n  (qt-form-layout-add-row! layout \"Email:\" email-edit)\n  (qt-form-layout-add-spanning-widget! layout newsletter-check)\n  (qt-dialog-exec! dlg))",
    "notes": "qt-form-layout-add-row! takes (layout label-string field-widget) for string labels. qt-form-layout-add-row-widget! takes (layout label-widget field-widget) for widget labels. qt-form-layout-add-spanning-widget! takes (layout widget) for a widget spanning the full row.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-standard-model-create-keyword-args",
    "title": "qt-standard-model-create uses rows: cols: parent: keyword args",
    "tags": [
      "qt",
      "model",
      "standard-model",
      "create",
      "rows",
      "cols",
      "table"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; qt-standard-model-create signature:\n;;   (qt-standard-model-create [rows: n] [cols: n] [parent: widget])\n;; All args are KEYWORD (not positional). Defaults: rows: 0, cols: 0, parent: #f\n;;\n;; WRONG — positional args:\n;; (qt-standard-model-create 0 8)  ;; ERROR\n;;\n;; CORRECT — keyword args:\n(qt-standard-model-create rows: 0 cols: 8)\n\n;; Set column headers one at a time:\n;;   (qt-standard-model-set-horizontal-header! model column-index text)\n(let ((model (qt-standard-model-create rows: 0 cols: 3)))\n  (qt-standard-model-set-horizontal-header! model 0 \"Name\")\n  (qt-standard-model-set-horizontal-header! model 1 \"Value\")\n  (qt-standard-model-set-horizontal-header! model 2 \"Type\")\n  model)\n\n;; qt-standard-item-create uses text: keyword:\n;;   (qt-standard-item-create [text: string])\n;; Default: text: \"\"\n(qt-standard-item-create text: \"Hello\")\n\n;; Populate model row by row:\n(qt-standard-model-set-row-count! model 1)\n(qt-standard-model-set-item! model 0 0 (qt-standard-item-create text: \"Alice\"))\n(qt-standard-model-set-item! model 0 1 (qt-standard-item-create text: \"42\"))\n(qt-standard-model-set-item! model 0 2 (qt-standard-item-create text: \"user\"))",
    "notes": "qt-standard-model-set-horizontal-header! takes (model col text) — sets one header at a time, not a list. qt-standard-item-create takes text: keyword (not positional). The text defaults to empty string.",
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "macos-codesign-install-binary",
    "title": "Re-sign Gerbil binary after cp install on macOS (SIGKILL fix)",
    "tags": [
      "macOS",
      "codesign",
      "install",
      "SIGKILL",
      "binary",
      "Makefile",
      "adhoc",
      "cp"
    ],
    "imports": [],
    "code": ";; PROBLEM: On macOS (Apple Silicon and Intel), copying a compiled Gerbil\n;; binary with `sudo cp` to /usr/local/bin/ causes it to be killed with\n;; signal 9 (SIGKILL) when executed.\n;;\n;; ROOT CAUSE: The Gambit linker creates an adhoc code signature tied to\n;; the file's modification time (cs_mtime). When `cp` creates a new file,\n;; it gets a new mtime that doesn't match the embedded cs_mtime. macOS\n;; AMFI (AppleMobileFileIntegrity) detects the mismatch and kills the\n;; process. The kernel log shows:\n;;   cs_mtime:XXXX != mtime:YYYY\n;;   CODE SIGNING: rejecting invalid page...\n;;   ASP: Security policy would not allow process\n;;\n;; The binaries are byte-identical (same MD5, same CDHash), but the\n;; mtime mismatch is enough for macOS to reject execution.\n;;\n;; FIX: Re-sign the binary after copying with `codesign --force --sign -`\n;;\n;; ---- Makefile pattern ----\n;; install: build\n;; \tsudo cp .gerbil/bin/my-app /usr/local/bin/\n;; \tsudo codesign --force --sign - /usr/local/bin/my-app\n;; ---- end ----\n;;\n;; ALTERNATIVES (less robust):\n;; - `sudo cp -p` preserves mtime (fragile, may fail on some filesystems)\n;; - `sudo install -p` also preserves mtime (same fragility)\n;;\n;; The codesign approach is most robust because it creates a fresh valid\n;; signature for the file in its final location regardless of mtime.",
    "notes": "This affects ALL compiled Gerbil/Gambit executables on macOS, not just specific projects. The adhoc linker-signed signature (flags=0x20002) is created by Gambit's C compiler backend. The issue manifests as: binary works from build dir (.gerbil/bin/) but gets SIGKILL when copied elsewhere. Diagnosis: check kernel logs with `log show --predicate 'eventMessage contains \"CODE SIGNING\"' --last 5m` or look for cs_mtime mismatch. `codesign --verify` may still report \"valid on disk\" even when runtime execution is rejected.",
    "related": [
      "patchelf-add-rpath-install",
      "gxc-exe-makefile-link"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ffi-multiple-inheritance-void-ptr-cast",
    "title": "C++ FFI: cast through correct base class before void* when multiple inheritance is involved",
    "tags": [
      "ffi",
      "multiple-inheritance",
      "void-pointer",
      "cast",
      "segfault",
      "QGraphicsTextItem",
      "QGraphicsObject"
    ],
    "imports": [],
    "code": "// C++ GOTCHA: When a class uses multiple inheritance and you pass\n// pointers through void* (as FFI requires), you MUST cast to the\n// correct base class BEFORE casting to void*.\n//\n// static_cast<void*>(DerivedPtr) preserves the raw address.\n// static_cast<BaseClass*>(void_ptr) does NOT adjust for MI offset.\n// So if BaseClass is not at offset 0, you get a wrong pointer → segfault.\n//\n// EXAMPLE: Qt's QGraphicsTextItem hierarchy:\n//   QGraphicsTextItem → QGraphicsObject → QObject + QGraphicsItem\n//                                          ^^^^^^^^   ^^^^^^^^^^^^^\n//                                          offset 0   offset N (not 0!)\n//\n// WRONG — segfaults when the void* is later cast to QGraphicsItem*:\n//   extern \"C\" void* qt_graphics_scene_add_text(void* scene, const char* text) {\n//       auto* s = static_cast<QGraphicsScene*>(scene);\n//       return static_cast<void*>(s->addText(QString::fromUtf8(text)));\n//       //     ^^^ addText returns QGraphicsTextItem* — void* preserves\n//       //         the QObject subobject address, NOT QGraphicsItem address\n//   }\n//\n// CORRECT — cast to QGraphicsItem* first, THEN to void*:\n//   extern \"C\" void* qt_graphics_scene_add_text(void* scene, const char* text) {\n//       auto* s = static_cast<QGraphicsScene*>(scene);\n//       QGraphicsItem* item = s->addText(QString::fromUtf8(text));\n//       //             ^^^^ compiler adjusts pointer for MI here\n//       return static_cast<void*>(item);\n//   }\n//\n// SAFE item types (single inheritance from QGraphicsItem):\n//   QGraphicsRectItem → QAbstractGraphicsShapeItem → QGraphicsItem ✓\n//   QGraphicsEllipseItem → QAbstractGraphicsShapeItem → QGraphicsItem ✓\n//   QGraphicsLineItem → QGraphicsItem ✓\n//   QGraphicsPixmapItem → QGraphicsItem ✓\n//\n// DANGEROUS (multiple inheritance via QGraphicsObject):\n//   QGraphicsTextItem → QGraphicsObject → QObject + QGraphicsItem ✗\n//   QGraphicsProxyWidget → QGraphicsObject → QObject + QGraphicsItem ✗\n//\n// RULE: Any time a C++ class inherits from QGraphicsObject (or any\n// class with multiple bases), cast to the target base BEFORE void*.",
    "notes": "This caused a real segfault in gerbil-qt's diagram.ss example. The pointer returned by addText() pointed to the QObject subobject. When later cast to QGraphicsItem* and used with setPos(), setBrush(), etc., it dereferenced garbage memory. The fix is a single line change: assign to QGraphicsItem* before void*. Same issue would affect any QGraphicsObject-derived type (QGraphicsProxyWidget, custom QGraphicsObject subclasses). Single-inheritance item types (rect, ellipse, line, pixmap) are unaffected because QGraphicsItem is their only base at offset 0.",
    "related": [
      "qt-graphics-scene-view-items",
      "qt-graphics-item-set-pen-brush-dynamic-cast",
      "gambit-ffi-pointer-types"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "deferror-class-extra-fields-keyword-constructor",
    "title": "deferror-class with extra fields uses keyword args in constructor",
    "tags": [
      "deferror-class",
      "error",
      "constructor",
      "keyword",
      "fields",
      "make"
    ],
    "imports": [
      ":std/error",
      ":std/format"
    ],
    "code": ";; deferror-class with extra fields generates a constructor that takes\n;; the error message as the first positional arg, then keyword args for fields.\n;;\n;; Define error with extra fields:\n(deferror-class WebexApiError (status-code response-body)\n  webex-api-error?)\n\n(deferror-class (WebexAuthError WebexApiError) ()\n  webex-auth-error?)\n\n(deferror-class (WebexRateLimitError WebexApiError) (retry-after)\n  webex-rate-limit-error?)\n\n;; WRONG — positional args for fields:\n;; (make-WebexApiError \"error msg\" [] 'webex-api-error 404 \"not found\")\n;; ERROR: arguments don't match object size\n\n;; CORRECT — message is positional, fields are keyword args:\n(def (raise-webex-api-error status-code body)\n  (raise (make-WebexApiError (format \"Webex API Error (~a): ~a\" status-code body)\n                             status-code: status-code response-body: body)))\n\n;; Child class inherits parent's keyword fields:\n(def (raise-webex-auth-error body)\n  (raise (make-WebexAuthError (format \"Authentication failed: ~a\" body)\n                              status-code: 401 response-body: body)))\n\n;; Child with its own extra field adds another keyword:\n(def (raise-webex-rate-limit body retry-after)\n  (raise (make-WebexRateLimitError (format \"Rate limited: ~a\" body)\n                                   status-code: 429 response-body: body\n                                   retry-after: retry-after)))\n\n;; Accessing fields uses the generated accessors:\n;; (WebexApiError-status-code e)\n;; (WebexApiError-response-body e)\n;; (WebexRateLimitError-retry-after e)",
    "notes": "Unlike defstruct (which uses positional args), deferror-class generates class-based constructors that accept keyword arguments for the extra fields. The first argument is always the error message string (positional). Parent class fields are inherited and also set via keywords in child constructors. This is because deferror-class uses defclass internally, not defstruct.",
    "related": [
      "error-handling",
      "defstruct-positional-args"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "getopt-nested-subcommands-rest-arguments",
    "title": "Nested subcommands via rest-arguments and inner call-with-getopt",
    "tags": [
      "getopt",
      "subcommand",
      "nested",
      "rest-arguments",
      "cli",
      "command"
    ],
    "imports": [
      ":std/cli/getopt",
      ":std/sugar"
    ],
    "code": ";; getopt's (command ...) CANNOT contain child (command ...) forms.\n;; Attempting to nest commands causes: \"cannot contain subcommands\" error.\n;;\n;; WRONG — nested commands:\n;; (command 'messages help: \"Messages\"\n;;   (command 'list help: \"List messages\" ...)\n;;   (command 'get help: \"Get a message\" ...))\n\n;; CORRECT — use rest-arguments to capture subcommand args,\n;; then dispatch with an inner call-with-getopt:\n\n;; Define inner subcommands separately\n(def messages-list-cmd\n  (command 'list help: \"List messages\"\n    (option 'room-id \"--room-id\" \"-r\" help: \"Room ID\")))\n\n(def messages-get-cmd\n  (command 'get help: \"Get a message\"\n    (argument 'message-id help: \"Message ID\")))\n\n;; Parent command captures everything after 'messages' as rest args\n(def messages-cmd\n  (command 'messages help: \"Manage messages\"\n    (rest-arguments 'rest-arguments help: \"subcommand and args\")))\n\n;; Top-level dispatch\n(def (main . args)\n  (call-with-getopt\n    (lambda (cmd opt)\n      (case cmd\n        ((messages) (handle-messages opt))\n        ((rooms)    (handle-rooms opt))))\n    args\n    program: \"webex\"\n    help: \"Webex CLI\"\n    messages-cmd))\n\n;; Inner dispatch for messages subcommands\n(def (handle-messages opt)\n  (let-hash opt\n    (call-with-getopt\n      (lambda (cmd opt)\n        (case cmd\n          ((list) (let-hash opt (displayln \"Listing room: \" .?room-id)))\n          ((get)  (let-hash opt (displayln \"Getting: \" .message-id)))))\n      .rest-arguments\n      program: \"webex messages\"\n      help: \"Message commands\"\n      messages-list-cmd messages-get-cmd)))",
    "notes": "This two-level dispatch pattern is the standard way to implement nested subcommands (e.g., \"git remote add\") with :std/cli/getopt. The parent command uses rest-arguments to pass through everything to the inner call-with-getopt. Each level gets its own --help automatically. The .rest-arguments field is a list of strings, which is exactly what call-with-getopt expects for its args parameter.",
    "related": [
      "getopt-subcommand-handler-two-args",
      "cli-getopt-subcommands"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "jsonl-append-thread-safe",
    "title": "Thread-safe JSONL append logging with mutex and unwind-protect",
    "tags": [
      "jsonl",
      "log",
      "append",
      "mutex",
      "thread-safe",
      "json"
    ],
    "imports": [
      ":std/text/json",
      ":std/sugar"
    ],
    "code": ";; Thread-safe append of JSON objects to a JSONL file.\n;; Each line is a complete JSON object. Mutex protects concurrent writes.\n\n(def log-mutex (make-mutex 'log))\n\n(def (log-event! type data)\n  \"Append a JSON event to a JSONL file. Thread-safe.\"\n  (let ((event (hash (\"type\" type)\n                     (\"timestamp\" (number->string (time->seconds (current-time))))))\n    ;; Merge caller's data into event\n    (when (hash-table? data)\n      (hash-for-each (lambda (k v) (hash-put! event k v)) data))\n    (let ((path \"/path/to/events.jsonl\")\n          (line (string-append (json-object->string event) \"\\n\")))\n      (mutex-lock! log-mutex)\n      (unwind-protect\n        (call-with-output-file [path: path append: #t create: 'maybe]\n          (lambda (port)\n            (display line port)\n            (force-output port)))\n        (mutex-unlock! log-mutex)))))\n\n;; Usage:\n(log-event! \"api_error\"\n  (hash (\"endpoint\" \"/users\")\n        (\"status_code\" 404)\n        (\"message\" \"Not found\")))\n\n;; Reading JSONL back with optional filters:\n(def (read-events type: (type #f))\n  (let ((path \"/path/to/events.jsonl\"))\n    (if (file-exists? path)\n      (let ((events []))\n        (call-with-input-file path\n          (lambda (port)\n            (let loop ()\n              (let ((line (read-line port)))\n                (unless (eof-object? line)\n                  (when (> (string-length line) 0)\n                    (try\n                      (let ((ev (with-input-from-string line read-json)))\n                        (when (or (not type) (equal? (hash-get ev \"type\") type))\n                          (set! events (cons ev events))))\n                      (catch (e) (void))))\n                  (loop))))))\n        (reverse events))\n      [])))",
    "notes": "Key details: (1) call-with-output-file with [path: ... append: #t create: 'maybe] opens for append, creating the file only if needed. (2) unwind-protect ensures mutex-unlock! runs even on error. (3) force-output flushes the write immediately. (4) json-object->string serializes a hash table to a JSON string. (5) When reading back, wrap read-json in try/catch to skip malformed lines. (6) Use with-input-from-string to parse each line individually rather than read-json on the whole file (JSONL is not valid JSON as a whole).",
    "related": [
      "mutex-unwind-protect",
      "read-json-file"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-three-panel-chat-layout",
    "title": "Three-panel chat app layout with QSplitter (sidebar | content | detail)",
    "tags": [
      "qt",
      "splitter",
      "layout",
      "chat",
      "panel",
      "sidebar",
      "three-panel"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; PATTERN: Three-panel layout for chat/messaging apps.\n;; Left sidebar (room list) | Center (messages) | Right panel (participants)\n;; Uses nested QSplitter for resizable panels.\n\n(import :gerbil-qt/qt)\n\n(with-qt-app app\n  (let* ((win (qt-main-window-create))\n         (central (qt-widget-create))\n         (main-layout (qt-vbox-layout-create central))\n\n         ;; Main horizontal splitter: sidebar | content+right\n         (splitter (qt-splitter-create QT_HORIZONTAL))\n\n         ;; LEFT: Room list sidebar\n         (sidebar (qt-widget-create))\n         (sidebar-layout (qt-vbox-layout-create sidebar))\n         (search (qt-line-edit-create))\n         (room-list (qt-list-widget-create))\n\n         ;; CENTER: Messages area\n         (center (qt-widget-create))\n         (center-layout (qt-vbox-layout-create center))\n         (header-label (qt-label-create \"Select a room\"))\n         (messages (qt-text-browser-create))\n         (input-row (qt-widget-create))\n         (input-layout (qt-hbox-layout-create input-row))\n         (input (qt-line-edit-create))\n         (send-btn (qt-push-button-create \"Send\"))\n\n         ;; RIGHT: Participant list\n         (right-panel (qt-widget-create))\n         (right-layout (qt-vbox-layout-create right-panel))\n         (people-label (qt-label-create \"Participants\"))\n         (people-list (qt-list-widget-create)))\n\n    ;; Assemble sidebar\n    (qt-line-edit-set-placeholder! search \"Search rooms...\")\n    (qt-layout-add-widget! sidebar-layout search)\n    (qt-layout-add-widget! sidebar-layout room-list)\n    (qt-layout-set-margins! sidebar-layout 0 0 0 0)\n\n    ;; Assemble center\n    (qt-layout-add-widget! center-layout header-label)\n    (qt-layout-add-widget! center-layout messages)\n    (qt-layout-add-widget! input-layout input)\n    (qt-layout-add-widget! input-layout send-btn)\n    (qt-layout-add-widget! center-layout input-row)\n    (qt-layout-set-margins! center-layout 0 0 0 0)\n    ;; Give messages area stretch priority\n    (qt-layout-set-stretch-factor! center-layout 1 1)\n\n    ;; Assemble right panel\n    (qt-layout-add-widget! right-layout people-label)\n    (qt-layout-add-widget! right-layout people-list)\n    (qt-layout-set-margins! right-layout 0 0 0 0)\n\n    ;; Add all three to splitter\n    (qt-splitter-add-widget! splitter sidebar)\n    (qt-splitter-add-widget! splitter center)\n    (qt-splitter-add-widget! splitter right-panel)\n    (qt-splitter-set-sizes! splitter '(250 550 200))\n\n    ;; Make right panel collapsible\n    (qt-splitter-set-collapsible! splitter 2 #t)\n\n    ;; Set central widget\n    (qt-layout-add-widget! main-layout splitter)\n    (qt-layout-set-margins! main-layout 0 0 0 0)\n    (qt-main-window-set-central-widget! win central)\n\n    ;; Wire send button\n    (qt-on-clicked! send-btn\n      (lambda ()\n        (let ((text (qt-line-edit-text input)))\n          (when (> (string-length text) 0)\n            (qt-text-browser-set-html! messages\n              (string-append \"<b>You:</b> \" text))\n            (qt-line-edit-set-text! input \"\")))))\n\n    ;; Wire room selection\n    (qt-on-current-row-changed! room-list\n      (lambda (row)\n        (when (>= row 0)\n          (let ((name (qt-list-widget-item-text room-list row)))\n            (qt-label-set-text! header-label name)))))\n\n    ;; Add sample rooms\n    (qt-list-widget-add-item! room-list \"General\")\n    (qt-list-widget-add-item! room-list \"Engineering\")\n    (qt-list-widget-add-item! room-list \"Random\")\n\n    (qt-main-window-set-title! win \"Chat App\")\n    (qt-widget-resize! win 1000 700)\n    (qt-widget-show! win)\n    (qt-app-exec! app)))",
    "notes": "This is the foundational layout for a chat application. Key points: (1) qt-splitter-create requires QT_HORIZONTAL as positional arg. (2) Layouts require parent widgets — pass to qt-vbox-layout-create/qt-hbox-layout-create. (3) Use qt-splitter-set-collapsible! to allow hiding the right panel. (4) Set stretch factor on the messages widget so it expands. (5) Set margins to 0 for tight packing. Missing from gerbil-qt as of 2025: scrollToBottom for QTextBrowser, QListWidget item data storage, min/max size constraints on widgets.",
    "related": [
      "qt-splitter-orientation-positional",
      "qt-hbox-vbox-require-parent",
      "qt-text-browser-anchor-clicked"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-dark-theme-stylesheet",
    "title": "Apply dark theme CSS stylesheet to entire Qt application",
    "tags": [
      "qt",
      "dark",
      "theme",
      "stylesheet",
      "css",
      "styling",
      "appearance"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; PATTERN: Apply a dark theme to the entire application via qt-app-set-style-sheet!\n;; Call this AFTER qt-app-create but BEFORE showing any widgets.\n;; The stylesheet cascades to all widgets automatically.\n\n(import :gerbil-qt/qt)\n\n(def dark-theme-css \"\n  QWidget {\n    background-color: #1e1e2e;\n    color: #cdd6f4;\n    font-family: 'Segoe UI', 'SF Pro Display', sans-serif;\n    font-size: 13px;\n  }\n  QMainWindow { background-color: #1e1e2e; }\n  QLineEdit {\n    background-color: #313244;\n    border: 1px solid #45475a;\n    border-radius: 4px;\n    padding: 6px;\n    color: #cdd6f4;\n    selection-background-color: #585b70;\n  }\n  QLineEdit:focus { border-color: #89b4fa; }\n  QPushButton {\n    background-color: #89b4fa;\n    color: #1e1e2e;\n    border: none;\n    border-radius: 4px;\n    padding: 6px 16px;\n    font-weight: bold;\n  }\n  QPushButton:hover { background-color: #74c7ec; }\n  QPushButton:pressed { background-color: #585b70; }\n  QListWidget {\n    background-color: #181825;\n    border: none;\n    outline: none;\n  }\n  QListWidget::item {\n    padding: 8px 12px;\n    border-bottom: 1px solid #313244;\n  }\n  QListWidget::item:selected {\n    background-color: #313244;\n    color: #cdd6f4;\n  }\n  QListWidget::item:hover { background-color: #262637; }\n  QTextBrowser, QTextEdit, QPlainTextEdit {\n    background-color: #1e1e2e;\n    border: none;\n    color: #cdd6f4;\n  }\n  QLabel { background-color: transparent; }\n  QSplitter::handle {\n    background-color: #313244;\n    width: 1px;\n  }\n  QScrollBar:vertical {\n    background-color: #1e1e2e;\n    width: 8px;\n  }\n  QScrollBar::handle:vertical {\n    background-color: #45475a;\n    border-radius: 4px;\n    min-height: 20px;\n  }\n  QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {\n    height: 0px;\n  }\n  QMenuBar {\n    background-color: #181825;\n    color: #cdd6f4;\n    border-bottom: 1px solid #313244;\n  }\n  QMenuBar::item:selected { background-color: #313244; }\n  QMenu {\n    background-color: #1e1e2e;\n    color: #cdd6f4;\n    border: 1px solid #45475a;\n  }\n  QMenu::item:selected { background-color: #313244; }\n\")\n\n;; Apply at startup:\n(with-qt-app app\n  (qt-app-set-style-sheet! app dark-theme-css)\n  (let ((win (qt-main-window-create)))\n    ;; ... build UI ...\n    (qt-widget-show! win)\n    (qt-app-exec! app)))",
    "notes": "Uses Catppuccin Mocha color palette. qt-app-set-style-sheet! applies to all widgets. Can also use qt-widget-set-style-sheet! on individual widgets to override. CSS selectors support pseudo-states (:hover, :pressed, :focus, :selected) and sub-controls (::handle, ::item). QSplitter handle width controls the draggable separator. Scrollbar styling removes the arrow buttons for a modern look. The font-family falls back through platform-specific sans-serif fonts.",
    "related": [
      "qt-three-panel-chat-layout",
      "qt-widget-set-font-arity"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "makefile-safe-clean-preserve-pkg",
    "title": "Makefile clean target that preserves .gerbil/pkg/ manifests",
    "tags": [
      "makefile",
      "clean",
      "pkg",
      "manifest",
      "build",
      "preserve"
    ],
    "imports": [],
    "code": ";; PROBLEM: `make clean` with `rm -rf .gerbil` destroys package manifests.\n;; After clean, `gerbil build` fails with:\n;;   No such file or directory\n;;   (call-with-input-file \".gerbil/pkg/.../package.manifest\" ...)\n;;\n;; FIX: Only remove .gerbil/lib and .gerbil/bin, preserving .gerbil/pkg/\n;;\n;; ---- Makefile ----\n;; clean:\n;; \trm -rf .gerbil/lib .gerbil/bin manifest.ss\n;; ---- end ----\n;;\n;; WRONG (destroys manifests):\n;; clean:\n;; \trm -rf .gerbil manifest.ss\n;;\n;; After a correct clean, `gerbil build` can still resolve dependencies\n;; because .gerbil/pkg/ manifests remain intact.\n;;\n;; If .gerbil/pkg/ IS already gone, restore manifests from global:\n;;   mkdir -p .gerbil/pkg/github.com/user/\n;;   cp ~/.gerbil/pkg/github.com/user/package.manifest .gerbil/pkg/github.com/user/",
    "notes": "This is the recommended clean pattern for any Gerbil project with dependencies declared in gerbil.pkg. The .gerbil/pkg/ directory contains only small manifest text files — preserving it avoids the need to re-install or copy manifests after every clean build. Combined with GERBIL_LOADPATH=~/.gerbil/lib in the build target, this gives reliable clean builds.",
    "related": [
      "gerbil-build-loadpath",
      "gerbil-build-missing-manifests"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-reactive-state-callbacks",
    "title": "Reactive state management with callbacks for Qt GUI apps",
    "tags": [
      "qt",
      "state",
      "callback",
      "reactive",
      "gui",
      "hash",
      "mutable"
    ],
    "imports": [],
    "code": ";; PATTERN: Centralized mutable state with change callbacks for Qt GUI.\n;; Keeps UI updates decoupled from state mutations.\n\n;; 1. Define state and callback infrastructure\n(def *app-state* (hash))\n(def *state-callbacks* [])\n\n(def (state-init!)\n  (set! *app-state*\n    (hash (current-room-id #f)\n          (status-text \"Disconnected\"))))\n\n(def (state-ref key (default #f))\n  (hash-ref *app-state* key default))\n\n(def (state-set! key value)\n  (hash-put! *app-state* key value)\n  ;; Notify all listeners for this key\n  (for-each (lambda (pair)\n              (when (eq? (car pair) key)\n                ((cdr pair) value)))\n            *state-callbacks*))\n\n(def (state-on-change! key callback)\n  \"Register callback(value) to run when key changes.\"\n  (set! *state-callbacks* (cons (cons key callback) *state-callbacks*)))\n\n;; 2. Wire Qt widgets to state changes (in widget setup code):\n;; (state-on-change! 'status-text\n;;   (lambda (text)\n;;     (qt-main-window-set-status-bar-text! win text)))\n;;\n;; (state-on-change! 'current-room-id\n;;   (lambda (room-id)\n;;     (qt-label-set-text! header-label\n;;       (if room-id (lookup-room-title room-id) \"Select a room\"))))\n\n;; 3. Update state from event handlers:\n;; (qt-on-current-row-changed! room-list\n;;   (lambda (row) (state-set! 'current-room-id (get-room-id row))))\n;;\n;; This triggers all registered callbacks, updating header, messages, etc.",
    "notes": "This pattern avoids tight coupling between widgets. Each panel registers its own callbacks during setup, and state mutations from any source (user clicks, API responses, timers) automatically propagate to all interested widgets. Use symbol keys in the state hash for eq? comparison in callbacks. For production use, consider adding a guard to skip callbacks when the new value equals the old value.",
    "related": [
      "qt-three-panel-chat-layout",
      "qt-dark-theme-stylesheet"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "build-multiple-exe-targets",
    "title": "Multiple exe targets in one build.ss (CLI + GUI binaries)",
    "tags": [
      "build",
      "exe",
      "binary",
      "multiple",
      "defbuild-script",
      "completion"
    ],
    "imports": [
      ":std/build-script",
      ":std/make"
    ],
    "code": "#!/usr/bin/env gxi\n(import :std/build-script\n        :std/make)\n\n;; Compute path to FFI shared library for linking\n(def qt-shim-dir\n  (path-expand \"gerbil-qt\"\n    (path-expand \"lib\"\n      (path-expand \".gerbil\" (getenv \"HOME\" \"/home/user\")))))\n\n(defbuild-script\n  `(\"myapp/types\"\n    \"myapp/util\"\n    \"myapp/gui-theme\"\n    \"myapp/gui-state\"\n    ;; GOTCHA: Do NOT list exe entry-point modules as library entries!\n    ;; Including \"myapp/cli\" or \"myapp/gui\" here AND in an exe: target\n    ;; causes \"Completion has already been posted\" deadlock.\n    ;; Only list them in the exe: blocks below.\n    (exe: \"myapp/cli\"\n          bin: \"myapp\"\n          \"-cc-options\" \"-I/opt/homebrew/include\"\n          \"-ld-options\" \"-L/opt/homebrew/lib -lyaml\")\n    (exe: \"myapp/gui\"\n          bin: \"myapp-qt\"\n          \"-cc-options\" ,(cppflags \"Qt6Widgets\" \"\")\n          \"-ld-options\" ,(string-append\n                           \"-L\" qt-shim-dir \" -lqt_shim \"\n                           \"-Wl,-rpath,\" qt-shim-dir \" \"\n                           (ldflags \"Qt6Widgets\" \"-lQt6Widgets\")))))",
    "notes": "KEY GOTCHA: If a module appears both as a plain string library entry AND in an (exe: ...) block, the build system tries to compile it twice and crashes with \"Completion has already been posted\". The fix: only list exe entry-point modules in the exe: blocks, not as standalone library entries. Their dependency modules (types, util, gui-theme, etc.) go as library entries. Both exe modules must export a `main` function: `(export main)` with `(def (main . args) ...)`. Use quasiquote (backtick) for the build spec when using ,(cppflags ...) or ,(ldflags ...) for dynamic flag computation. Use `(getenv \"HOME\")` not `\"~/.gerbil\"` for path computation — tilde doesn't expand in `path-expand`.",
    "related": [
      "static-exe-with-deps",
      "gxc-exe-in-makefile",
      "build-ffi-pkg-config",
      "gerbil-build-loadpath"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "string-contains-returns-index-not-boolean",
    "title": "string-contains returns index (not #t) — wrap in number? for tests",
    "tags": [
      "string-contains",
      "srfi-13",
      "test",
      "check",
      "truthy",
      "index",
      "boolean"
    ],
    "imports": [
      ":std/srfi/13",
      ":std/test"
    ],
    "code": ";; GOTCHA: string-contains returns the index of the match, NOT #t.\n;; In :std/test, (check expr => (not #f)) evaluates (not #f) to #t,\n;; then compares with equal? — so (check (string-contains s \"foo\") => (not #f))\n;; FAILS because 34 != #t.\n\n;; WRONG — fails because string-contains returns an index (integer):\n;; (check (string-contains \"hello world\" \"world\") => (not #f))  ;; 6 != #t\n;; (check (string-contains css \"QWidget\") => (not #f))          ;; 34 != #t\n\n;; CORRECT — wrap in number? to get a proper boolean:\n(check (number? (string-contains \"hello world\" \"world\")) => #t)\n(check (number? (string-contains \"hello world\" \"missing\")) => #f)\n\n;; ALSO CORRECT — use ? predicate check syntax:\n;; (check (string-contains \"hello world\" \"world\") ? number?)\n\n;; Same issue applies to string-contains-ci from :std/srfi/13:\n(check (number? (string-contains-ci \"Hello World\" \"hello\")) => #t)",
    "notes": "string-contains and string-contains-ci (from :std/srfi/13) return the starting index of the match as an integer, or #f if not found. Since integers are truthy in Gerbil, you can use them in if/when/cond directly. But in :std/test check assertions, you need exact equality — so wrap with number? or use the ? predicate syntax. This commonly bites when writing tests for CSS/HTML content that contains known substrings.",
    "related": [
      "write-tests-with-std-test",
      "ffi-type-predicate-returns-sublist"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ssxi-optimizer-arity-workaround",
    "title": "Disable ssxi optimizer to fix arity mismatch in complex import graphs",
    "tags": [
      "ssxi",
      "optimizer",
      "arity",
      "mismatch",
      "declare",
      "compile",
      "gerbil-qt",
      "keyword"
    ],
    "imports": [],
    "code": ";; PROBLEM: The Gerbil ssxi optimizer can generate incorrect arity for\n;; functions that use keyword-dispatch (like gerbil-qt widget creation)\n;; when the module imports certain other modules. The same calls compile\n;; fine in modules with fewer imports.\n;;\n;; SYMPTOM: Compilation error:\n;;   \"Illegal lambda application; arity mismatch\"\n;;   SyntaxError during gxc compilation\n;;\n;; Example: (qt-dialog-create parent: win) works in gui-header.ss\n;; (which imports only :gerbil-qt/qt, ./gui-theme, ./gui-state)\n;; but FAILS in gui-auth.ss (which also imports ./types, ./util, ./client).\n;;\n;; WORKAROUND: Add this declaration at the top of the affected module,\n;; after the import form:\n\n(declare (not optimize-dead-definitions))\n\n;; This disables the ssxi optimizer's dead-definition elimination pass,\n;; which is where the incorrect arity inference occurs.\n;;\n;; Full module template:\n;; (import\n;;   :gerbil-qt/qt\n;;   ./types\n;;   ./util\n;;   ./client)\n;;\n;; (export #t)\n;;\n;; ;; Disable ssxi optimizer to prevent arity mismatch\n;; (declare (not optimize-dead-definitions))\n;;\n;; (def (my-function parent)\n;;   (let ((dlg (qt-dialog-create parent: parent)))  ;; now compiles OK\n;;     ...))",
    "notes": "This is a known quirk of the Gerbil ssxi optimizer. It affects modules that import both keyword-dispatch-heavy modules (like :gerbil-qt/qt) AND other project modules. The optimizer incorrectly infers arities for keyword-dispatch calls based on the combined import context. The workaround has no significant performance impact for GUI code. You can also try a clean build (make clean && make build) as stale .ssxi files can cause similar issues.",
    "related": [
      "qt-splitter-create-requires-orientation"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "hash-table-predicate-not-hash",
    "title": "Use hash-table? (not hash?) to check for hash tables",
    "tags": [
      "hash-table?",
      "hash?",
      "predicate",
      "type-check",
      "unbound"
    ],
    "imports": [],
    "code": ";; GOTCHA: Gerbil uses hash-table? to check if a value is a hash table.\n;; There is NO hash? predicate — it causes an \"unbound identifier\" error.\n\n;; WRONG — unbound identifier:\n;; (hash? my-value)  ;; ERROR: Unbound identifier hash?\n\n;; CORRECT:\n(hash-table? (hash (\"a\" 1)))  ;; => #t\n(hash-table? '())             ;; => #f\n(hash-table? 42)              ;; => #f\n\n;; Common pattern in tests:\n;; (check (hash-table? (state-ref 'rooms)) => #t)\n\n;; Note: (hash ...) creates a hash table, but hash? doesn't exist.\n;; The constructor and predicate have different naming conventions:\n;;   Constructor:  (hash (\"key\" value) ...)\n;;   Predicate:    (hash-table? obj)\n;;   Type name:    HashTable (for class-info)",
    "notes": "This catches many people coming from other Lisp dialects where the predicate matches the constructor name. In Gerbil: hash creates, hash-table? checks. Also note: hash-eq creates an eq?-based hash table, and the same hash-table? predicate works for both kinds.",
    "related": [
      "hash-table-basics"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "void-initial-callback-avoids-compiler-type-error",
    "title": "Use (void) not #f for mutable callback variables to avoid compiler type errors",
    "tags": [
      "void",
      "callback",
      "compiler",
      "type",
      "mutable",
      "def",
      "procedure",
      "initial"
    ],
    "imports": [],
    "code": ";; GOTCHA: When defining a mutable global that will hold a callback procedure,\n;; do NOT initialize it to #f. The Gerbil compiler performs static analysis\n;; and may see the #f value at compile time, causing errors when the variable\n;; is later called as a procedure in a lambda.\n;;\n;; WRONG — compiler sees #f (boolean::t) and rejects the call:\n;; (def *my-callback* #f)\n;; (qt-on-triggered! action\n;;   (lambda () (when *my-callback* (*my-callback*))))\n;; => ERROR: (%#call (%#ref *my-callback*)) detail: boolean::t\n;;\n;; CORRECT — use (void) as initial value + procedure? check:\n(def *my-callback* (void))\n\n;; Later, set it to an actual procedure:\n;; (set! *my-callback* (lambda () (do-something)))\n\n;; When calling, check with procedure?:\n;; (when (procedure? *my-callback*) (*my-callback*))",
    "notes": "This issue occurs specifically with Gerbil's AOT compiler (gxc). The compiler statically analyzes known values and can determine that #f is boolean::t, which cannot be called as a procedure. Using (void) avoids this because #!void is not typed as narrowly. The procedure? check at the call site is needed regardless since the initial value is not callable. This pattern is common when avoiding circular imports — module A defines the callback slot, module B sets it at init time.",
    "related": [
      "hash-ref-returns-void-truthy"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "hash-ref-default-not-used-when-key-exists-empty",
    "title": "hash-ref default is ignored when key exists with [] or #f value",
    "tags": [
      "hash-ref",
      "default",
      "empty-list",
      "state",
      "fallback",
      "gotcha"
    ],
    "imports": [],
    "code": ";; GOTCHA: hash-ref's default is only used when the KEY IS MISSING.\n;; If the key exists with a falsy or empty value, the default is NOT used.\n;;\n;; This commonly bites with state stores that initialize all keys upfront.\n\n;; Example: state hash initialized with all keys\n(def *state* (hash (room-order [\"r1\" \"r2\" \"r3\"])\n                   (filtered-room-order [])))  ;; key exists, value is []\n\n;; WRONG — expects fallback to room-order, but gets [] because key exists:\n(def (get-rooms)\n  (hash-ref *state* 'filtered-room-order\n    (hash-ref *state* 'room-order [])))\n;; => []  (NOT [\"r1\" \"r2\" \"r3\"] — default is never used!)\n\n;; The key 'filtered-room-order EXISTS with value [], so hash-ref\n;; returns [] immediately without consulting the default expression.\n\n;; CORRECT — check if the value is empty, not just missing:\n(def (get-rooms)\n  (let ((filtered (hash-ref *state* 'filtered-room-order [])))\n    (if (pair? filtered)\n      filtered\n      (hash-ref *state* 'room-order []))))\n\n;; ALSO CORRECT — initialize with #f instead of []:\n;; (def *state* (hash (filtered-room-order #f)))\n;; Then hash-ref returns #f, and (or #f default) works.\n;; But this changes the type contract.\n\n;; GENERAL RULE: hash-ref default is a KEY-ABSENCE default, not a\n;; VALUE-ABSENCE default. If you need fallback for empty/falsy values,\n;; check the value explicitly after retrieval.",
    "notes": "This commonly manifests in reactive state stores (like gui-state.ss) where all keys are initialized upfront with defaults. The pattern (hash-ref state 'key1 (hash-ref state 'key2 default)) looks like it chains fallbacks, but the first hash-ref always returns the initialized value (even []) because the key exists. Tests that only set key2 (the \"real\" data) but not key1 (the \"filtered\" view) fail silently because key1 returns [] instead of falling through. Fix: either check (pair? result) for list values, or initialize optional keys to #f instead of [].",
    "related": [
      "hash-table-operations",
      "hash-ref-void-truthy"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-dialog-create-parent-keyword",
    "title": "qt-dialog-create takes parent: as keyword argument, not positional",
    "tags": [
      "qt",
      "dialog",
      "create",
      "parent",
      "keyword",
      "arity",
      "modal"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: qt-dialog-create takes parent: as a KEYWORD argument.\n;; Arity is 1 (keyword dispatch), not 0 or 2.\n;;\n;; WRONG — positional parent arg:\n;; (qt-dialog-create *main-window*)\n;; => ERROR: Illegal lambda application; arity mismatch\n;;\n;; WRONG — no parent (creates orphan dialog):\n;; (qt-dialog-create)\n;; => ERROR: Illegal lambda application; arity mismatch\n;;\n;; CORRECT — use parent: keyword:\n(let ((dlg (qt-dialog-create parent: *main-window*)))\n  (qt-dialog-set-title! dlg \"My Dialog\")\n  (qt-widget-set-minimum-size! dlg 400 300)\n\n  ;; Add content via layout\n  (let ((layout (qt-vbox-layout-create dlg)))\n    (qt-layout-add-widget! layout (qt-label-create \"Hello\"))\n    (let ((close-btn (qt-push-button-create \"Close\")))\n      (qt-on-clicked! close-btn (lambda () (qt-dialog-accept! dlg)))\n      (qt-layout-add-widget! layout close-btn)))\n\n  ;; Show as modal dialog (blocks until closed)\n  (qt-dialog-exec! dlg))",
    "notes": "The parent: keyword makes the dialog modal relative to the parent window. qt-dialog-exec! shows the dialog and blocks until the user closes it (via qt-dialog-accept! or qt-dialog-reject! or the X button). Use qt-dialog-set-title! to set the title bar text. The dialog's layout is created with (qt-vbox-layout-create dlg) — passing the dialog as parent to the layout constructor.",
    "related": [
      "qt-hbox-vbox-layout-require-parent",
      "qt-action-parent-keyword"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-system-tray-icon-create-bus-error",
    "title": "qt-system-tray-icon-create: icon is positional, parent is keyword (bus error gotcha)",
    "tags": [
      "system",
      "tray",
      "icon",
      "create",
      "bus error",
      "crash",
      "SIGBUS",
      "parent",
      "keyword",
      "positional"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: qt-system-tray-icon-create takes icon as POSITIONAL arg, parent as KEYWORD.\n;; Passing a QWidget as the first positional arg causes a Bus Error (SIGBUS)\n;; because the C shim dereferences it as a const QIcon& reference.\n;;\n;; WRONG — causes Bus error: 10 (SIGBUS):\n;; (qt-system-tray-icon-create win)  ;; win treated as icon, not parent!\n;;\n;; CORRECT — create a QIcon first, pass parent: as keyword:\n(let* ((icon (qt-icon-create \"\"))  ;; empty/null icon\n       (tray (qt-system-tray-icon-create icon parent: win)))\n  (qt-system-tray-icon-set-tooltip! tray \"My App\")\n  (qt-system-tray-icon-show! tray)\n  tray)\n\n;; Or with a real icon from a pixmap:\n;; (let* ((pix (qt-pixmap-create-blank 32 32))\n;;        (_ (qt-pixmap-fill! pix 52 152 219))\n;;        (icon (qt-icon-create-from-pixmap pix))\n;;        (tray (qt-system-tray-icon-create icon parent: win)))\n;;   ...)",
    "notes": "The crash occurs because qt_system_tray_icon_create(icon, parent) passes the first arg as const QIcon& to the QSystemTrayIcon C++ constructor. A QWidget pointer dereferenced as QIcon reads garbage memory → SIGBUS. The empty string icon path creates a null QIcon which is safe to pass. Always check (qt-system-tray-available?) before creating.",
    "related": [
      "qt-system-tray-icon-full",
      "qt-action-create-requires-parent-keyword"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-list-widget-item-data-user-role",
    "title": "Store hidden data on QListWidget items using Qt::UserRole",
    "tags": [
      "qt",
      "list-widget",
      "item-data",
      "user-role",
      "hidden-data",
      "setData"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; QListWidget items can carry hidden string data via Qt::UserRole.\n;; This is useful for storing IDs, keys, or metadata alongside display text.\n;;\n;; qt-list-widget-set-item-data! stores a string on the item at the given row.\n;; qt-list-widget-item-data retrieves the stored string (or \"\" if none).\n;; The display text (qt-list-widget-item-text) is unaffected.\n\n(import :gerbil-qt/qt)\n\n(let ((l (qt-list-widget-create)))\n  ;; Add visible items\n  (qt-list-widget-add-item! l \"Alice\")\n  (qt-list-widget-add-item! l \"Bob\")\n\n  ;; Attach hidden data (e.g. database IDs)\n  (qt-list-widget-set-item-data! l 0 \"user-id-1001\")\n  (qt-list-widget-set-item-data! l 1 \"user-id-1002\")\n\n  ;; Retrieve hidden data\n  (qt-list-widget-item-data l 0)  ;; => \"user-id-1001\"\n  (qt-list-widget-item-data l 1)  ;; => \"user-id-1002\"\n\n  ;; Display text is unchanged\n  (qt-list-widget-item-text l 0)  ;; => \"Alice\"\n\n  ;; Use in selection handler:\n  (qt-on-current-row-changed! l\n    (lambda (row)\n      (when (>= row 0)\n        (let ((id (qt-list-widget-item-data l row)))\n          (displayln \"Selected user: \" id)))))\n\n  (qt-widget-destroy! l))",
    "notes": "Data is stored using Qt::UserRole (256). Only string data is supported. Returns \"\" for items with no data set or invalid row indices. The C++ shim uses QVariant::toString() so non-string QVariant data will be coerced to string.",
    "related": [
      "qt-on-return-pressed-not-on-line-edit-return"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-scroll-to-bottom-text-edit-browser",
    "title": "Scroll QTextEdit or QTextBrowser to bottom (chat-style auto-scroll)",
    "tags": [
      "qt",
      "scroll",
      "bottom",
      "text-edit",
      "text-browser",
      "chat",
      "auto-scroll"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; For chat apps or log viewers, scroll to the bottom after appending text.\n;; Works on both QTextEdit and QTextBrowser.\n;; Internally uses verticalScrollBar()->setValue(verticalScrollBar()->maximum()).\n\n(import :gerbil-qt/qt)\n\n;; QTextEdit example (chat input area):\n(let ((e (qt-text-edit-create)))\n  (qt-text-edit-append! e \"Message 1\")\n  (qt-text-edit-append! e \"Message 2\")\n  (qt-text-edit-append! e \"Message 3\")\n  (qt-text-edit-scroll-to-bottom! e)\n  (qt-widget-destroy! e))\n\n;; QTextBrowser example (chat history display):\n(let ((tb (qt-text-browser-create)))\n  (qt-text-browser-set-html! tb \"<p>Welcome to the chat</p>\")\n  (qt-text-browser-append! tb \"User1: Hello!\")\n  (qt-text-browser-append! tb \"User2: Hi there!\")\n  (qt-text-browser-scroll-to-bottom! tb)\n  (qt-widget-destroy! tb))",
    "notes": "Call scroll-to-bottom! AFTER appending content. QTextBrowser also has qt-text-browser-append! (which QTextEdit already had as qt-text-edit-append!). Both append functions add rich text (HTML-aware) — plain text is auto-escaped.",
    "related": [
      "qt-list-widget-item-data-user-role"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-widget-min-max-width-height-cursor",
    "title": "Set individual min/max width/height and cursor shape on any widget",
    "tags": [
      "qt",
      "widget",
      "minimum-width",
      "maximum-height",
      "cursor",
      "pointing-hand",
      "size-constraint"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; Individual min/max width/height setters (vs the combined set-minimum-size!).\n;; Useful when you only want to constrain one dimension.\n;;\n;; (qt-widget-set-minimum-width! w pixels)\n;; (qt-widget-set-minimum-height! w pixels)\n;; (qt-widget-set-maximum-width! w pixels)\n;; (qt-widget-set-maximum-height! w pixels)\n;;\n;; Compare with existing combined versions:\n;; (qt-widget-set-minimum-size! w width height)\n;; (qt-widget-set-maximum-size! w width height)\n\n(import :gerbil-qt/qt)\n\n;; Example: sidebar with fixed width but flexible height\n(let ((sidebar (qt-widget-create)))\n  (qt-widget-set-minimum-width! sidebar 200)\n  (qt-widget-set-maximum-width! sidebar 300)\n  ;; height is unconstrained\n\n  ;; Cursor shape constants:\n  ;; QT_CURSOR_ARROW (0) — default arrow\n  ;; QT_CURSOR_CROSS (2) — crosshair\n  ;; QT_CURSOR_WAIT (3) — hourglass/spinner\n  ;; QT_CURSOR_IBEAM (4) — text I-beam\n  ;; QT_CURSOR_POINTING_HAND (13) — clickable hand\n  ;; QT_CURSOR_FORBIDDEN (14) — not-allowed circle\n  ;; QT_CURSOR_BUSY (16) — arrow + spinner\n\n  ;; Set cursor on any widget (e.g. clickable label):\n  (qt-widget-set-cursor! sidebar QT_CURSOR_POINTING_HAND)\n\n  ;; Restore default cursor:\n  (qt-widget-unset-cursor! sidebar)\n\n  (qt-widget-destroy! sidebar))",
    "notes": "Cursor constants map to Qt::CursorShape enum values. setCursor works on any QWidget subclass. unsetCursor restores the cursor inherited from the parent widget. For busy indicators, QT_CURSOR_BUSY shows an arrow with a spinner (non-blocking) while QT_CURSOR_WAIT shows just a spinner (suggests blocking).",
    "related": [
      "qt-scroll-to-bottom-text-edit-browser"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-text-edit-to-html",
    "title": "Get HTML content from QTextEdit or QTextBrowser with toHtml",
    "tags": [
      "qt",
      "text-edit",
      "text-browser",
      "html",
      "toHtml",
      "rich-text",
      "export"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; Get the full HTML representation of text content.\n;; Works on both QTextEdit (qt-text-edit-html) and QTextBrowser (qt-text-browser-html).\n;; Even plain text gets wrapped in HTML tags by Qt.\n\n(import :gerbil-qt/qt)\n\n;; QTextEdit: get HTML\n(let ((e (qt-text-edit-create)))\n  (qt-text-edit-set-text! e \"Hello World\")\n  (let ((html (qt-text-edit-html e)))\n    ;; html contains full HTML document with <html><head><body> tags\n    ;; e.g. \"<!DOCTYPE HTML PUBLIC ...><html><head>...</head><body>\n    ;;       <p style=\\\"...\\\">Hello World</p></body></html>\"\n    (displayln html))\n  (qt-widget-destroy! e))\n\n;; QTextBrowser: get HTML\n(let ((tb (qt-text-browser-create)))\n  (qt-text-browser-set-html! tb \"<b>Bold</b> and <i>italic</i>\")\n  (let ((html (qt-text-browser-html tb)))\n    (displayln html))\n  (qt-widget-destroy! tb))\n\n;; Compare with plain text getters:\n;; (qt-text-edit-text e)         ;; plain text only (strips HTML)\n;; (qt-text-edit-html e)         ;; full HTML document\n;; (qt-text-browser-plain-text tb)  ;; plain text only\n;; (qt-text-browser-html tb)       ;; full HTML document",
    "notes": "Qt always wraps content in a full HTML document structure even for plain text input. The HTML includes inline CSS styles for font, margins, etc. Useful for saving rich text content or clipboard operations. The string-returning FFI uses s_return_buf + const-cast wrapper pattern.",
    "related": [
      "qt-scroll-to-bottom-text-edit-browser"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-label-word-wrap",
    "title": "Enable word wrapping on QLabel for long text",
    "tags": [
      "qt",
      "label",
      "word-wrap",
      "text",
      "wrap",
      "multi-line"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; By default, QLabel does NOT word-wrap — long text is clipped.\n;; Enable word wrapping for multi-line labels or chat message bubbles.\n\n(import :gerbil-qt/qt)\n\n(let ((label (qt-label-create \"This is a very long text that should wrap to multiple lines when the widget is narrower than the text.\")))\n  (qt-label-set-word-wrap! label #t)   ;; enable wrapping\n  ;; (qt-label-set-word-wrap! label #f)  ;; disable wrapping (default)\n  (qt-widget-set-maximum-width! label 200)  ;; constrain width to see wrapping\n  (qt-widget-destroy! label))",
    "notes": "Takes a boolean (#t/#f), internally converted to int (1/0) for the C FFI. Word wrap respects the widget's width — combine with qt-widget-set-maximum-width! or layout constraints to control wrap point. Useful for chat message display, status labels, and description text.",
    "related": [
      "qt-widget-min-max-width-height-cursor"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-with-busy-cursor-macro",
    "title": "with-busy-cursor macro for wrapping long GUI operations",
    "tags": [
      "qt",
      "cursor",
      "busy",
      "macro",
      "defrule",
      "try-finally",
      "long-operation"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; Macro to show a busy cursor (arrow + spinner) during long operations.\\n;; Uses try/finally to ensure the cursor is always restored, even on error.\\n;; Assumes `win` is bound to the main window in the enclosing scope.\\n\\n(defrule (with-busy-cursor body ...)\\n  (begin\\n    (qt-widget-set-cursor! win QT_CURSOR_BUSY)\\n    (try body ...\\n      (finally (qt-widget-unset-cursor! win)))))\\n\\n;; Usage in event handlers:\\n(def (run-search!)\\n  (with-busy-cursor\\n    (qt-main-window-set-status-bar-text! win \\\"Searching...\\\")\\n    (let* ((results (expensive-query))\\n           (n (populate-model! results)))\\n      (qt-main-window-set-status-bar-text! win\\n        (format \\\"Found ~a results\\\" n)))))\\n\\n;; Also works with nested try/catch inside:\\n(def (load-data!)\\n  (with-busy-cursor\\n    (try\\n      (do-loading!)\\n      (catch (e)\\n        (qt-message-box-critical win \\\"Error\\\"\\n          (format \\\"Load failed: ~a\\\" e))))))",
    "notes": "QT_CURSOR_BUSY (16) shows arrow + spinner (non-blocking feel). QT_CURSOR_WAIT (3) shows just a spinner (blocking feel). The macro captures `win` from the enclosing scope — if your main window variable has a different name, adjust accordingly. The try/finally ensures the cursor is restored even if the body throws an exception. This pattern is commonly applied to: search operations, database scans, S3 loads, and any operation that takes more than ~200ms.",
    "related": [
      "qt-widget-min-max-width-cursor-shape"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-json-detail-html-panel",
    "title": "Render JSON in styled QTextBrowser detail panel with HTML",
    "tags": [
      "qt",
      "text-browser",
      "html",
      "json",
      "detail",
      "panel",
      "escape",
      "pre",
      "dark-theme"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; Replace QPlainTextEdit with QTextBrowser for read-only detail panels.\\n;; QTextBrowser supports HTML rendering, enabling styled JSON display.\\n\\n;; HTML escape helper (required for JSON content with <, >, &)\\n(def (html-escape str)\\n  (let loop ((i 0) (acc []))\\n    (if (>= i (string-length str))\\n      (list->string (reverse acc))\\n      (let ((ch (string-ref str i)))\\n        (cond\\n          ((char=? ch #\\\\&) (loop (+ i 1) (append (reverse (string->list \\\"&amp;\\\")) acc)))\\n          ((char=? ch #\\\\<) (loop (+ i 1) (append (reverse (string->list \\\"&lt;\\\")) acc)))\\n          ((char=? ch #\\\\>) (loop (+ i 1) (append (reverse (string->list \\\"&gt;\\\")) acc)))\\n          (else (loop (+ i 1) (cons ch acc))))))))\\n\\n;; Wrap JSON string in styled HTML <pre> block (dark theme colors)\\n(def (json->detail-html json-str)\\n  (string-append\\n    \\\"<pre style=\\\\\\\"color:#cdd6f4; background-color:#181825; \\\"\\n    \\\"font-family:monospace; font-size:11px; padding:8px;\\\\\\\">\\\" \\n    (html-escape json-str)\\n    \\\"</pre>\\\"))\\n\\n;; Create the detail panel:\\n(def detail (qt-text-browser-create))\\n(qt-text-browser-set-html! detail\\n  \\\"<p style=\\\\\\\"color:#a6adc8;\\\\\\\">Select an item to view details...</p>\\\")\\n\\n;; Update on selection:\\n(def (show-detail! record)\\n  (qt-text-browser-set-html! detail\\n    (json->detail-html (record->json-string record))))\\n\\n;; CSS theme entry for QTextBrowser (add alongside QPlainTextEdit):\\n;; QPlainTextEdit, QTextBrowser {\\n;;   background-color: #181825;\\n;;   color: #cdd6f4;\\n;;   border: 1px solid #585b70;\\n;;   font-family: 'Monospace', 'Consolas', 'Courier New';\\n;;   font-size: 11px;\\n;; }",
    "notes": "QTextBrowser is read-only by default (no need to call set-read-only). It has no set-placeholder equivalent — use set-html! with a styled <p> for placeholder text. The html-escape function is essential because JSON may contain angle brackets from AWS API responses (e.g. ARNs, XML snippets in error messages). When using a dark theme stylesheet, add QTextBrowser alongside QPlainTextEdit in CSS rules. The inline styles in the <pre> tag ensure correct rendering even if the stylesheet doesn't fully override QTextBrowser defaults.",
    "related": [
      "qt-scroll-to-bottom-text-edit-browser",
      "qt-text-browser-html-get"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-settings-persist-window-state",
    "title": "QSettings: persist and restore window size and preferences",
    "tags": [
      "settings",
      "QSettings",
      "persist",
      "save",
      "restore",
      "window",
      "preferences"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; PATTERN: Use QSettings to persist window geometry and user preferences.\n;;\n;; qt-settings-create takes (org app) — two positional strings.\n;; qt-settings-string/int/bool take (settings key default: val) — keyword default.\n;; qt-settings-set-string!/set-int!/set-bool! take (settings key value) — 3 positional.\n;; qt-settings-begin-group!/end-group! for sectioned keys.\n\n(import :gerbil-qt/qt)\n\n;; Create settings (uses native format — plist on macOS, registry on Windows)\n(def settings (qt-settings-create \"MyOrg\" \"my-app\"))\n\n;; Save window geometry\n(qt-settings-begin-group! settings \"Window\")\n(qt-settings-set-int! settings \"width\" (qt-widget-width win))\n(qt-settings-set-int! settings \"height\" (qt-widget-height win))\n(qt-settings-end-group! settings)\n(qt-settings-sync! settings)\n\n;; Restore window geometry\n(qt-settings-begin-group! settings \"Window\")\n(let ((w (qt-settings-int settings \"width\" default: 1200))\n      (h (qt-settings-int settings \"height\" default: 800)))\n  (qt-settings-end-group! settings)\n  (qt-widget-resize! win w h))\n\n;; Boolean preferences\n(qt-settings-set-bool! settings \"Prefs/notifications\" #t)\n(qt-settings-bool settings \"Prefs/notifications\" default: #f)  ;; => #t\n\n;; String preferences (e.g., last selected item)\n(qt-settings-set-string! settings \"Channel/lastId\" \"C12345\")\n(qt-settings-string settings \"Channel/lastId\" default: \"\")  ;; => \"C12345\"\n\n;; Check if a key exists\n(qt-settings-contains? settings \"Channel/lastId\")  ;; => #t\n\n;; Cleanup\n(qt-settings-sync! settings)\n(qt-settings-destroy! settings)",
    "notes": "qt-settings-create takes two positional strings (org, app-name). The default: keyword on getters provides a fallback value. Use begin-group!/end-group! for hierarchical keys, or use slash notation like \"Section/key\". Always call qt-settings-sync! before destroy to ensure data is flushed. On macOS, settings are stored in ~/Library/Preferences/com.MyOrg.my-app.plist.",
    "related": [
      "qt-system-tray-icon-full",
      "qt-dialog-create-keyword-parent"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-progress-bar-create-keyword-parent",
    "title": "qt-progress-bar-create takes parent: keyword (not positional)",
    "tags": [
      "progress",
      "bar",
      "create",
      "parent",
      "keyword",
      "arity",
      "indeterminate"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: qt-progress-bar-create takes parent: as KEYWORD argument.\n;; Passing parent as positional arg causes arity mismatch error.\n;;\n;; WRONG — positional parent:\n;; (qt-progress-bar-create widget)\n;; => ERROR: Illegal lambda application; arity mismatch\n;;\n;; CORRECT — keyword parent:\n(qt-progress-bar-create parent: widget)\n\n;; Full signature:\n;;   (qt-progress-bar-create [parent: widget])\n\n;; Set range and value\n(let ((pbar (qt-progress-bar-create parent: container)))\n  (qt-progress-bar-set-range! pbar 0 100)\n  (qt-progress-bar-set-value! pbar 50)  ;; 50%\n\n  ;; Indeterminate mode (animated loading bar):\n  (qt-progress-bar-set-range! pbar 0 0)  ;; min=max=0 triggers indeterminate\n\n  ;; Back to determinate:\n  (qt-progress-bar-set-range! pbar 0 100)\n  (qt-progress-bar-set-value! pbar 100)\n\n  ;; Thin styling (4px loading bar):\n  (qt-widget-set-maximum-height! pbar 4)\n  (qt-widget-set-style-sheet! pbar\n    \"QProgressBar { border: none; background: transparent; }\n     QProgressBar::chunk { background-color: #1264A3; }\")\n\n  ;; Show/hide\n  (qt-widget-show! pbar)\n  (qt-widget-hide! pbar))",
    "notes": "Setting range to (0, 0) enables indeterminate/animated mode — Qt shows a pulsing progress bar. This is useful when you don't know the total work (e.g., loading messages from API). Set range back to (0, 100) for determinate mode. The progress bar is a QWidget so parent-child ownership applies.",
    "related": [
      "qt-dialog-create-keyword-parent",
      "qt-progress-dialog-timer-driven"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-unregister-handler-prevent-accumulation",
    "title": "unregister-qt-handler! to prevent signal handler accumulation",
    "tags": [
      "unregister",
      "handler",
      "disconnect",
      "cleanup",
      "accumulation",
      "signal",
      "leak"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: Calling qt-on-*! multiple times ACCUMULATES handlers.\n;; Both old and new callbacks fire on every signal.\n;; This causes duplicate actions, memory leaks, and stale closures.\n;;\n;; PATTERN: Store handler IDs, unregister before re-registering.\n\n(import :gerbil-qt/qt)\n\n(def *handler-id* #f)\n\n(def (init-widget! widget)\n  ;; Unregister previous handler if re-initializing\n  (when *handler-id*\n    (unregister-qt-handler! *handler-id*))\n  ;; Register new handler — qt-on-*! returns a handler ID\n  (set! *handler-id*\n    (qt-on-clicked! widget\n      (lambda () (displayln \"clicked!\")))))\n\n;; For timers:\n(def *timer* #f)\n(def *timer-handler* #f)\n\n(def (start-polling!)\n  ;; Clean up previous timer handler\n  (when (and *timer* *timer-handler*)\n    (unregister-qt-handler! *timer-handler*)\n    (qt-timer-stop! *timer*))\n  ;; Create or reuse timer\n  (let ((timer (or *timer* (qt-timer-create))))\n    (set! *timer* timer)\n    (set! *timer-handler*\n      (qt-on-timeout! timer (lambda () (process-events!))))\n    (qt-timer-start! timer 100)))\n\n;; Disconnect ALL handlers from a widget (nuclear option):\n;; (qt-disconnect-all! widget)",
    "notes": "All qt-on-*! functions return a callback ID (integer). Save it and pass to unregister-qt-handler! before re-registering. This is critical in init! functions that may be called multiple times. qt-disconnect-all! removes ALL signal connections from a QObject — use for widget cleanup/destroy. The handler ID is needed because Qt signal connections accumulate by design (multiple slots per signal is a feature).",
    "related": [
      "qt-system-tray-icon-full",
      "qt-shortcut-explicit-destroy"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-completer-line-edit-search",
    "title": "QCompleter for autocomplete on QLineEdit with fuzzy matching",
    "tags": [
      "completer",
      "autocomplete",
      "line-edit",
      "search",
      "filter",
      "fuzzy",
      "match"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; PATTERN: Attach a QCompleter to a QLineEdit for autocomplete suggestions.\n;; qt-completer-create takes 1 arg (parent widget).\n;; qt-completer-set-model-strings! takes (completer string-list).\n\n(import :gerbil-qt/qt)\n\n(let* ((search-box (qt-line-edit-create))\n       (completer (qt-completer-create search-box)))\n\n  ;; Configure matching mode\n  (qt-completer-set-case-sensitivity! completer QT_CASE_INSENSITIVE)\n  (qt-completer-set-filter-mode! completer QT_MATCH_CONTAINS)  ;; fuzzy\n\n  ;; Attach to line edit\n  (qt-line-edit-set-completer! search-box completer)\n\n  ;; Populate with suggestions\n  (qt-completer-set-model-strings! completer\n    '(\"general\" \"random\" \"engineering\" \"design\" \"marketing\"))\n\n  ;; Update suggestions dynamically (e.g., when data changes):\n  ;; (qt-completer-set-model-strings! completer new-list)\n  )\n\n;; Filter mode constants:\n;; QT_MATCH_STARTS_WITH — only match from the beginning (default)\n;; QT_MATCH_CONTAINS    — match anywhere in the string (fuzzy)\n;; QT_MATCH_ENDS_WITH   — match at the end\n\n;; Completion mode constants:\n;; QT_COMPLETER_POPUP            — dropdown popup (default)\n;; QT_COMPLETER_INLINE           — inline completion\n;; QT_COMPLETER_UNFILTERED_POPUP — show all items, highlight match\n\n;; Case sensitivity constants:\n;; QT_CASE_SENSITIVE\n;; QT_CASE_INSENSITIVE",
    "notes": "qt-completer-create takes a parent widget (typically the line edit it will serve). Call qt-completer-set-model-strings! to update the suggestions list — can be called repeatedly as data changes. QT_MATCH_CONTAINS is best for search/filter UIs. The completer only works with QLineEdit (not QPlainTextEdit). For in-text autocomplete (@mentions, :emoji:), you'd need a custom popup approach.",
    "related": [
      "qt-on-return-pressed-not-on-line-edit-return",
      "qt-list-widget-item-data-user-role"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-group-box-checkbox-preferences-dialog",
    "title": "QGroupBox + QCheckBox pattern for preferences dialogs",
    "tags": [
      "group-box",
      "checkbox",
      "preferences",
      "dialog",
      "settings",
      "toggle",
      "form"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; PATTERN: Preferences dialog with grouped checkboxes.\n;; qt-group-box-create takes 1 arg: title string.\n;; qt-check-box-create takes 1 arg: label string.\n;; qt-check-box-checked? and qt-check-box-set-checked! for state.\n\n(import :gerbil-qt/qt)\n\n(let* ((dlg (qt-dialog-create parent: win))\n       (layout (qt-vbox-layout-create dlg))\n       ;; Notifications group\n       (notif-group (qt-group-box-create \"Notifications\"))\n       (notif-layout (qt-vbox-layout-create notif-group))\n       (notif-check (qt-check-box-create \"Enable desktop notifications\"))\n       (sound-check (qt-check-box-create \"Play notification sounds\"))\n       ;; Appearance group\n       (appear-group (qt-group-box-create \"Appearance\"))\n       (appear-layout (qt-vbox-layout-create appear-group))\n       (compact-check (qt-check-box-create \"Compact mode\"))\n       ;; Buttons\n       (save-btn (qt-push-button-create \"Save\")))\n\n  (qt-dialog-set-title! dlg \"Preferences\")\n\n  ;; Load saved values\n  (qt-check-box-set-checked! notif-check #t)\n  (qt-check-box-set-checked! compact-check #f)\n\n  ;; Assemble groups\n  (qt-layout-add-widget! notif-layout notif-check)\n  (qt-layout-add-widget! notif-layout sound-check)\n  (qt-layout-add-widget! appear-layout compact-check)\n\n  ;; Wire save button\n  (qt-on-clicked! save-btn\n    (lambda ()\n      (let ((notifications (qt-check-box-checked? notif-check))\n            (compact (qt-check-box-checked? compact-check)))\n        ;; Save to QSettings...\n        (qt-dialog-accept! dlg))))\n\n  ;; Main layout\n  (qt-layout-add-widget! layout notif-group)\n  (qt-layout-add-widget! layout appear-group)\n  (qt-layout-add-stretch! layout)\n  (qt-layout-add-widget! layout save-btn)\n\n  (qt-dialog-exec! dlg))",
    "notes": "qt-group-box-create and qt-check-box-create each take exactly 1 positional arg (the title/label string). The group box layout is a separate qt-vbox-layout-create call with the group box as parent. Checkbox state is read with qt-check-box-checked? (returns #t/#f) and set with qt-check-box-set-checked!. For toggle handlers use qt-on-toggled! (callback receives boolean).",
    "related": [
      "qt-dialog-create-keyword-parent",
      "qt-settings-persist-window-state",
      "qt-form-layout-spanning-widget"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "qt-action-set-tooltip-not-widget-set-tooltip",
    "title": "Use qt-action-set-tooltip! for QAction (not qt-widget-set-tooltip!)",
    "tags": [
      "action",
      "tooltip",
      "widget",
      "toolbar",
      "menu",
      "set-tooltip"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: QAction is NOT a QWidget — use qt-action-set-tooltip!, not qt-widget-set-tooltip!\n;;\n;; WRONG — QAction is not a QWidget:\n;; (qt-widget-set-tooltip! my-action \"Search\")  ;; type error or crash\n;;\n;; CORRECT — separate function for actions:\n(let ((action (qt-action-create \"Search\" parent: win)))\n  (qt-action-set-tooltip! action \"Search messages (Ctrl+F)\")\n  (qt-toolbar-add-action! toolbar action))\n\n;; For actual QWidget tooltips:\n(qt-widget-set-tooltip! my-button \"Click to send\")\n(qt-widget-set-tooltip! my-label \"Current channel name\")\n(qt-widget-set-tooltip! my-line-edit \"Type to filter\")\n\n;; Both take (object tooltip-string) — arity 2.",
    "notes": "QAction inherits QObject, not QWidget, so all widget-specific functions (set-tooltip!, set-style-sheet!, etc.) don't work on actions. Use the action-specific variants: qt-action-set-tooltip!, qt-action-set-enabled!, qt-action-set-icon!, etc. The tooltip shows when hovering over the action's toolbar button or menu entry.",
    "related": [
      "qt-action-create-requires-parent-keyword",
      "qt-toolbar-create-title-positional"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "pkg-link-stale-unbound-rebuild",
    "title": "Linked package not rebuilt causes #!unbound errors in compiled binary",
    "tags": [
      "pkg",
      "link",
      "unbound",
      "stale",
      "rebuild",
      "build",
      "makefile",
      "gerbil pkg build"
    ],
    "imports": [],
    "code": ";; PROBLEM: Compiled binary crashes with:\n;;   Operator is not a PROCEDURE (#!unbound2 ...)\n;; even though the function exists in the dependency source and the\n;; module_exports MCP tool can find it.\n;;\n;; ROOT CAUSE: The dependency was linked via `gerbil pkg link` into\n;; .gerbil/pkg/dep-name -> /path/to/dep-source\n;; but the linked package was never rebuilt after new functions were added.\n;; The Makefile only runs `gerbil pkg build dep-name` when the symlink\n;; doesn't exist yet:\n;;\n;;   # WRONG — skips rebuild when symlink exists:\n;;   deps:\n;;   \t@if [ ! -L .gerbil/pkg/dep-name ]; then \\\n;;   \t\tgerbil pkg link dep-name /path/to/source; \\\n;;   \t\tgerbil pkg build dep-name; \\\n;;   \tfi\n;;   \t@gerbil pkg deps -i\n;;\n;; FIX: Always run `gerbil pkg build` for the linked package:\n;;\n;;   # CORRECT — always rebuilds linked dependency:\n;;   deps:\n;;   \t@if [ ! -L .gerbil/pkg/dep-name ]; then \\\n;;   \t\techo \"Linking dep-name...\"; \\\n;;   \t\tgerbil pkg link dep-name /path/to/source; \\\n;;   \tfi\n;;   \t@gerbil pkg build dep-name\n;;   \t@gerbil pkg deps -i\n;;\n;; DIAGNOSIS:\n;; 1. The error shows #!unbound2 with arguments that match a specific call\n;;    site — e.g. (#!unbound2 '#<void* ...> 250) means a 2-arg function\n;;    call where the function resolved to unbound.\n;; 2. Check if the function exists in the dep source:\n;;    grep function-name /path/to/dep-source/*.ss\n;; 3. Check if it's exported:\n;;    grep function-name /path/to/dep-source/*.ss | head\n;; 4. If it exists in source but the compiler says \"unbound identifier\",\n;;    the linked package needs rebuilding:\n;;    gerbil pkg build dep-name\n;; 5. Then clean-rebuild your project:\n;;    make clean && make",
    "notes": "This is distinct from the \"stale global static files\" problem. Here the issue is that `gerbil pkg link` creates a symlink but doesn't automatically track source changes. When the dependency source adds new exports, you must explicitly run `gerbil pkg build dep-name` to recompile the linked package. The Makefile guard `if [ ! -L ... ]` is a common trap — it protects the link step but also gates the build step. Move `gerbil pkg build` outside the conditional. The rebuild is fast (no-op) when nothing changed, so always running it is safe.",
    "related": [
      "stale-global-static-segfault",
      "gerbil-build-loadpath",
      "gerbil-build-missing-manifests"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "uuid-generation",
    "title": "UUID generation, conversion, and hashing",
    "tags": [
      "uuid",
      "random",
      "unique",
      "identifier",
      "hash",
      "bytes"
    ],
    "imports": [
      ":std/misc/uuid"
    ],
    "code": "(import :std/misc/uuid)\n\n;; Generate a random UUID v4\n(def u (random-uuid))\n(uuid->string u)  ;; => \"1b97ab50-a7b7-4158-acc9-aa55f75a50bb\"\n\n;; Parse a UUID from string\n(def u2 (string->uuid \"550e8400-e29b-41d4-a716-446655440000\"))\n(uuid? u2)  ;; => #t\n\n;; Round-trip: string -> uuid -> string\n(uuid->string (string->uuid \"550e8400-e29b-41d4-a716-446655440000\"))\n;; => \"550e8400-e29b-41d4-a716-446655440000\"\n\n;; Binary representation (16 bytes)\n(def bytes (uuid->u8vector u))\n(u8vector-length bytes)  ;; => 16\n(def u3 (u8vector->uuid bytes))\n(uuid=? u u3)  ;; => #t\n\n;; UUID as hash table key (uuid-hash for custom tables)\n(def ht (make-hash-table))\n(hash-put! ht u \"my-resource\")\n(hash-ref ht u)  ;; => \"my-resource\"\n\n;; The UUID coercer accepts string, u8vector, or uuid\n(UUID \"550e8400-e29b-41d4-a716-446655440000\")  ;; => uuid from string\n(UUID (make-u8vector 16 0))                      ;; => uuid from bytes\n\n;; Pattern: generate unique file/resource names\n(def (unique-filename prefix ext)\n  (string-append prefix \"-\" (uuid->string (random-uuid)) \".\" ext))\n(unique-filename \"report\" \"csv\")  ;; => \"report-a1b2c3d4-...-e5f6.csv\"",
    "notes": ":std/misc/uuid provides RFC 4122 v4 random UUIDs. The UUID struct has a lazy string representation (computed once on first uuid->string call, then cached). uuid-hash makes UUIDs usable as hash table keys. The UUID coercer accepts strings, u8vectors, or existing uuid objects. uuid=? compares by value (not identity).",
    "related": [
      "hash-table-basics",
      "crypto-digest-sha256-md5"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "values-multiple-return",
    "title": "Multiple return values: extract, convert, and destructure",
    "tags": [
      "values",
      "multiple",
      "return",
      "first-value",
      "nth-value",
      "destructure",
      "vector",
      "cons"
    ],
    "imports": [
      ":std/values"
    ],
    "code": "(import :std/values)\n\n;; Extract individual values from a multi-value expression\n(first-value (values 10 20 30))   ;; => 10\n(second-value (values 10 20 30))  ;; => 20\n(nth-value 2 (values 10 20 30))   ;; => 30\n\n;; Convert between values and data structures\n(values->vector (values 'a 'b 'c))  ;; => #(a b c)\n(values->cons (values 'x 'y))       ;; => (x . y)\n\n;; Convert data structures back to values\n(let-values (((a b c) (vector->values '#(1 2 3))))\n  (+ a b c))  ;; => 6\n\n(let-values (((x y) (cons->values '(hello . world))))\n  (list x y))  ;; => (hello world)\n\n(let-values (((a b c) (list->values '(10 20 30))))\n  (* a b c))  ;; => 6000\n\n;; Pattern: extract just the first result from a multi-value function\n;; (e.g., hash-table-ref returns value + found? flag)\n(first-value (hash-ref (hash (a 1) (b 2)) 'a))  ;; => 1\n\n;; Pattern: convert partition result (2 values) to a pair\n(import :std/srfi/1)\n(values->cons (partition even? '(1 2 3 4 5)))\n;; => ((2 4) . (1 3 5))",
    "notes": ":std/values provides utilities for working with Scheme's multiple return values. first-value and second-value work as both macros (single expression) and functions (multiple args). nth-value is 0-indexed. values->vector/values->cons convert multi-value results to single values. The reverse functions (vector->values, cons->values, list->values) expand data structures into multiple values for let-values destructuring. Note: values->list is a Gambit builtin (no import needed).",
    "related": [
      "collect-results-with-for-collect",
      "srfi-1-list-utilities"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "hmac-message-authentication",
    "title": "HMAC message authentication with SHA-256/SHA-512",
    "tags": [
      "hmac",
      "crypto",
      "sha256",
      "sha512",
      "authentication",
      "mac",
      "signature",
      "security"
    ],
    "imports": [
      ":std/crypto/hmac",
      ":std/text/hex"
    ],
    "code": "(import :std/crypto/hmac :std/text/hex)\n\n;; One-shot HMAC computation\n(def key (string->bytes \"my-secret-key\"))\n(def message (string->bytes \"hello world\"))\n\n;; HMAC-SHA256 (most common)\n(def mac (hmac-sha256 key message))\n(hex-encode mac)  ;; => hex string of 32-byte MAC\n\n;; Other digest algorithms\n(hmac-sha512 key message)  ;; => 64-byte MAC\n(hmac-sha384 key message)  ;; => 48-byte MAC\n(hmac-sha1 key message)    ;; => 20-byte MAC\n(hmac-md5 key message)     ;; => 16-byte MAC\n\n;; Verify HMAC by comparing\n(def (hmac-verify? key message expected-mac)\n  (equal? (hmac-sha256 key message) expected-mac))\n\n;; Streaming HMAC (for large data processed in chunks)\n(def h (make-hmac 'sha256))\n(hmac-init! h key)\n(hmac-update! h (string->bytes \"hello \"))\n(hmac-update! h (string->bytes \"world\"))\n(def result (hmac-final! h))\n;; result equals (hmac-sha256 key (string->bytes \"hello world\"))\n\n;; Pattern: API request signing\n(def (sign-request secret-key method path timestamp body)\n  (let* ((message (string-append method \"\\n\" path \"\\n\" timestamp \"\\n\" body))\n         (mac (hmac-sha256 (string->bytes secret-key)\n                           (string->bytes message))))\n    (hex-encode mac)))",
    "notes": ":std/crypto/hmac wraps OpenSSL's HMAC implementation. The one-shot functions (hmac-sha256, etc.) take key and data as u8vectors and return a u8vector MAC. The streaming API (make-hmac/hmac-init!/hmac-update!/hmac-final!) processes data in chunks — useful for large files or network streams. make-hmac takes a symbol digest name ('sha256, 'sha512, 'sha1, 'md5). The HMAC object is single-use: after hmac-final!, create a new one. Always use constant-time comparison (equal? on u8vectors) for MAC verification to prevent timing attacks.",
    "related": [
      "crypto-digest-sha256-md5",
      "sigv4-aws-request-signing"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "aes-encrypt-decrypt",
    "title": "AES symmetric encryption and decryption",
    "tags": [
      "crypto",
      "cipher",
      "aes",
      "encrypt",
      "decrypt",
      "cbc",
      "gcm",
      "security"
    ],
    "imports": [
      ":std/crypto/cipher",
      ":std/text/hex"
    ],
    "code": "(import :std/crypto/cipher :std/text/hex)\n\n;; AES-256-CBC: encrypt and decrypt\n(def key (make-u8vector 32 42))   ;; 256-bit key (use random bytes in production!)\n(def iv (make-u8vector 16 7))     ;; 128-bit IV  (must be unique per encryption!)\n(def plaintext (string->bytes \"Hello Gerbil!\"))\n\n;; IMPORTANT: create SEPARATE cipher instances for encrypt and decrypt\n;; (ciphers are finalized after use and cannot be reused)\n(def ciphertext (encrypt (make-aes-256-cbc-cipher) key iv plaintext))\n(def decrypted (decrypt (make-aes-256-cbc-cipher) key iv ciphertext))\n(bytes->string decrypted)  ;; => \"Hello Gerbil!\"\n\n;; Available cipher constructors (common ones):\n;; AES-128: make-aes-128-cbc-cipher, make-aes-128-gcm-cipher, make-aes-128-ctr-cipher\n;; AES-192: make-aes-192-cbc-cipher, make-aes-192-gcm-cipher\n;; AES-256: make-aes-256-cbc-cipher, make-aes-256-gcm-cipher, make-aes-256-ctr-cipher\n;; Modes: ecb, cbc, cfb, ofb, ctr, ccm, gcm, xts\n\n;; Streaming API for large data\n(def c (make-aes-256-cbc-cipher))\n(encrypt-init! c key iv)\n(def part1 (encrypt-update! c (string->bytes \"first chunk\")))\n(def part2 (encrypt-update! c (string->bytes \"second chunk\")))\n(def final (encrypt-final! c))\n;; Concatenate part1, part2, final for full ciphertext\n\n;; Pattern: encrypt a file\n(def (encrypt-file in-path out-path key iv)\n  (let ((c (make-aes-256-cbc-cipher)))\n    (encrypt-init! c key iv)\n    (call-with-input-file in-path\n      (lambda (in)\n        (call-with-output-file out-path\n          (lambda (out)\n            (let loop ()\n              (let (buf (read-u8vector 4096 in))\n                (unless (equal? buf #u8())\n                  (let (encrypted (encrypt-update! c buf))\n                    (write-subu8vector encrypted 0 (u8vector-length encrypted) out))\n                  (loop))))\n            (let (final (encrypt-final! c))\n              (write-subu8vector final 0 (u8vector-length final) out))))))))",
    "notes": ":std/crypto/cipher wraps OpenSSL's EVP cipher API. CRITICAL: cipher instances are single-use — after encrypt or encrypt-final!, the cipher is finalized and cannot be reused. Create a new instance with make-aes-256-cbc-cipher for each operation. The high-level encrypt/decrypt functions handle init/update/final in one call. Key sizes: AES-128 = 16 bytes, AES-192 = 24 bytes, AES-256 = 32 bytes. IV size: 16 bytes for CBC/CTR/CFB/OFB, 12 bytes for GCM. In production, generate keys and IVs with cryptographic randomness, never reuse an IV with the same key.",
    "related": [
      "hmac-message-authentication",
      "crypto-digest-sha256-md5"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ll1-parser-combinators",
    "title": "LL(1) parser combinators for structured text parsing",
    "tags": [
      "parser",
      "ll1",
      "combinator",
      "parse",
      "text",
      "csv",
      "grammar",
      "bind",
      "monadic"
    ],
    "imports": [
      ":std/parser/ll1"
    ],
    "code": "(import :std/parser/ll1)\n\n;; Parse an unsigned integer from a string\n(ll1/string ll1-uint \"12345\")  ;; => 12345\n\n;; Parse a signed integer\n(ll1/string ll1-sint \"-42\")    ;; => -42\n\n;; Parse a specific character or string\n;; ll1-char matches one char, ll1-string matches a literal\n(ll1/string (ll1-begin (ll1-string \"hello\") (ll1-char #\\!) (ll1-pure 'greeting))\n            \"hello!\")\n;; => greeting\n\n;; Monadic bind: chain parsers, use result in next parser\n(def addition-parser\n  (ll1-bind ll1-uint\n    (lambda (a)\n      (ll1-begin (ll1-char #\\+)\n        (ll1-bind ll1-uint\n          (lambda (b) (ll1-pure (+ a b))))))))\n(ll1/string addition-parser \"3+4\")  ;; => 7\n\n;; ll1-or: try alternatives (backtracks on parse error)\n(def bool-parser\n  (ll1-or (ll1-begin (ll1-string \"true\") (ll1-pure #t))\n          (ll1-begin (ll1-string \"false\") (ll1-pure #f))))\n(ll1/string bool-parser \"true\")   ;; => #t\n(ll1/string bool-parser \"false\")  ;; => #f\n\n;; ll1-separated: parse elements with separator until terminator\n;; Signature: (ll1-separated element separator terminator)\n(def csv-uints (ll1-separated ll1-uint (ll1-char #\\,) ll1-eof))\n(ll1/string csv-uints \"1,2,3,4\")  ;; => (1 2 3 4)\n\n;; ll1-repeated: parse element repeatedly until terminator\n(def digits (ll1-repeated (ll1-char? char-numeric?) ll1-eof))\n(ll1/string digits \"abc\")  ;; parsed until eof\n\n;; ll1*: applicative — apply function to parsed results\n(def pair-parser (ll1* cons ll1-uint (ll1-begin (ll1-char #\\:) ll1-uint)))\n(ll1/string pair-parser \"42:99\")  ;; => (42 . 99)\n\n;; ll1-case: deterministic dispatch on next character (no backtracking)\n;; More efficient than ll1-or when first char determines the branch\n;; (ll1-case (#\\t (ll1-string \"true\"))\n;;           (#\\f (ll1-string \"false\")))\n\n;; Running parsers on different inputs\n(ll1/string ll1-uint \"42\")                ;; parse from string\n;; (ll1/port parser port)                 ;; parse from input port\n;; (ll1/file parser \"path.txt\")           ;; parse from file\n;; (ll1/file-lines line-parser \"input\")   ;; parse file line by line",
    "notes": ":std/parser/ll1 provides LL(1) parser combinators with one-character lookahead. Key combinators: ll1-pure (return value), ll1-bind (monadic chain), ll1-begin/ll1-begin0 (sequence, return last/first), ll1-or (alternatives with backtracking), ll1* (applicative), ll1-separated (delimited lists), ll1-repeated (repetition). ll1-separated takes 3 required args: element parser, separator parser, terminator parser. The terminator tells the parser when to stop — commonly ll1-eof, ll1-eolf, or ll1-peek for lookahead. WARNING: ll1-or backtracks on failure but does NOT reset position if multiple chars were consumed — use ll1-case for deterministic first-char dispatch when possible.",
    "related": [
      "regular-expressions",
      "pregexp-replace"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "for-fold-accumulation",
    "title": "Accumulate values with for/fold (reduce over iterables)",
    "tags": [
      "for",
      "fold",
      "reduce",
      "accumulate",
      "iterate",
      "filter",
      "when",
      "unless"
    ],
    "imports": [
      ":std/iter"
    ],
    "code": "(import :std/iter)\n\n;; Basic fold: sum a list\n(for/fold (sum 0) (x '(1 2 3 4 5))\n  (+ sum x))\n;; => 15\n\n;; Build a reversed list (like foldl)\n(for/fold (acc []) (x '(a b c))\n  (cons x acc))\n;; => (c b a)\n\n;; Fold with filter: accumulate only matching elements\n(for/fold (acc []) ((x (in-range 10)) when (odd? x))\n  (cons x acc))\n;; => (9 7 5 3 1)\n\n;; Fold with unless (exclude matching)\n(for/fold (acc []) ((x '(1 2 3 4 5 6)) unless (even? x))\n  (cons x acc))\n;; => (5 3 1)\n\n;; Fold over hash table\n(for/fold (total 0) ((k v) (in-hash (hash (a 10) (b 20) (c 30))))\n  (+ total v))\n;; => 60\n\n;; Fold over range with index\n(for/fold (acc []) ((x i) (in-indexed '(a b c)))\n  (cons (list i x) acc))\n;; => ((2 c) (1 b) (0 a))\n\n;; Build a hash table from a list\n(for/fold (ht (make-hash-table)) ((x i) (in-indexed '(zero one two three)))\n  (hash-put! ht i x)\n  ht)\n\n;; Pattern: find maximum with for/fold\n(for/fold (best 0) (x '(3 7 2 9 4 1))\n  (max best x))\n;; => 9\n\n;; Pattern: group-by using for/fold\n(def (group-by key-fn lst)\n  (for/fold (groups (make-hash-table)) (x lst)\n    (let (k (key-fn x))\n      (hash-put! groups k (cons x (hash-ref groups k [])))\n      groups)))",
    "notes": "for/fold is Gerbil's general-purpose reduction over iterables. Syntax: (for/fold (acc init) (binding ...) body). The body returns the new accumulator value. Supports when/unless filters in the binding clause. Works with all iterables: lists, vectors, in-range, in-hash, in-indexed, etc. For multiple accumulators, use (for/fold (acc1 init1 acc2 init2) ...) and return (values new-acc1 new-acc2) from the body — but beware: deeply nested hash literals in the init position can trigger a \"Bad syntax; invalid match target\" error; work around by binding the initial value in a let outside the for/fold.",
    "related": [
      "collect-results-with-for-collect",
      "reduce-with-for-fold",
      "iterate-hash-table"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "while-until-loops",
    "title": "Imperative loops with while and until",
    "tags": [
      "while",
      "until",
      "loop",
      "imperative",
      "iteration",
      "sugar",
      "mutation"
    ],
    "imports": [],
    "code": ";; while: loop as long as condition is true (no import needed — builtin)\n(def v (make-vector 5 0))\n(def i 0)\n(while (< i 5)\n  (vector-set! v i (* i i))\n  (set! i (+ i 1)))\nv  ;; => #(0 1 4 9 16)\n\n;; until: loop until condition becomes true (opposite of while)\n(def result [])\n(def j 0)\n(until (= j 5)\n  (set! result (cons j result))\n  (set! j (+ j 1)))\n(reverse result)  ;; => (0 1 2 3 4)\n\n;; Pattern: read lines until EOF\n;; (def (read-all-lines port)\n;;   (def lines [])\n;;   (def line (read-line port))\n;;   (until (eof-object? line)\n;;     (set! lines (cons line lines))\n;;     (set! line (read-line port)))\n;;   (reverse lines))\n\n;; Pattern: poll with timeout\n;; (def (wait-for-ready check-fn timeout-ms)\n;;   (def start (current-milliseconds))\n;;   (def ready #f)\n;;   (until (or ready (> (- (current-milliseconds) start) timeout-ms))\n;;     (set! ready (check-fn))\n;;     (unless ready (thread-sleep! 0.1)))\n;;   ready)\n\n;; While with break: use let/cc for early exit\n(let/cc break\n  (def k 0)\n  (while #t\n    (when (> k 10) (break k))\n    (set! k (+ k 1))))\n;; => 11",
    "notes": "while and until are builtin Gerbil macros (no import needed). while loops while the test is true; until loops until the test becomes true. Both expand to a named let loop that re-evaluates the test on each iteration. These are for imperative code with mutation — for functional iteration, prefer for/for-each/for-fold from :std/iter. For early exit from while #t, combine with let/cc to create a break-like escape. increment! is also available as a builtin for (set! var (+ var 1)).",
    "related": [
      "for-fold-accumulation",
      "collect-results-with-for-collect"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ignore-errors-fault-tolerance",
    "title": "Suppress exceptions with ignore-errors",
    "tags": [
      "ignore-errors",
      "error",
      "exception",
      "catch",
      "suppress",
      "fault",
      "tolerance",
      "sugar"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": "(import :std/sugar)\n\n;; ignore-errors: evaluate body, return #f if any exception occurs\n(ignore-errors (+ 1 2))            ;; => 3 (no error)\n(ignore-errors (error \"boom\") 42)  ;; => #f (error suppressed)\n\n;; Returns the value of the last expression on success\n(ignore-errors\n  (def x 10)\n  (def y 20)\n  (+ x y))\n;; => 30\n\n;; Returns #f on ANY exception (not just errors)\n(ignore-errors (string-ref \"hi\" 99))  ;; => #f\n\n;; Pattern: safe hash lookup with fallback\n(or (ignore-errors (hash-ref ht 'key))\n    \"default-value\")\n\n;; Pattern: try to parse, fall back on failure\n(def (safe-string->number s)\n  (or (ignore-errors (string->number s))\n      0))\n\n;; Pattern: best-effort cleanup (don't care if it fails)\n(def (safe-cleanup! resource)\n  (ignore-errors (close-port resource))\n  (ignore-errors (delete-file (resource-path resource))))\n\n;; CAUTION: ignore-errors hides ALL errors including bugs.\n;; Prefer try/catch with specific exception predicates for production code:\n;; (try (risky-operation)\n;;   (catch (io-error? e) (handle-io-error e))\n;;   (catch (e) (log-unexpected-error e)))",
    "notes": "ignore-errors from :std/sugar expands to (with-catch false (lambda () body ...)). It catches any exception and returns #f. Useful for best-effort operations where failure is acceptable (cleanup, optional features, probing). WARNING: it suppresses ALL exceptions including programming errors — use sparingly and prefer try/catch with specific predicates for production error handling. The false in with-catch means it always returns #f on error regardless of exception type.",
    "related": [
      "error-handling",
      "with-destroy-resource-cleanup"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "bytes-endian-access",
    "title": "Endian-aware binary data access with :std/misc/bytes",
    "tags": [
      "bytes",
      "binary",
      "endian",
      "u8vector",
      "u16",
      "u32",
      "u64",
      "float",
      "double",
      "protocol"
    ],
    "imports": [
      ":std/misc/bytes"
    ],
    "code": "(import :std/misc/bytes)\n\n;; Read/write multi-byte integers with explicit endianness\n(def buf (make-u8vector 16 0))\n\n;; Write big-endian u32 at offset 0\n(u8vector-u32-set! buf 0 #x12345678 (endianness big))\n;; buf[0..3] = #x12 #x34 #x56 #x78\n\n;; Read it back\n(u8vector-u32-ref buf 0 (endianness big))  ;; => #x12345678\n\n;; Little-endian u16 at offset 4\n(u8vector-u16-set! buf 4 #xABCD (endianness little))\n(u8vector-u16-ref buf 4 (endianness little))  ;; => #xABCD\n\n;; 64-bit integers\n(u8vector-u64-set! buf 8 #xDEADBEEFCAFEBABE (endianness big))\n(u8vector-u64-ref buf 8 (endianness big))  ;; => #xDEADBEEFCAFEBABE\n\n;; Signed integers\n(u8vector-s32-set! buf 0 -1 (endianness big))\n(u8vector-s32-ref buf 0 (endianness big))  ;; => -1\n\n;; Native endianness (fastest, platform-dependent)\n(u8vector-u32-native-set! buf 0 42)\n(u8vector-u32-native-ref buf 0)  ;; => 42\n(native-endianness)  ;; => little (on x86/ARM)\n\n;; IEEE floating point\n(u8vector-float-set! buf 0 3.14 (endianness big))\n(u8vector-float-ref buf 0 (endianness big))  ;; => ~3.14 (single precision)\n\n(u8vector-double-set! buf 0 3.141592653589793 (endianness big))\n(u8vector-double-ref buf 0 (endianness big))  ;; => 3.141592653589793\n\n;; Convert integer to/from u8vector\n(uint->u8vector #xDEAD (endianness big) 2)\n;; => #u8(#xDE #xAD)\n(u8vector->uint #u8(#xDE #xAD) (endianness big))\n;; => #xDEAD\n\n;; Bulk conversion: list of integers to/from u8vector\n(uint-list->u8vector '(1 2 3 4) (endianness big) 2)\n;; => #u8(0 1 0 2 0 3 0 4)\n(u8vector->uint-list #u8(0 1 0 2 0 3 0 4) (endianness big) 2)\n;; => (1 2 3 4)",
    "notes": ":std/misc/bytes provides R6RS-style bytevector operations with explicit endianness. Use (endianness big) or (endianness little) — these are syntax, not procedure calls. The native variants (*-native-ref, *-native-set!) use platform byte order and are fastest but non-portable. Supported widths: u8/s8, u16/s16, u32/s32, u64/s64, float (32-bit IEEE), double (64-bit IEEE). uint->u8vector and u8vector->uint handle arbitrary-width integers. All functions also have bytevector-* aliases (e.g., bytevector-u32-ref) for R6RS compatibility. The & prefixed variants (&u8vector-u32-ref, etc.) skip bounds checking for maximum performance in tight loops.",
    "related": [
      "u8vector-big-endian-encoding",
      "binary-io-write-subu8vector"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "srfi-42-eager-comprehensions",
    "title": "Eager comprehensions with SRFI-42 (list-ec, vector-ec, sum-ec, ...)",
    "tags": [
      "srfi",
      "srfi-42",
      "comprehension",
      "list-ec",
      "vector-ec",
      "sum-ec",
      "generator",
      "loop"
    ],
    "imports": [
      ":std/srfi/42"
    ],
    "code": "(import :std/srfi/42)\n\n;; list-ec: list comprehension\n(list-ec (:range i 5) (* i i))\n;; => (0 1 4 9 16)\n\n;; vector-ec: build a vector\n(vector-ec (:list x '(a b c)) x)\n;; => #(a b c)\n\n;; sum-ec: sum values\n(sum-ec (:range i 1 6) i)  ;; => 15\n\n;; string-append-ec: concatenate strings\n(string-append-ec (:list x '(\"hello\" \" \" \"world\")) x)\n;; => \"hello world\"\n\n;; Nested generators (Cartesian product)\n(list-ec (:range i 1 4) (:range j 1 4) (list i j))\n;; => ((1 1) (1 2) (1 3) (2 1) (2 2) (2 3) (3 1) (3 2) (3 3))\n\n;; Filtering with :range and if\n(list-ec (:range i 1 20) (if (zero? (modulo i 3))) i)\n;; => (3 6 9 12 15 18)\n\n;; :list generator\n(list-ec (:list x '(1 2 3) '(4 5 6)) (* x 10))\n;; => (10 20 30 40 50 60)\n\n;; :string generator (iterate over characters)\n(list-ec (:string c \"hello\") (char-upcase c))\n;; => (#\\H #\\E #\\L #\\L #\\O)\n\n;; :vector generator\n(sum-ec (:vector x '#(10 20 30)) x)  ;; => 60\n\n;; :parallel — zip generators (stop at shortest)\n(list-ec (:parallel (:range i 100) (:list x '(a b c))) (cons i x))\n;; => ((0 . a) (1 . b) (2 . c))\n\n;; :let — bind intermediate values\n(list-ec (:range i 1 5) (:let sq (* i i)) (list i sq))\n;; => ((1 1) (2 4) (3 9) (4 16))\n\n;; :while / :until — conditional termination\n(list-ec (:while (:range i 100) (< (* i i) 50)) i)\n;; => (0 1 2 3 4 5 6 7)\n\n;; Predicates\n(any?-ec (:range i 10) (= i 7))      ;; => #t\n(every?-ec (:range i 1 5) (> i 0))   ;; => #t\n(first-ec #f (:range i 10) (if (> (* i i) 50)) i)  ;; => 8\n\n;; fold-ec: general fold\n(fold-ec 0 (:range i 1 6) i +)  ;; => 15\n(fold-ec '() (:range i 5) i cons)  ;; => (4 3 2 1 0)",
    "notes": "SRFI-42 provides Python-style comprehensions for Scheme. Generator syntax: (:range i start end step), (:list x lst ...), (:vector x vec), (:string c str), (:integers), (:parallel gen1 gen2 ...). Filter: (if test) after generators. Result forms: list-ec, vector-ec, string-ec, string-append-ec, sum-ec, product-ec, min-ec, max-ec, any?-ec, every?-ec, first-ec, last-ec, fold-ec, fold3-ec, do-ec (side effects only), append-ec. :parallel zips generators (stops at shortest). :while/:until control iteration termination. These are eager (compute everything immediately) — for lazy sequences, use :std/lazy or :std/coroutine instead.",
    "related": [
      "collect-results-with-for-collect",
      "for-fold-accumulation"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "srfi-1-list-utilities",
    "title": "SRFI-1 list utilities: take, drop, partition, zip, fold, unfold, filter",
    "tags": [
      "srfi",
      "srfi-1",
      "list",
      "take",
      "drop",
      "partition",
      "zip",
      "fold",
      "unfold",
      "filter",
      "remove",
      "find",
      "any",
      "every"
    ],
    "imports": [
      ":std/srfi/1"
    ],
    "code": "(import :std/srfi/1)\n\n;; Slicing\n(take '(a b c d e) 3)   ;; => (a b c)\n(drop '(a b c d e) 3)   ;; => (d e)\n(take-right '(a b c d e) 2)  ;; => (d e)\n(drop-right '(a b c d e) 2)  ;; => (a b c)\n(split-at '(a b c d e) 3)    ;; => (a b c) (d e) [two values]\n\n;; Filtering\n(filter odd? '(1 2 3 4 5 6))           ;; => (1 3 5)\n(remove even? '(1 2 3 4 5 6))          ;; => (1 3 5)\n(partition even? '(1 2 3 4 5 6))       ;; => (2 4 6) (1 3 5) [two values]\n(delete-duplicates '(a b a c b d))     ;; => (a b c d)\n\n;; Searching\n(find even? '(1 3 4 5 6))             ;; => 4\n(find-tail even? '(1 3 4 5))          ;; => (4 5) (pair starting at match)\n(any even? '(1 3 5 7))                ;; => #f\n(any even? '(1 3 4 7))                ;; => #t\n(every positive? '(1 2 3))            ;; => #t\n(list-index even? '(1 3 4 5))         ;; => 2\n\n;; Folding\n(fold + 0 '(1 2 3 4 5))               ;; => 15\n(fold cons '() '(a b c))              ;; => (c b a)\n(fold-right cons '() '(a b c))        ;; => (a b c)\n(reduce + 0 '(1 2 3 4 5))             ;; => 15\n\n;; Unfolding (generate lists)\n(unfold (lambda (x) (> x 5)) identity 1+ 1)\n;; => (1 2 3 4 5)\n;; Args: (stop? map-fn next-fn seed)\n\n;; Zipping\n(zip '(a b c) '(1 2 3))               ;; => ((a 1) (b 2) (c 3))\n(unzip2 '((a 1) (b 2) (c 3)))         ;; => (a b c) (1 2 3) [two values]\n\n;; Appending and concatenating\n(append-map (lambda (x) (list x (* x 10))) '(1 2 3))\n;; => (1 10 2 20 3 30)\n(concatenate '((a b) (c d) (e f)))     ;; => (a b c d e f)\n(append-reverse '(3 2 1) '(4 5 6))    ;; => (1 2 3 4 5 6)\n\n;; Counting\n(count even? '(1 2 3 4 5 6))          ;; => 3\n\n;; Pair iteration\n(pair-for-each (lambda (p) (displayln (car p))) '(a b c))\n;; prints: a b c",
    "notes": "SRFI-1 provides the comprehensive list library for Scheme. IMPORTANT: filter, remove, partition, delete-duplicates, find, any, every, take, drop, zip, fold, unfold are NOT builtins — they require (import :std/srfi/1). Common builtins that DON'T need import: map, for-each, append, reverse, length, assoc, member, iota, cons*, list-ref. partition and split-at return two values — use let-values or receive to destructure. The ! variants (filter!, delete!, take!, etc.) are destructive (modify the original list). fold is left-fold (foldl); fold-right is right-fold (foldr).",
    "related": [
      "sort-filter-require-imports",
      "for-fold-accumulation"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "let-cc-escape-continuation",
    "title": "Early return with let/cc (escape continuations)",
    "tags": [
      "let/cc",
      "continuation",
      "escape",
      "return",
      "early-exit",
      "break",
      "control-flow"
    ],
    "imports": [],
    "code": ";; let/cc: capture the current continuation as a \"return\" function\n;; No import needed — builtin\n\n;; Early return from a search\n(let/cc return\n  (for-each (lambda (x)\n              (when (= x 3) (return 'found-3)))\n            '(1 2 3 4 5))\n  'not-found)\n;; => found-3\n\n;; Abort a nested computation\n(* 10 (let/cc k (+ 1 (k 42))))\n;; => 420 (k short-circuits, returning 42 to the * expression)\n\n;; Pattern: find-or-default\n(def (find-in-tree tree pred)\n  (let/cc return\n    (let walk ((node tree))\n      (cond\n        ((pred node) (return node))\n        ((pair? node)\n         (walk (car node))\n         (walk (cdr node)))))\n    #f))  ;; default if not found\n\n(find-in-tree '(1 (2 (3 4) 5) 6) (lambda (x) (and (number? x) (= x 4))))\n;; => 4\n\n;; Pattern: break from a while loop\n(let/cc break\n  (def i 0)\n  (while #t\n    (when (> i 10) (break i))\n    (set! i (+ i 1))))\n;; => 11\n\n;; let/cc captures an UNDELIMITED continuation — calling k jumps back\n;; to the point where let/cc was evaluated, abandoning the current\n;; computation. The value passed to k becomes the result of let/cc.\n\n;; For delimited continuations, use call/prompt + abort/prompt instead.\n;; For exception-based control flow, use try/catch instead.",
    "notes": "let/cc (call-with-current-continuation) is a Gerbil builtin (no import needed). It binds the current continuation to a variable. Calling that variable with a value immediately returns from the let/cc expression with that value — all intermediate computation is abandoned. This is equivalent to setjmp/longjmp in C or labeled returns in Kotlin. Use cases: early return from loops, search termination, error bailout. WARNING: the continuation is undelimited — calling it after the let/cc expression has already returned has undefined behavior. For structured control flow, prefer try/catch or let/esc (which raises an exception instead of using raw continuations).",
    "related": [
      "while-until-loops",
      "error-handling"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "stable-sort-preserve-order",
    "title": "Stable sort: preserve original order of equal elements",
    "tags": [
      "sort",
      "stable",
      "stable-sort",
      "order",
      "comparator",
      "key"
    ],
    "imports": [
      ":std/sort"
    ],
    "code": "(import :std/sort)\n\n;; sort vs stable-sort:\n;; Both sort a list/vector, but stable-sort preserves the original\n;; order of elements that compare as equal.\n\n;; Example: sort by priority, keep insertion order within same priority\n(def tasks '((a . 1) (b . 1) (c . 2) (d . 1) (e . 2)))\n\n;; stable-sort: elements with same cdr stay in original order\n(stable-sort tasks (lambda (x y) (< (cdr x) (cdr y))))\n;; => ((a . 1) (b . 1) (d . 1) (c . 2) (e . 2))\n;; Note: a, b, d all have priority 1 and keep their original order\n\n;; plain sort: no guarantee on equal-element order\n(sort tasks (lambda (x y) (< (cdr x) (cdr y))))\n;; => order of equal elements is unspecified\n\n;; In-place variants (mutate the vector)\n(def v (vector 5 3 1 4 2))\n(sort! v <)           ;; unstable in-place sort\nv  ;; => #(1 2 3 4 5)\n\n(def v2 (vector 5 3 1 4 2))\n(stable-sort! v2 <)   ;; stable in-place sort\nv2  ;; => #(1 2 3 4 5)\n\n;; Pattern: multi-key sort (sort by secondary key first, then primary)\n;; Since stable-sort preserves order of equal elements,\n;; sorting twice gives correct multi-key ordering:\n(def data '((alice 25) (bob 30) (carol 25) (dave 30)))\n(def by-name (stable-sort data (lambda (a b) (string<? (symbol->string (car a))\n                                                        (symbol->string (car b))))))\n(def by-age-then-name (stable-sort by-name (lambda (a b) (< (cadr a) (cadr b)))))\n;; => ((alice 25) (carol 25) (bob 30) (dave 30))",
    "notes": ":std/sort provides both stable and unstable sorting. sort uses heapsort for vectors (O(n log n), unstable) and merge sort for lists. stable-sort uses merge sort for both (O(n log n), stable). The ! variants (sort!, stable-sort!) sort in-place for vectors. All take a comparator: (lambda (a b) -> boolean) where #t means a should come before b. For multi-key sorting, use stable-sort twice: first by secondary key, then by primary key — the stability guarantee ensures the secondary ordering is preserved within equal primary groups.",
    "related": [
      "sort-filter-require-imports",
      "sort-a-list"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "file-locking-flock",
    "title": "Advisory file locking with flock",
    "tags": [
      "flock",
      "file",
      "lock",
      "exclusive",
      "shared",
      "blocking",
      "timeout",
      "os"
    ],
    "imports": [
      ":std/os/flock"
    ],
    "code": "(import :std/os/flock)\n\n;; Non-blocking lock attempt\n;; flock returns #t if lock acquired, #f if already locked\n(def port (open-output-file \"/tmp/myapp.lock\"))\n(flock port LOCK_EX)  ;; => #t (exclusive lock acquired)\n\n;; Unlock\n(flock port LOCK_UN)   ;; => #t (unlocked)\n\n;; Lock types:\n;; LOCK_SH — shared lock (multiple readers OK)\n;; LOCK_EX — exclusive lock (single writer)\n;; LOCK_UN — unlock\n\n;; Blocking lock with optional timeout (seconds)\n(flock/block port LOCK_EX)       ;; block indefinitely until lock acquired\n(flock/block port LOCK_EX 5.0)   ;; block up to 5 seconds, return #f on timeout\n\n;; Open and lock atomically\n(def locked-in (open-input-file/lock \"/tmp/data.txt\" LOCK_SH))\n;; reads are safe under shared lock\n(def contents (read-line locked-in))\n(close-port locked-in)  ;; closing the port releases the lock\n\n(def locked-out (open-output-file/lock \"/tmp/data.txt\" LOCK_EX))\n;; exclusive lock for writing\n(display \"new data\\n\" locked-out)\n(force-output locked-out)\n(close-port locked-out)  ;; releases the lock\n\n;; Pattern: exclusive file access with cleanup\n(def (with-file-lock path thunk)\n  (let ((port (open-output-file/lock path LOCK_EX)))\n    (unwind-protect\n      (thunk port)\n      (close-port port))))\n\n;; (with-file-lock \"/tmp/config.lock\"\n;;   (lambda (port) (write-config! port new-config)))\n\n;; Pattern: try-lock with fallback\n(def (try-with-lock path thunk)\n  (let ((port (open-output-file path)))\n    (if (flock port LOCK_EX)\n      (unwind-protect (thunk port)\n        (flock port LOCK_UN)\n        (close-port port))\n      (begin\n        (close-port port)\n        (error \"Could not acquire lock\" path)))))",
    "notes": ":std/os/flock provides POSIX advisory file locking. flock is non-blocking: it returns immediately with #t (acquired) or #f (already locked). flock/block polls with exponential backoff and optional timeout. Locks are advisory — other processes must cooperate by also calling flock. Closing the port automatically releases the lock. open-input-file/lock and open-output-file/lock combine open+lock atomically. The lock is per-process on the file descriptor, not per-thread — use a mutex for intra-process synchronization.",
    "related": [
      "mutex-unwind-protect",
      "rwlock-read-write-lock"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "config-keyword-plist",
    "title": "Configuration management with keyword property lists",
    "tags": [
      "config",
      "configuration",
      "keyword",
      "plist",
      "settings",
      "load",
      "save",
      "file"
    ],
    "imports": [
      ":std/config"
    ],
    "code": "(import :std/config)\n\n;; Configs are keyword property lists: [key1: val1 key2: val2 ...]\n(def cfg [app-name: \"MyApp\" debug: #t port: 8080 workers: 4])\n\n;; Get a value (with optional default)\n(config-get cfg app-name:)       ;; => \"MyApp\"\n(config-get cfg port:)           ;; => 8080\n(config-get cfg timeout: 30)     ;; => 30 (default, key not in cfg)\n\n;; Get a value (error if missing)\n(config-get! cfg app-name:)      ;; => \"MyApp\"\n;; (config-get! cfg timeout:)    ;; ERROR: missing key\n\n;; Set a value (returns new config)\n(def cfg2 (config-set! cfg debug: #f))\n(config-get cfg2 debug:)         ;; => #f\n\n;; Typed config with validation\n(def typed-cfg [config: my-app-config host: \"localhost\" port: 5432])\n(config-check! typed-cfg my-app-config)  ;; verifies config: tag matches\n\n;; Save config to file\n(save-config! cfg \"/tmp/myapp.config\")\n;; File content: (app-name: \"MyApp\" debug: #t port: 8080 workers: 4)\n\n;; Load config from file\n(def loaded (load-config \"/tmp/myapp.config\"))\n(config-get loaded app-name:)    ;; => \"MyApp\"\n\n;; Load typed config (validates config: tag)\n;; (def loaded (load-config \"/tmp/typed.config\" my-app-config))\n\n;; Write config to port (for custom output)\n(write-config cfg (current-output-port))\n\n;; Pattern: merge configs (later values override)\n(def defaults [host: \"localhost\" port: 8080 debug: #f])\n(def overrides [port: 9090 debug: #t])\n(def merged (append overrides defaults))\n;; config-get searches left-to-right, so overrides take precedence\n(config-get merged port:)   ;; => 9090\n(config-get merged host:)   ;; => \"localhost\" (from defaults)",
    "notes": ":std/config represents configuration as flat keyword property lists (plists). config-get scans the list for the keyword and returns the following value. Since it's a linear scan, later entries are shadowed by earlier ones — use (append overrides defaults) for merge-with-override semantics. config-set! creates a new plist with the updated key (non-destructive). config-push! is the destructive variant. The config: keyword in a typed config is a tag for validation — config-check! verifies it matches the expected symbol. save-config!/load-config use Scheme's read/write for serialization.",
    "related": [
      "hash-table-basics"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "decimal-exact-arithmetic",
    "title": "Exact decimal numbers for financial/monetary calculations",
    "tags": [
      "decimal",
      "exact",
      "money",
      "financial",
      "arithmetic",
      "precision",
      "parse"
    ],
    "imports": [
      ":std/misc/decimal"
    ],
    "code": "(import :std/misc/decimal)\n\n;; Parse decimal strings to exact rationals (no floating-point errors)\n(string->decimal \"19.99\")    ;; => 1999/100 (exact rational)\n(string->decimal \"0.1\")      ;; => 1/10 (exact — NOT 0.1000000000000000055...)\n(string->decimal \"-42.5\")    ;; => -85/2\n\n;; Convert back to decimal string\n(decimal->string 1999/100)   ;; => \"19.99\"\n(decimal->string 1/3)        ;; => \"0.333...\" (repeating)\n\n;; Exact arithmetic avoids floating-point rounding\n(def price (string->decimal \"19.99\"))\n(def tax-rate (string->decimal \"0.0825\"))\n(def total (+ price (* price tax-rate)))\n(decimal->string total)  ;; exact result\n\n;; Check if a number is decimal-representable\n(decimal? 1/4)    ;; => #t (0.25 — finite decimal)\n(decimal? 1/3)    ;; => #f (0.333... — infinite repeating)\n\n;; Significant digits counting\n(count-significant-digits 1999/100)  ;; number of significant digits\n\n;; Pattern: money formatting\n(def (format-money amount)\n  (let* ((cents (inexact->exact (round (* amount 100))))\n         (dollars (quotient cents 100))\n         (remainder (modulo (abs cents) 100)))\n    (format \"$~a.~a~a\" dollars\n            (if (< remainder 10) \"0\" \"\")\n            remainder)))",
    "notes": ":std/misc/decimal uses Scheme's exact rational numbers to represent decimals without floating-point errors. string->decimal parses \"19.99\" to the exact rational 1999/100. All arithmetic operations (+, -, *, /) on rationals remain exact. Use this for financial calculations, currency, or any domain where rounding errors are unacceptable. decimal->string converts back to decimal notation. decimal? checks if a rational has a finite decimal representation (denominator factors are only 2 and 5). For display formatting, convert to string and pad as needed.",
    "related": [
      "ll1-parser-combinators"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "temporary-file-safe-cleanup",
    "title": "Safe temporary files with automatic cleanup",
    "tags": [
      "temporary",
      "temp",
      "file",
      "cleanup",
      "safe",
      "os"
    ],
    "imports": [
      ":std/os/temporaries"
    ],
    "code": "(import :std/os/temporaries)\n\n;; Generate a unique temporary file name\n;; Takes exactly 1 arg: prefix string\n(def tmpfile (make-temporary-file-name \"myapp\"))\n;; => \"/tmp/myapp.eghagFpE.1770327980.9162219\"\n\n;; Safe cleanup: file is deleted even if body throws\n(call-with-temporary-file-name \"work\"\n  (lambda (path)\n    ;; path is a unique temp file name\n    (call-with-output-file path\n      (lambda (port) (display \"temp data\\n\" port)))\n    ;; ... use the file ...\n    (call-with-input-file path read-line)))\n;; File is automatically deleted after the lambda returns (or throws)\n\n;; Pattern: temp file with specific extension\n(def (make-temp-with-ext prefix ext)\n  (string-append (make-temporary-file-name prefix) \".\" ext))\n\n(make-temp-with-ext \"image\" \"png\")\n;; => \"/tmp/image.xxxxx.yyyyy.zzzzz.png\"\n\n;; Pattern: atomic write via temp file + rename\n(def (atomic-write! target-path write-fn)\n  (let ((tmp (make-temporary-file-name \"atomic\")))\n    (call-with-output-file tmp\n      (lambda (port) (write-fn port)))\n    (rename-file tmp target-path)))",
    "notes": ":std/os/temporaries provides safe temporary file handling. make-temporary-file-name takes exactly 1 arg (prefix string) — calling with 0 args causes \"Wrong number of arguments\". The generated name includes random characters and timestamp for uniqueness. call-with-temporary-file-name ensures cleanup via unwind-protect. For atomic file writes, use temp file + rename-file (rename is atomic on POSIX). The files are created in the system temp directory (/tmp on Unix).",
    "related": [
      "file-locking-flock",
      "read-file-to-string"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "dag-topological-walk",
    "title": "DAG traversal with cycle detection and attribute computation",
    "tags": [
      "dag",
      "graph",
      "topological",
      "sort",
      "cycle",
      "dependency",
      "walk",
      "tree"
    ],
    "imports": [
      ":std/misc/dag"
    ],
    "code": "(import :std/misc/dag)\n\n;; walk-dag traverses a directed acyclic graph with:\n;; - Cycle detection (raises error on cycles)\n;; - Computed attributes per node\n;; - Post-order visitation (children before parents)\n\n;; Signature: (walk-dag root children-fn visit-fn\n;;              visiting: visiting-table visited: visited-table)\n\n;; Example: build dependency graph\n;; Node = symbol, children = list of dependencies\n(def deps (hash\n  (app '(lib-a lib-b))\n  (lib-a '(core))\n  (lib-b '(core lib-a))\n  (core '())))\n\n(def (get-deps node) (hash-ref deps node []))\n\n;; walk-dag visits each node once, children first\n(def order [])\n(walk-dag 'app get-deps\n  (lambda (node children-results)\n    (set! order (cons node order))\n    node))\n(reverse order)\n;; => (core lib-a lib-b app) — topological order\n\n;; Pattern: compute aggregate attributes (e.g., transitive dep count)\n(def (count-transitive-deps root)\n  (walk-dag root get-deps\n    (lambda (node child-counts)\n      (+ 1 (apply + child-counts)))))\n\n(count-transitive-deps 'app)  ;; => 4 (app + lib-a + lib-b + core)\n\n;; Cycle detection: raises error if graph has cycles\n;; (def cyclic-deps (hash (a '(b)) (b '(a))))\n;; (walk-dag 'a (lambda (n) (hash-ref cyclic-deps n [])) ...)\n;; => ERROR: cycle detected",
    "notes": ":std/misc/dag provides walk-dag for traversing directed acyclic graphs. It uses two hash tables internally: visiting (currently on the stack, for cycle detection) and visited (already processed, for memoization). The visit function receives the node and a list of results from its children — this enables bottom-up attribute computation. Nodes are visited in post-order (children before parents). If a cycle is detected (node is in visiting but not visited), an error is raised. Use cases: dependency resolution, build ordering, module loading order, package management.",
    "related": [
      "rbtree-sorted-map",
      "hash-table-basics"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "ed25519-sign-verify",
    "title": "Ed25519 digital signatures: key generation, signing, and verification",
    "tags": [
      "crypto",
      "ed25519",
      "signature",
      "sign",
      "verify",
      "pkey",
      "keypair",
      "security"
    ],
    "imports": [
      ":std/crypto/pkey",
      ":std/text/hex"
    ],
    "code": "(import :std/crypto/pkey :std/text/hex)\n\n;; Generate an Ed25519 keypair\n(def kp (keygen/ed25519))\n;; kp is a list: (private-key public-key)\n(def privkey (car kp))\n(def pubkey (cadr kp))\n\n;; Serialize keys to bytes for storage/transmission\n(def privkey-bytes (private-key->bytes privkey))  ;; 64 bytes\n(def pubkey-bytes (public-key->bytes pubkey))     ;; 32 bytes\n\n;; Reconstruct keys from bytes\n(def privkey2 (bytes->private-key ED25519 privkey-bytes))\n(def pubkey2 (bytes->public-key ED25519 pubkey-bytes))\n\n;; Sign a message\n(def message (string->bytes \"Hello, authenticated world!\"))\n(def signature (digest-sign privkey message))\n;; signature is a u8vector (64 bytes for Ed25519)\n\n;; Verify a signature\n(digest-verify pubkey signature message)  ;; => #t\n\n;; Verify with wrong message\n(digest-verify pubkey signature (string->bytes \"tampered\"))  ;; => #f\n\n;; Pattern: sign and encode for transmission\n(def (sign-message privkey msg)\n  (let* ((msg-bytes (if (string? msg) (string->bytes msg) msg))\n         (sig (digest-sign privkey msg-bytes)))\n    (hex-encode sig)))\n\n;; Pattern: verify received message\n(def (verify-message pubkey msg sig-hex)\n  (let* ((msg-bytes (if (string? msg) (string->bytes msg) msg))\n         (sig (hex-decode sig-hex)))\n    (digest-verify pubkey sig msg-bytes)))",
    "notes": ":std/crypto/pkey wraps OpenSSL's EVP_PKEY API for public-key cryptography. keygen/ed25519 generates a random Ed25519 keypair (returns a list of private-key and public-key objects). digest-sign creates a signature using the private key; digest-verify checks it with the public key. Ed25519 signatures are 64 bytes, public keys are 32 bytes, private keys are 64 bytes. Keys can be serialized to/from u8vectors with private-key->bytes/bytes->private-key and public-key->bytes/bytes->public-key. The ED25519 constant identifies the algorithm for key reconstruction. Always use unwind-protect for FFI resource cleanup in production code.",
    "related": [
      "hmac-message-authentication",
      "aes-encrypt-decrypt"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "sqlite-database-operations",
    "title": "SQLite database operations (create, insert, query, transactions)",
    "tags": [
      "sqlite",
      "database",
      "sql",
      "dbi",
      "query",
      "transaction",
      "insert",
      "select"
    ],
    "imports": [
      ":std/db/dbi",
      ":std/db/sqlite"
    ],
    "code": "(import :std/db/dbi :std/db/sqlite)\n\n;; Open an in-memory database (or use a file path)\n(def db (sql-connect sqlite-open \":memory:\"))\n;; (def db (sql-connect sqlite-open \"/path/to/data.db\"))\n\n;; Quick eval: execute SQL without preparing a statement\n(sql-eval db \"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)\")\n(sql-eval db \"INSERT INTO users VALUES (1, 'Alice', 30)\")\n(sql-eval db \"INSERT INTO users VALUES (2, 'Bob', 25)\")\n(sql-eval db \"INSERT INTO users VALUES (3, 'Carol', 35)\")\n\n;; Quick query: sql-eval-query returns a list of rows\n;; Single-column results are bare values; multi-column results are vectors\n(sql-eval-query db \"SELECT * FROM users\")\n;; => (#(1 \"Alice\" 30) #(2 \"Bob\" 25) #(3 \"Carol\" 35))\n\n;; Parameterized queries (? placeholders bound positionally)\n(sql-eval-query db \"SELECT name, age FROM users WHERE age > ?\" 28)\n;; => (#(\"Alice\" 30) #(\"Carol\" 35))\n\n;; Prepared statements for repeated use\n(let ((stmt (sql-prepare db \"SELECT name FROM users WHERE age = ?\")))\n  (sql-bind stmt 30)\n  (let ((result (sql-query stmt)))\n    (sql-finalize stmt)\n    result))\n;; => (\"Alice\")\n\n;; Transactions: begin, commit, abort (rollback)\n(sql-txn-begin db)\n(sql-eval db \"INSERT INTO users VALUES (4, 'Dave', 40)\")\n(sql-txn-commit db)  ;; committed\n\n(sql-txn-begin db)\n(sql-eval db \"INSERT INTO users VALUES (5, 'Eve', 22)\")\n(sql-txn-abort db)   ;; rolled back — Eve not inserted\n\n;; Iterate query results with for/collect (or for-each)\n(import :std/iter)\n(let ((stmt (sql-prepare db \"SELECT name, age FROM users\")))\n  (let ((result (for/collect (row (in-sql-query stmt)) row)))\n    (sql-finalize stmt)\n    result))\n;; => (#(\"Alice\" 30) #(\"Bob\" 25) #(\"Carol\" 35) #(\"Dave\" 40))\n\n;; Always close when done\n(sql-close db)",
    "notes": "Use sql-connect with sqlite-open to create a DBI connection. sql-eval/sql-eval-query are convenience wrappers that prepare, bind, execute, and finalize in one call. For repeated queries, use sql-prepare/sql-bind/sql-query/sql-finalize explicitly. sql-query returns all result rows as a list; in-sql-query returns an iterable for lazy consumption. Single-column SELECT results are bare values (not vectors). Transactions use sql-txn-begin/sql-txn-commit/sql-txn-abort. The DBI interface is generic — the same sql-* functions work with PostgreSQL by using sql-connect with postgresql-connect instead of sqlite-open.",
    "related": [
      "error-handling"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "alist-association-list-operations",
    "title": "Association list operations (get, set, remove, convert)",
    "tags": [
      "alist",
      "association",
      "list",
      "key-value",
      "plist",
      "lookup",
      "asetq",
      "aremq",
      "acons"
    ],
    "imports": [
      ":std/misc/alist"
    ],
    "code": "(import :std/misc/alist)\n\n;; An alist is a list of (key . value) pairs\n(def al '((a . 1) (b . 2) (c . 3)))\n\n;; Lookup: use standard Scheme assq/assv/assoc\n(assq 'b al)   ;; => (b . 2)\n(cdr (assq 'b al))  ;; => 2\n\n;; Prepend a new key-value pair (standard cons-based)\n(acons 'd 4 al)\n;; => ((d . 4) (a . 1) (b . 2) (c . 3))\n\n;; Functional set: returns NEW alist with updated binding\n;; Signature: (asetq alist key value)\n(asetq al 'b 99)\n;; => ((a . 1) (b . 99) (c . 3))\n\n;; Functional remove: returns NEW alist without key\n;; Signature: (aremq key alist)\n(aremq 'b al)\n;; => ((a . 1) (c . 3))\n\n;; Destructive set: modifies the alist IN PLACE\n;; Signature: (asetq! alist key value)\n(def al2 (list (cons 'x 10) (cons 'y 20)))\n(asetq! al2 'y 99)\nal2  ;; => ((x . 10) (y . 99))\n\n;; Convert keyword plist to alist\n(plist->alist '(name: \"Alice\" age: 30 city: \"NYC\"))\n;; => ((name: . \"Alice\") (age: . 30) (city: . \"NYC\"))\n\n;; Predicate\n(alist? al)   ;; => #t\n(alist? '())  ;; => #t\n(alist? 42)   ;; => #f\n\n;; Variants by comparison:\n;;   asetq/aremq  — use eq?  (symbols, fixnums)\n;;   asetv/aremv  — use eqv? (chars, numbers)\n;;   aset/arem    — use equal? (strings, lists)",
    "notes": "GOTCHA: asetq and aremq have DIFFERENT argument orders! asetq is (asetq alist key value) but aremq is (aremq key alist). The ! variants (asetq!, aremq!) are destructive — they modify the alist in place. The non-! variants are functional — they return a new alist. Use asetq/aremq for symbol keys (eq?), asetv/aremv for char/number keys (eqv?), aset/arem for string/list keys (equal?). For hash-table-like performance with many entries, prefer hash tables instead.",
    "related": [
      "hash-table-create",
      "plist-keyword-config",
      "config-keyword-plist"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "random-number-generation",
    "title": "Generate random numbers (integers, reals, reproducible sequences)",
    "tags": [
      "random",
      "integer",
      "real",
      "seed",
      "random-source",
      "random-integer",
      "random-real"
    ],
    "imports": [],
    "code": ";; Random integer in [0, n) — Gambit builtin, no import needed\n(random-integer 100)   ;; => e.g. 42\n(random-integer 6)     ;; => 0..5 (simulating a die: add 1 for 1..6)\n\n;; Random real in [0.0, 1.0) — Gambit builtin\n(random-real)          ;; => e.g. 0.7382...\n\n;; Random integer in a range [lo, hi)\n(def (random-range lo hi)\n  (+ lo (random-integer (- hi lo))))\n(random-range 10 20)   ;; => 10..19\n\n;; Random element from a list\n(def (random-choice lst)\n  (list-ref lst (random-integer (length lst))))\n(random-choice '(red green blue))  ;; => e.g. green\n\n;; Reproducible sequences with random sources\n(def rs (make-random-source))\n(random-source-pseudo-randomize! rs 42 0)  ;; seed with two integers\n(def rand-int (random-source-make-integers rs))\n(def rand-real (random-source-make-reals rs))\n(rand-int 100)    ;; always same sequence for seed (42, 0)\n(rand-real)\n\n;; Random hex string (for tokens, IDs)\n(import :std/misc/string)\n(random-string 32)  ;; => e.g. \"a3f7c91b...\" (32 hex chars = 16 bytes)",
    "notes": "random-integer and random-real are Gambit builtins — no import needed. They use the default-random-source which is automatically seeded. For reproducible sequences, create a random-source with make-random-source and seed it with random-source-pseudo-randomize!. Then create dedicated integer/real generators from it with random-source-make-integers/random-source-make-reals. For random hex strings, use random-string from :std/misc/string. For shuffling lists/vectors, use :std/misc/shuffle (see shuffle recipe).",
    "related": [
      "shuffle-list-vector"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "match-pattern-matching",
    "title": "Pattern matching with match (destructure lists, structs, predicates)",
    "tags": [
      "match",
      "pattern",
      "destructure",
      "case",
      "dispatch",
      "predicate",
      "guard",
      "struct"
    ],
    "imports": [],
    "code": ";; match is a core Gerbil form — no import needed\n\n;; Match on literal values\n(match 'red\n  ('red \"stop\")\n  ('yellow \"caution\")\n  ('green \"go\"))\n;; => \"stop\"\n\n;; Destructure lists\n(match '(add 3 5)\n  (['add x y] (+ x y))\n  (['mul x y] (* x y))\n  (else \"unknown\"))\n;; => 8\n\n;; Head/tail (cons) destructuring\n(match '(1 2 3 4 5)\n  ([hd . tl] (list 'head: hd 'tail: tl)))\n;; => (head: 1 tail: (2 3 4 5))\n\n;; Nested list patterns\n(match '(1 \"hello\" #t)\n  ([a (? string? b) #t] (list 'matched a b))\n  (else 'no-match))\n;; => (matched 1 \"hello\")\n\n;; Predicate patterns with (? pred var)\n(def (describe val)\n  (match val\n    ((? number? n) (if (> n 0) \"positive\" \"non-positive\"))\n    ((? string? s) (string-append \"string: \" s))\n    ((? list? lst) (string-append \"list of \" (number->string (length lst))))\n    (#t \"true\")\n    (#f \"false\")\n    (else \"other\")))\n(describe 42)       ;; => \"positive\"\n(describe \"hi\")     ;; => \"string: hi\"\n(describe '(a b c)) ;; => \"list of 3\"\n\n;; Or-patterns (match any of several values)\n(match 1\n  ((or 0 1) \"binary digit\")\n  (else \"other\"))\n;; => \"binary digit\"\n\n;; Match on struct types (struct must be transparent: #t)\n(defstruct point (x y) transparent: #t)\n(match (make-point 3 4)\n  ((point x y) (sqrt (+ (* x x) (* y y)))))\n;; => 5\n\n;; Wildcard: use _ to ignore a position\n(match '(1 2 3)\n  ([_ second _] second))\n;; => 2\n\n;; else clause catches anything not matched\n(match 'unknown\n  ('a 1)\n  ('b 2)\n  (else 0))\n;; => 0",
    "notes": "match is a core Gerbil form (no import needed). Patterns: literal values, list destructuring with [], cons destructuring with [hd . tl], struct destructuring with (StructName fields...), predicate guards with (? pred var), or-patterns with (or pat1 pat2 ...), and _ as wildcard. Structs must be transparent: #t to match. The else clause (or a bare variable) catches everything. match raises an error if no clause matches and there's no else. For matching on multiple values, nest matches or use let-values + match. match is preferred over cond/if chains for structural dispatch.",
    "related": [
      "defstruct-positional-args",
      "multi-arity-def-star"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "tcp-client-server-sockets",
    "title": "TCP client and server sockets (connect, listen, accept)",
    "tags": [
      "tcp",
      "socket",
      "client",
      "server",
      "connect",
      "listen",
      "accept",
      "network",
      "port"
    ],
    "imports": [],
    "code": ";; Gambit builtins — no import needed\n\n;; === TCP Client ===\n;; open-tcp-client returns a bidirectional port\n(let ((sock (open-tcp-client\n              (list server-address: \"example.com\"\n                    port-number: 80))))\n  ;; Write a request\n  (display \"GET / HTTP/1.0\\r\\nHost: example.com\\r\\n\\r\\n\" sock)\n  (force-output sock)\n  ;; Read the response\n  (let ((first-line (read-line sock)))\n    (close-port sock)\n    first-line))\n;; => \"HTTP/1.1 200 OK\\r\"\n\n;; Shorter form: address:port string\n(let ((sock (open-tcp-client \"example.com:80\")))\n  (display \"HEAD / HTTP/1.0\\r\\nHost: example.com\\r\\n\\r\\n\" sock)\n  (force-output sock)\n  (let ((line (read-line sock)))\n    (close-port sock)\n    line))\n\n;; === TCP Server ===\n;; open-tcp-server listens and calls handler for each connection\n(def (start-echo-server port-num)\n  (open-tcp-server\n    (list server-address: \"*\"     ;; bind all interfaces\n          port-number: port-num\n          reuse-address: #t\n          backlog: 128\n          coalesce: #t)\n    (lambda (client)\n      ;; Each connection runs in its own thread automatically\n      (let loop ()\n        (let ((line (read-line client)))\n          (unless (eof-object? line)\n            (display line client)\n            (newline client)\n            (force-output client)\n            (loop))))\n      (close-port client))))\n\n;; === Client with timeout ===\n(with-exception-catcher\n  (lambda (e) (displayln \"connection failed: \" e) #f)\n  (lambda ()\n    (let ((sock (open-tcp-client\n                  (list server-address: \"localhost\"\n                        port-number: 8080\n                        keep-alive: #t))))\n      sock)))",
    "notes": "open-tcp-client and open-tcp-server are Gambit builtins — no import needed. open-tcp-client takes a settings list with server-address:, port-number:, and optionally keep-alive:, coalesce:. It returns a bidirectional port (both input and output). open-tcp-server spawns a new thread for each connection, calling the handler with the client port. The server runs in the background — use thread-join! to keep the main thread alive. For TLS/SSL connections, use :std/net/ssl instead. For higher-level HTTP, use :std/net/request. Always force-output after writing and close-port when done.",
    "related": [
      "run-subprocess-custom-env"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "string-ports-io",
    "title": "String ports for in-memory I/O (read from/write to strings)",
    "tags": [
      "string",
      "port",
      "input",
      "output",
      "with-input-from-string",
      "with-output-to-string",
      "call-with",
      "in-memory",
      "serialize"
    ],
    "imports": [],
    "code": ";; Gambit builtins — no import needed\n\n;; === Read from a string ===\n;; with-input-from-string: binds current-input-port to the string\n(with-input-from-string \"(+ 1 2)\" read)\n;; => (+ 1 2)  ;; returns the S-expression\n\n;; call-with-input-string: passes port as argument to procedure\n(call-with-input-string \"hello world\" read-line)\n;; => \"hello\"\n\n;; open-input-string: returns a port for manual use\n(let ((p (open-input-string \"line1\\nline2\\nline3\")))\n  (list (read-line p) (read-line p) (read-line p)))\n;; => (\"line1\" \"line2\" \"line3\")\n\n;; === Write to a string ===\n;; with-output-to-string: captures current-output-port as string\n(with-output-to-string\n  (lambda () (display \"hello \") (display \"world\")))\n;; => \"hello world\"\n\n;; call-with-output-string: passes port as argument\n(call-with-output-string\n  (lambda (p) (write '(a b c) p)))\n;; => \"(a b c)\"\n\n;; open-output-string + get-output-string for incremental building\n(let ((p (open-output-string)))\n  (display \"x=\" p)\n  (write 42 p)\n  (get-output-string p))\n;; => \"x=42\"\n\n;; === Common patterns ===\n;; Serialize any object to string\n(def (object->string obj)\n  (call-with-output-string (lambda (p) (write obj p))))\n\n;; Redirect a procedure's output to string\n(def (capture-output thunk)\n  (with-output-to-string thunk))\n\n;; Parse a string with a port-consuming procedure\n(def (parse-from-string str reader)\n  (call-with-input-string str reader))",
    "notes": "All string port functions are Gambit builtins — no import needed. Two styles: (1) with-input-from-string/with-output-to-string use current ports (implicit I/O), (2) call-with-input-string/call-with-output-string pass port as argument (explicit I/O). The open-input-string/open-output-string variants return a port for manual management — use get-output-string to extract the accumulated output. String ports are commonly used for serialization, testing I/O code, and redirecting output from procedures that only write to current-output-port (like write-json, write-xml).",
    "related": [
      "write-json-arity-1-parameterize",
      "write-xml-arity-1-parameterize"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "parameterize-dynamic-binding",
    "title": "Dynamic binding with make-parameter and parameterize",
    "tags": [
      "parameterize",
      "parameter",
      "dynamic",
      "binding",
      "thread-local",
      "make-parameter",
      "fluid",
      "context"
    ],
    "imports": [],
    "code": ";; Core Scheme — no import needed\n\n;; Create a parameter (thread-local dynamic variable)\n(def current-indent (make-parameter 0))\n(def current-verbose (make-parameter #f))\n\n;; Read the current value by calling the parameter\n(current-indent)    ;; => 0\n(current-verbose)   ;; => #f\n\n;; Set temporarily with parameterize (restores on exit)\n(parameterize ((current-indent 4)\n               (current-verbose #t))\n  (list (current-indent) (current-verbose)))\n;; => (4 #t)\n\n;; Value is restored even if an exception occurs\n(current-indent)    ;; => 0 (back to default)\n\n;; Nested parameterize composes\n(def (indented-print msg)\n  (display (make-string (current-indent) #\\space))\n  (displayln msg))\n\n(with-output-to-string\n  (lambda ()\n    (indented-print \"top\")\n    (parameterize ((current-indent 4))\n      (indented-print \"nested\")\n      (parameterize ((current-indent 8))\n        (indented-print \"deep\")))\n    (indented-print \"back\")))\n;; => \"top\\n    nested\\n        deep\\nback\\n\"\n\n;; Parameters are thread-local: each thread gets its own value\n;; (parameterize in one thread doesn't affect another)\n\n;; Set the global default (affects all threads)\n(current-verbose #t)  ;; call with value to set globally\n\n;; Parameter with validation/conversion\n(def current-log-level\n  (make-parameter 'info\n    (lambda (v)\n      (if (member v '(debug info warn error))\n        v\n        (error \"invalid log level\" v)))))",
    "notes": "make-parameter creates a thread-local dynamic variable. Read it by calling with no args: (my-param). Set it globally by calling with one arg: (my-param value). Use parameterize for scoped temporary binding — the old value is always restored, even on exception or escape continuation. Parameters are thread-local: parameterize in one thread doesn't affect other threads. The optional second arg to make-parameter is a guard/converter procedure called on every set. Common Gerbil parameters: current-input-port, current-output-port, current-error-port, current-directory, read-json-key-as-symbol?.",
    "related": [
      "write-json-arity-1-parameterize",
      "break-circular-imports-with-parameter"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "cut-partial-application",
    "title": "Partial application with cut (lightweight lambda shorthand)",
    "tags": [
      "cut",
      "partial",
      "application",
      "lambda",
      "shorthand",
      "slot",
      "placeholder",
      "map",
      "filter"
    ],
    "imports": [],
    "code": ";; cut is a builtin — no import needed\n;; <> marks argument slots (placeholders)\n\n;; Basic: partial application of binary functions\n(map (cut + <> 10) '(1 2 3))\n;; => (11 12 13)\n\n(filter (cut < <> 5) '(3 7 1 9 4 2))\n;; => (3 1 4 2)\n\n;; Multiple slots: filled left-to-right\n(map (cut string-append <> \"-\" <>) '(\"a\" \"b\") '(\"x\" \"y\"))\n;; => (\"a-x\" \"b-y\")\n\n;; Prefix application: fix the first arg\n(map (cut string-append \"prefix-\" <>) '(\"a\" \"b\" \"c\"))\n;; => (\"prefix-a\" \"prefix-b\" \"prefix-c\")\n\n;; No slots: just a thunk (zero-arg lambda)\n(def greet (cut displayln \"hello\"))\n(greet)  ;; prints: hello\n\n;; Slot in any position\n(map (cut vector-ref '#(a b c d e) <>) '(0 2 4))\n;; => (a c e)\n\n;; Equivalent to lambda but more concise:\n;; (cut + <> 10)     ≡  (lambda (x) (+ x 10))\n;; (cut f <> y <>)   ≡  (lambda (a b) (f a y b))\n;; (cut f)           ≡  (lambda () (f))\n\n;; Practical patterns:\n(for-each (cut displayln \"item: \" <>) '(\"a\" \"b\" \"c\"))\n;; prints: item: a \\n item: b \\n item: c\n\n(map (cut * 2 <>) '(1 2 3 4 5))\n;; => (2 4 6 8 10)",
    "notes": "cut is a Gerbil builtin (no import needed, unlike SRFI-26 in other Schemes). Use <> for argument slots — they're filled left-to-right when the resulting procedure is called. cut evaluates non-slot expressions at call time (not at definition time). Gerbil does NOT support <...> (rest-arg slot) or cute (evaluated-once variant). cut is most useful with map, filter, for-each, and other higher-order functions where a full lambda would be verbose. For more complex partial application, use a regular lambda.",
    "related": [
      "collect-results-with-for-collect",
      "srfi-1-list-utilities"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "named-let-loop",
    "title": "Named let for tail-recursive loops (the fundamental Scheme loop pattern)",
    "tags": [
      "named",
      "let",
      "loop",
      "recursion",
      "tail",
      "recursive",
      "iterate",
      "accumulate"
    ],
    "imports": [],
    "code": ";; Named let is core Scheme — no import needed\n\n;; Basic pattern: (let NAME ((var init) ...) body)\n;; NAME becomes a function that can be called recursively from body\n\n;; Accumulate squares\n(let loop ((i 0) (acc '()))\n  (if (>= i 5)\n    (reverse acc)\n    (loop (+ i 1) (cons (* i i) acc))))\n;; => (0 1 4 9 16)\n\n;; Sum a list\n(let loop ((lst '(1 2 3 4 5)) (sum 0))\n  (if (null? lst)\n    sum\n    (loop (cdr lst) (+ sum (car lst)))))\n;; => 15\n\n;; Find first element matching a predicate\n(let loop ((lst '(1 3 4 7 8)))\n  (cond\n    ((null? lst) #f)\n    ((even? (car lst)) (car lst))\n    (else (loop (cdr lst)))))\n;; => 4\n\n;; Read all lines from a port\n(def (read-all-lines port)\n  (let loop ((acc '()))\n    (let ((line (read-line port)))\n      (if (eof-object? line)\n        (reverse acc)\n        (loop (cons line acc))))))\n\n;; Count down with side effects\n(let loop ((n 5))\n  (when (> n 0)\n    (displayln n)\n    (loop (- n 1))))\n;; prints: 5 4 3 2 1\n\n;; Process items with index\n(let loop ((items '(a b c d)) (i 0))\n  (when (pair? items)\n    (displayln i \": \" (car items))\n    (loop (cdr items) (+ i 1))))\n\n;; Build a result vector\n(let ((v (make-vector 5)))\n  (let loop ((i 0))\n    (when (< i 5)\n      (vector-set! v i (* i 10))\n      (loop (+ i 1))))\n  v)\n;; => #(0 10 20 30 40)",
    "notes": "Named let is the fundamental Scheme iteration pattern. It creates a local recursive function — the loop variable becomes a procedure you call to continue iterating with new values. The tail calls are optimized by the compiler into actual loops (no stack growth). Use named let when: (1) you need an accumulator, (2) the loop shape doesn't fit for/for-each/map, (3) you need early exit (just don't recurse). For simpler iteration, prefer for-each/map/for from :std/iter. For accumulation, prefer for/fold from :std/iter. Named let is the go-to when those don't fit.",
    "related": [
      "while-until-loops",
      "for-fold-accumulation",
      "collect-results-with-for-collect"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "receive-multiple-values",
    "title": "Destructure multiple return values with receive and let-values",
    "tags": [
      "receive",
      "values",
      "multiple",
      "return",
      "destructure",
      "let-values",
      "bind"
    ],
    "imports": [],
    "code": ";; Core Scheme — no import needed\n\n;; Return multiple values\n(def (divide a b)\n  (values (quotient a b) (remainder a b)))\n\n;; receive: bind multiple return values (SRFI-8 style)\n(receive (q r) (divide 17 5)\n  (list 'quotient: q 'remainder: r))\n;; => (quotient: 3 remainder: 2)\n\n;; receive with single variable captures all as list\n(receive all (values 1 2 3) all)\n;; => (1 2 3)\n\n;; let-values: bind multiple values in a let-style form\n(let-values (((q r) (divide 17 5)))\n  (+ q r))\n;; => 5\n\n;; let-values with multiple bindings\n(let-values (((a b) (values 1 2))\n             ((c d) (values 3 4)))\n  (+ a b c d))\n;; => 10\n\n;; values->list: convert multiple values to a list (Gambit builtin)\n(values->list (values 'a 'b 'c))\n;; => (a b c)\n\n;; call-with-values: functional style\n(call-with-values\n  (lambda () (divide 17 5))\n  (lambda (q r) (list q r)))\n;; => (3 2)\n\n;; Common pattern: ignore extra return values\n(let-values (((result _) (divide 17 5)))\n  result)\n;; => 3",
    "notes": "Gerbil supports multiple return values via (values v1 v2 ...). To destructure: use receive (SRFI-8 style, more concise) or let-values (R7RS style, supports multiple clauses). receive does NOT support dotted rest patterns like (first . rest) — use a single variable to capture all as a list instead. values->list is a Gambit builtin that converts to a list. For more utilities (first-value, nth-value, values->vector, etc.), see :std/values.",
    "related": [
      "values-multiple-return"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gambit-port-byte-position-seek",
    "title": "Seek in Gambit file ports with output-port-byte-position / input-port-byte-position",
    "tags": [
      "gambit",
      "port",
      "seek",
      "position",
      "byte",
      "file",
      "offset"
    ],
    "imports": [],
    "code": ";; Gambit uses multi-arity functions for port positioning — NOT setter functions.\n;; There is NO output-port-byte-position-set! or input-port-byte-position-set!\n;;\n;; WRONG — these don't exist:\n;; (output-port-byte-position-set! port 0)  ;; ERROR: unbound\n;; (input-port-byte-position-set! port 0)   ;; ERROR: unbound\n;;\n;; CORRECT — use the same function name with position argument:\n(let ((out (open-output-file [path: \"/tmp/test.txt\" truncate: #f buffering: #f])))\n  (output-port-byte-position out 10)  ;; seek to byte offset 10\n  (write-subu8vector (string->bytes \"hello\") 0 5 out)\n  (close-output-port out))\n\n(let ((in (open-input-file [path: \"/tmp/test.txt\" buffering: #f])))\n  (input-port-byte-position in 10)  ;; seek to byte offset 10\n  (let ((buf (make-u8vector 5)))\n    (read-subu8vector buf 0 5 in)\n    (close-input-port in)\n    buf))  ;; => #u8(104 101 108 108 111) = \"hello\"\n\n;; Get current position (0 args after port):\n;; (output-port-byte-position port) => current position\n;; (input-port-byte-position port) => current position",
    "notes": "Gambit's port positioning API uses multi-arity: 1 arg = get position, 2 args = set position. This is different from the typical Scheme setter convention (set-foo! or foo-set!). The -set! variants do NOT exist and will give \"unbound variable\" errors. Works with buffering: #f for unbuffered I/O on file ports.",
    "related": [
      "gambit-runtime-primitives",
      "binary-io-subu8vector"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gambit-file-exception-types",
    "title": "Gambit file exception predicates for errno-style error handling",
    "tags": [
      "gambit",
      "exception",
      "file",
      "errno",
      "error",
      "no-such-file",
      "permission-denied"
    ],
    "imports": [],
    "code": ";; Gambit file operations throw SPECIFIC exception types, NOT os-exception?.\n;; os-exception? is for :std/os/error — Gambit builtins use their own types.\n;;\n;; WRONG — os-exception? returns #f for Gambit file errors:\n;; (import :std/os/error)\n;; (os-exception? e)  ;; => #f for file errors!\n;;\n;; CORRECT — use Gambit's specific exception predicates:\n(with-catch\n  (lambda (e)\n    (cond\n      ((no-such-file-or-directory-exception? e)\n       (displayln \"File not found\"))\n      ((permission-denied-exception? e)\n       (displayln \"Permission denied\"))\n      ((file-exists-exception? e)\n       (displayln \"File already exists\"))\n      (else\n       (displayln \"Other error: \" (with-output-to-string\n                                    (lambda () (display-exception e)))))))\n  (lambda () (open-input-file \"/nonexistent\")))\n\n;; Available Gambit file exception predicates (no import needed):\n;;   no-such-file-or-directory-exception?  — ENOENT\n;;   permission-denied-exception?          — EACCES/EPERM\n;;   file-exists-exception?                — EEXIST\n;;\n;; Each has accessors:\n;;   *-exception-procedure  — the function that raised it\n;;   *-exception-arguments  — the arguments passed to that function\n\n;; Pattern: map Gambit exceptions to errno for FFI/FUSE callbacks\n(def (with-errno thunk)\n  (with-catch\n    (lambda (e)\n      (cond\n        ((no-such-file-or-directory-exception? e) -2)   ;; ENOENT\n        ((permission-denied-exception? e) -13)          ;; EACCES\n        ((file-exists-exception? e) -17)                ;; EEXIST\n        (else -5)))                                     ;; EIO\n    thunk))",
    "notes": "Gambit's file I/O functions (open-input-file, delete-file, rename-file, create-directory, etc.) throw these specific exception types rather than a generic os-exception. The :std/os/error module's os-exception? predicate does NOT match these — it's for a different error hierarchy. Always use no-such-file-or-directory-exception?, permission-denied-exception?, and file-exists-exception? for Gambit file operations.",
    "related": [
      "error-handling",
      "gambit-runtime-primitives"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "gambit-ffi-shim-split-pattern",
    "title": "Split C shim into two files to avoid FFI forward declaration type mismatches",
    "tags": [
      "gambit",
      "ffi",
      "c-define",
      "c-declare",
      "shim",
      "forward-declaration",
      "type-mismatch"
    ],
    "imports": [],
    "code": ";; PROBLEM: When a C shim has forward declarations for c-define'd functions,\n;; the C types may not match Gambit's generated types.\n;; Example: you declare `int scheme_read(char *, void *, size_t, long, uint64_t);`\n;; but Gambit generates `unsigned long` for unsigned-int64, not uint64_t.\n;; This causes compile errors on ARM64 where uint64_t != unsigned long.\n;;\n;; SOLUTION: Split the C shim into two files:\n;;   shim.c          — headers, buffers, helpers (BEFORE c-define)\n;;   shim-trampolines.c — C trampolines that call scheme_* (AFTER c-define)\n;;\n;; In the FFI .ss file:\n\n(begin-ffi (...)\n  ;; Part 1: Include headers and helpers BEFORE c-define callbacks\n  (c-declare \"#include \\\"shim.c\\\"\")\n\n  ;; All c-define callbacks — Gambit generates correct forward declarations\n  (c-define (scheme_read path buf size offset fh)\n            (char-string (pointer void) size_t long unsigned-int64) int\n            \"scheme_read\" \"\"\n    ;; ... dispatch logic ...\n    )\n  ;; ... more c-define callbacks ...\n\n  ;; Part 2: Include trampolines AFTER c-define\n  ;; Now Gambit's generated forward declarations are in scope\n  ;; and the trampolines can call scheme_* with correct types\n  (c-declare \"#include \\\"shim-trampolines.c\\\"\")\n\n  ;; ... rest of FFI ...\n)\n\n;; shim-trampolines.c can safely call scheme_read() etc. because\n;; Gambit's c-define already generated the correct forward declarations\n;; with the exact C types Gambit uses internally.",
    "notes": "This pattern is essential for large FFI projects (like FUSE bindings) where C code calls back into Scheme. The key insight is that Gambit maps FFI types to C types in platform-specific ways (e.g., unsigned-int64 -> unsigned long on ARM64, not uint64_t). Writing your own forward declarations will inevitably mismatch. By splitting the shim and including trampolines AFTER c-define, you let Gambit generate the correct declarations automatically.",
    "related": [
      "gambit-ffi-pointer-types"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "nonnull-char-string-list-argv",
    "title": "Pass Scheme list as C char** argv using nonnull-char-string-list",
    "tags": [
      "gambit",
      "ffi",
      "argv",
      "char-string-list",
      "nonnull",
      "argc",
      "command-line"
    ],
    "imports": [],
    "code": ";; PROBLEM: C functions taking (int argc, char **argv) can't directly\n;; accept a Scheme list. (pointer char-string) doesn't auto-convert.\n;;\n;; SOLUTION: Use nonnull-char-string-list for the argv parameter.\n;; This auto-converts a Scheme list of strings to a NULL-terminated char**.\n;; But you still need argc — write a C wrapper that counts the list.\n\n;; In the C shim:\n;; int ffi_my_main_list(___SCMOBJ argv_list) {\n;;     int argc = 0;\n;;     char **p = (char **)argv_list;  // conceptually\n;;     // Actually, count the NULL-terminated array:\n;;     char **argv = ___CAST(char**, ___arg1);\n;;     while (argv[argc] != NULL) argc++;\n;;     return my_real_main(argc, argv);\n;; }\n\n;; In the FFI .ss file:\n;; (define-c-lambda ffi-my-main (nonnull-char-string-list) int\n;;   \"ffi_my_main_list\")\n\n;; Usage from Scheme:\n;; (ffi-my-main '(\"program-name\" \"-s\" \"-f\" \"/tmp/mountpoint\"))\n\n;; The C wrapper to count argc from NULL-terminated argv:\n;; static int ffi_my_main_list(char **argv) {\n;;     int argc = 0;\n;;     while (argv[argc]) argc++;\n;;     return real_main(argc, argv);\n;; }",
    "notes": "nonnull-char-string-list is Gambit's FFI type for passing a Scheme list of strings as a NULL-terminated char** array. The \"nonnull\" means the list itself cannot be #f. Each string in the list is automatically converted to a C string. The resulting array is NULL-terminated, which is how you determine argc in the C wrapper. This pattern is commonly needed for wrapping C main() functions (like fuse_main, getopt, etc.).",
    "related": [
      "gambit-ffi-pointer-types",
      "gambit-ffi-shim-split-pattern"
    ],
    "gerbil_version": "v0.18.1-173"
  },
  {
    "id": "barrier-synchronization-v19",
    "title": "Barrier synchronization for N threads to reach a checkpoint",
    "tags": [
      "barrier",
      "synchronization",
      "thread",
      "sync",
      "wait",
      "coordination"
    ],
    "imports": [
      ":std/sync/barrier"
    ],
    "code": "(import :std/sync/barrier)\n\n;; Create a barrier for N threads\n(def b (make-barrier 3))\n\n;; Each thread signals when it reaches the checkpoint\n(for (i (in-range 3))\n  (spawn (lambda ()\n    (thread-sleep! (* i 0.1))  ;; simulate varying work\n    (displayln \"thread \" i \" reached barrier\")\n    (barrier-post! b)           ;; signal \"I'm done\"\n    (displayln \"thread \" i \" past barrier\"))))\n\n;; Main thread waits for all 3 to post\n(barrier-wait! b)\n(displayln \"all threads reached the barrier\")\n\n;; Error propagation: if any thread fails, all waiters get the error\n(def b2 (make-barrier 2))\n(spawn (lambda ()\n  (with-barrier-error b2\n    (error \"worker failed!\"))))\n;; barrier-wait! will re-raise the error\n(with-catch\n  (lambda (e) (displayln \"barrier error: \" (error-message e)))\n  (lambda () (barrier-wait! b2)))",
    "notes": "Barriers use a mutex + condition variable internally. barrier-post! increments a counter and broadcasts when it reaches the limit. barrier-wait! blocks until all expected threads have posted. with-barrier-error catches exceptions in the body and propagates them to all waiters via barrier-error!. Once a barrier fires (or errors), it cannot be reused — create a new one.",
    "related": [
      "workgroup-thread-pool",
      "completion-async-value-v19"
    ],
    "gerbil_version": "v0.19"
  },
  {
    "id": "completion-async-value-v19",
    "title": "Completion: one-shot async value/error container",
    "tags": [
      "completion",
      "async",
      "future",
      "promise",
      "one-shot",
      "thread",
      "sync"
    ],
    "imports": [
      ":std/sync/completion"
    ],
    "code": "(import :std/sync/completion)\n\n;; Create a completion (like a one-shot promise/future)\n(def c (make-completion))\n\n;; Producer thread posts a value or error\n(spawn (lambda ()\n  (thread-sleep! 0.5)  ;; simulate async work\n  (completion-post! c 42)))\n\n;; Consumer blocks until value is available\n(def result (completion-wait! c))  ;; => 42\n\n;; Error propagation\n(def c2 (make-completion))\n(spawn (lambda ()\n  (completion-error! c2 (make-error \"async failure\"))))\n;; completion-wait! will raise the posted error\n(with-catch\n  (lambda (e) (displayln \"got error: \" (error-message e)))\n  (lambda () (completion-wait! c2)))\n\n;; with-completion-error: catch body errors and propagate to completion\n(def c3 (make-completion))\n(spawn (lambda ()\n  (with-completion-error c3\n    (let (result (risky-computation))\n      (completion-post! c3 result)))))\n;; If risky-computation throws, the error is posted to c3\n\n;; Pattern: async operation with timeout\n(def c4 (make-completion))\n(spawn (lambda ()\n  (let (data (fetch-remote-data))\n    (completion-post! c4 data))))\n;; Poll with timeout (using mutex-unlock! internally)\n(completion-wait! c4)  ;; blocks until ready",
    "notes": "Completions are one-shot: once a value or error is posted, it cannot be changed. Attempting to post twice raises an error. Multiple threads can wait on the same completion — all will be woken when the value is posted. completion-wait! returns the posted value or re-raises the posted error. This is simpler than channels for single-result async operations.",
    "related": [
      "barrier-synchronization-v19",
      "channel-communication-v19"
    ],
    "gerbil_version": "v0.19"
  },
  {
    "id": "channel-communication-v19",
    "title": "Channel-based communication between threads",
    "tags": [
      "channel",
      "communication",
      "thread",
      "producer",
      "consumer",
      "queue",
      "sync"
    ],
    "imports": [
      ":std/sync/channel"
    ],
    "code": "(import :std/sync/channel)\n(def ch (make-channel))\n\n;; Producer:\n(spawn (lambda ()\n  (for-each (lambda (x) (channel-put ch x)) '(1 2 3))\n  (channel-close ch)))\n\n;; Consumer — iterate until closed:\n(let loop ()\n  (let ((val (channel-try-get ch eof)))\n    (unless (eof-object? val)\n      (displayln \"got: \" val)\n      (loop))))",
    "notes": "Use channel-get for blocking reads. Avoid spinning on channel-try-get in a tight loop — use channel-get instead.",
    "related": [
      "spawn-thread",
      "barrier-synchronization-v19",
      "completion-async-value-v19"
    ],
    "gerbil_version": "v0.19"
  },
  {
    "id": "concurrency-pattern-decision-guide-v19",
    "title": "Concurrency pattern decision guide — choose the right primitive",
    "tags": [
      "concurrency",
      "thread",
      "channel",
      "barrier",
      "completion",
      "actor",
      "pattern",
      "guide",
      "sync"
    ],
    "imports": [],
    "code": ";; Concurrency Pattern Decision Guide for Gerbil Scheme v0.19\n;;\n;; Use case                          → Primitive               → Module\n;; ─────────────────────────────────────────────────────────────────────\n;; Fire-and-forget task              → spawn                   → (builtin)\n;; Multiple producers/consumers      → channel                 → :std/sync/channel\n;; One-shot async result (future)    → completion              → :std/sync/completion\n;; Wait for N tasks to finish        → barrier                 → :std/sync/barrier\n;; Thread pool with task queue       → workgroup (wg)          → :std/misc/wg\n;; Shared mutable state (simple)     → atom                    → :std/misc/atom\n;; Read-heavy shared state           → rwlock                  → :std/sync/rwlock\n;; Message passing / RPC             → actor                   → :std/actor\n;; Race multiple events              → sync/select             → :std/event\n;; Exclusive critical section        → mutex + unwind-protect  → (builtin)\n;;\n;; Quick decision tree:\n;; 1. Need to pass data between threads?\n;;    - Stream of values → channel\n;;    - Single result    → completion\n;; 2. Need to coordinate threads?\n;;    - Wait for all    → barrier or wg\n;;    - Wait for first  → sync/select\n;; 3. Need shared mutable state?\n;;    - Read-heavy      → rwlock\n;;    - Read/write even → atom\n;; 4. Need structured message passing?\n;;    - Request/reply   → actor (->>)\n;;    - Fire-and-forget → actor (->)",
    "notes": "This is a reference guide, not executable code. Each primitive listed here has its own cookbook recipe with working examples. Search for the specific pattern name (e.g., \"channel\", \"barrier\", \"workgroup\") to find detailed examples. NOTE: In v0.19, sync primitives moved: barrier/channel/completion/rwlock are now in :std/sync/, not :std/misc/. List utilities moved to :std/list/. Some modules remain in :std/misc/ or moved to v0.19-TODO/misc/.",
    "related": [
      "channel-communication-v19",
      "barrier-synchronization-v19",
      "completion-async-value-v19",
      "workgroup-thread-pool",
      "atom-atomic-reference",
      "actor-message-passing",
      "event-sync-select"
    ],
    "gerbil_version": "v0.19"
  },
  {
    "id": "alist-operations-v19",
    "title": "Association list operations (get, set, remove, convert)",
    "tags": [
      "alist",
      "association-list",
      "assoc",
      "assq",
      "asetq",
      "aremq",
      "plist",
      "list"
    ],
    "imports": [
      ":std/list/alist"
    ],
    "code": "(import :std/list/alist)\n\n;; An alist is a list of (key . value) pairs\n(def al '((a . 1) (b . 2) (c . 3)))\n\n;; Lookup: use standard Scheme assq/assv/assoc\n(assq 'b al)   ;; => (b . 2)\n(cdr (assq 'b al))  ;; => 2\n\n;; Prepend a new key-value pair (standard cons-based)\n(acons 'd 4 al)\n;; => ((d . 4) (a . 1) (b . 2) (c . 3))\n\n;; Functional set: returns NEW alist with updated binding\n;; Signature: (asetq alist key value)\n(asetq al 'b 99)\n;; => ((a . 1) (b . 99) (c . 3))\n\n;; Functional remove: returns NEW alist without key\n;; Signature: (aremq key alist)\n(aremq 'b al)\n;; => ((a . 1) (c . 3))\n\n;; Destructive set: modifies the alist IN PLACE\n;; Signature: (asetq! alist key value)\n(def al2 (list (cons 'x 10) (cons 'y 20)))\n(asetq! al2 'y 99)\nal2  ;; => ((x . 10) (y . 99))\n\n;; Convert keyword plist to alist\n(plist->alist '(name: \"Alice\" age: 30 city: \"NYC\"))\n;; => ((name: . \"Alice\") (age: . 30) (city: . \"NYC\"))\n\n;; Predicate\n(alist? al)   ;; => #t\n(alist? '())  ;; => #t\n(alist? 42)   ;; => #f\n\n;; Variants by comparison:\n;;   asetq/aremq  — use eq?  (symbols, fixnums)\n;;   asetv/aremv  — use eqv? (chars, numbers)\n;;   aset/arem    — use equal? (strings, lists)",
    "notes": "GOTCHA: asetq and aremq have DIFFERENT argument orders! asetq is (asetq alist key value) but aremq is (aremq key alist). The ! variants (asetq!, aremq!) are destructive — they modify the alist in place. The non-! variants are functional — they return a new alist. Use asetq/aremq for symbol keys (eq?), asetv/aremv for char/number keys (eqv?), aset/arem for string/list keys (equal?). For hash-table-like performance with many entries, prefer hash tables instead.",
    "related": [
      "hash-table-create",
      "plist-keyword-config",
      "config-keyword-plist"
    ],
    "gerbil_version": "v0.19"
  },
  {
    "id": "defobject-cache-object-pooling",
    "title": "Object pooling with defobject-cache",
    "tags": [
      "object",
      "cache",
      "pool",
      "reuse",
      "defobject-cache",
      "performance",
      "memory"
    ],
    "imports": [
      ":std/object"
    ],
    "code": "(import :std/object)\n\n;; Define a class that will be pooled\n(defclass MyBuffer ()\n  (data)\n  constructor: :init!)\n\n(defmethod {:init! MyBuffer}\n  (lambda (self)\n    (set! self.data (make-u8vector 4096 0))))\n\n;; Define reset function to prepare object for reuse\n(def (reset-buffer! (buf : MyBuffer))\n  (u8vector-fill! buf.data 0))\n\n;; Create object pool using defobject-cache\n;; Generates: buffer-cache.get (allocates or reuses), buffer-cache.put! (returns to pool)\n(defobject-cache buffer-cache MyBuffer make-MyBuffer reset-buffer!)\n\n;; Usage: get from pool\n(def buf1 (buffer-cache.get))  ;; new MyBuffer\n(displayln \"got buffer\")\n\n;; Use it...\n(u8vector-set! buf1.data 0 42)\n\n;; Return to pool when done\n(buffer-cache.put! buf1)  ;; calls reset-buffer! and adds to cache\n\n;; Next get reuses the same object\n(def buf2 (buffer-cache.get))  ;; reuses buf1\n(displayln (u8vector-ref buf2.data 0))  ;; => 0 (reset cleared it)",
    "notes": "defobject-cache creates a thread-safe object pool with a mutex-protected free list. The .get method either allocates a new object (via the constructor function) or pops from the cache. The .put! method calls the reset function then pushes to the cache. This reduces GC pressure for frequently allocated/deallocated objects like buffers, parsers, or formatters. The cache grows unbounded — it doesn't evict old objects. Best for workloads with bounded concurrency where the cache naturally stabilizes at the high-water mark.",
    "related": [
      "object-pooling",
      "gc-optimization",
      "do-with-lock"
    ],
    "gerbil_version": "v0.19"
  },
  {
    "id": "logging-with-std-log-v19",
    "title": "Structured logging with :std/log",
    "tags": [
      "log",
      "logging",
      "debug",
      "info",
      "warn",
      "error",
      "critical",
      "level"
    ],
    "imports": [
      ":std/log/default"
    ],
    "code": "(import :std/log/default)\n\n;; Simple logging at different levels\n(log.info \"Server started\" port: 8080)\n(log.debug \"Processing request\" method: \"GET\" path: \"/api/users\")\n(log.warn \"High memory usage\" usage: 85.5 threshold: 80.0)\n(log.error \"Database connection failed\" db: \"postgres\" error: err)\n(log.critical \"Disk full\" mount: \"/var\" available: 0)\n\n;; With formatted strings (printf-style)\n(log.infof \"Server started on port ~a\" 8080)\n(log.debugf \"Processing ~a ~a\" \"GET\" \"/api/users\")\n(log.warnf \"Memory usage: ~a% (threshold: ~a%)\" 85.5 80.0)\n\n;; Log levels (from least to most verbose):\n;; CRITICAL = -1  (always logged, system failures)\n;; ERROR    =  0  (errors that need attention)\n;; WARN     =  1  (warnings, degraded performance)\n;; INFO     =  2  (normal operation milestones)\n;; DEBUG    =  3  (detailed diagnostic info)\n;; VERBOSE  =  4  (trace-level debugging)\n\n;; Control logging level via environment variable:\n;; export GERBIL_LOG_LEVEL=INFO     # default level\n;; export GERBIL_LOG_LEVEL=INFO:myapp/db:DEBUG  # per-source override\n;; export GERBIL_LOG_LEVEL=WARN:myapp/*:DEBUG   # subsystem wildcard",
    "notes": "The :std/log system in v0.19 provides structured logging with log levels, per-source configuration, and formatted output. Messages are only generated if the log level is enabled (lazy evaluation). Use keyword arguments (port: 8080) for structured data, or *f variants (log.infof) for printf-style formatted strings. The log level can be set globally via GERBIL_LOG_LEVEL environment variable, with per-source overrides (source:level) and wildcard subsystems (prefix/*:level). The default logger logs to stderr via console sink. Logs include timestamp, level, source (typically module name), message, and structured data as an alist.",
    "related": [
      "debug-logging",
      "structured-logging",
      "error-handling"
    ],
    "gerbil_version": "v0.19"
  },
  {
    "id": "iterator-api-changes-v19",
    "title": "Iterator API changes in v0.19: renamed and removed functions",
    "tags": [
      "iter",
      "iterator",
      "in-range",
      "in-iota",
      "migration",
      "v0.19",
      "breaking-change"
    ],
    "imports": [
      ":std/iter"
    ],
    "code": "(import :std/iter)\n\n;; === RENAMED in v0.19 ===\n\n;; OLD (v0.18): in-iota\n;; NEW (v0.19): in-range\n(for (i (in-range 5))\n  (displayln i))  ;; 0 1 2 3 4\n\n;; in-range with start and optional step\n(for (i (in-range 2 10 2))\n  (displayln i))  ;; 2 4 6 8\n\n;; NEW in v0.19: in-range-inclusive (includes end)\n(for (i (in-range-inclusive 1 5))\n  (displayln i))  ;; 1 2 3 4 5\n\n;; OLD (v0.18): in-naturals\n;; NEW (v0.19): in-integers (infinite sequence)\n(for/fold (sum 0) ((i (in-integers)) (count 0))\n  (if (< count 5)\n    (values (+ sum i) (+ count 1))\n    (break sum)))  ;; => 10 (0+1+2+3+4)\n\n;; NEW in v0.19: in-number-series (arithmetic series)\n(for (x (in-number-series 1.0 0.5 10))\n  (displayln x))  ;; 1.0, 1.5, 2.0, ... up to 10 items\n\n;; === REMOVED in v0.19 ===\n;; These no longer exist in :std/iter:\n;;   in-input-port, in-input-lines, in-input-chars, in-input-bytes\n;; Likely moved to :std/io or :std/io/bio modules\n\n;; === NEW in v0.19 ===\n;; in-list, in-vector — explicit list/vector iterators\n(for (x (in-list '(a b c)))\n  (displayln x))  ;; a b c\n\n(for (x (in-vector #(1 2 3)))\n  (displayln x))  ;; 1 2 3\n\n;; Existing iterators still work:\n;; in-hash, in-hash-keys, in-hash-values, in-coroutine\n;; for, for*, for/collect, for/fold",
    "notes": "Breaking changes in :std/iter for v0.19: (1) in-iota renamed to in-range with consistent semantics. (2) in-naturals renamed to in-integers. (3) in-input-port and related port iterators removed from :std/iter (likely moved to :std/io modules — check there if needed). (4) New: in-range-inclusive (includes end point), in-number-series (arithmetic series), in-list, in-vector (explicit collection iterators). The module was reorganized into :std/iter/api, :std/iter/interface, :std/iter/iterators, :std/iter/macros but :std/iter still re-exports everything.",
    "related": [
      "for-collect-iteration",
      "for-fold-accumulation",
      "hash-iteration"
    ],
    "gerbil_version": "v0.19"
  },
  {
    "id": "format-printf-fprintf-v19",
    "title": "Format strings with printf/fprintf (v0.19 new API)",
    "tags": [
      "format",
      "printf",
      "fprintf",
      "eprintf",
      "string",
      "output",
      "v0.19"
    ],
    "imports": [
      "std/format"
    ],
    "code": "(import :std/format)\n\n;; NEW in v0.19: :std/format provides printf/fprintf/eprintf/format\n;; These take the port as an explicit argument (no parameterize needed)\n\n;; printf: format to stdout\n(printf \"Hello ~a!\\n\" \"world\")\n;; => Hello world!\n\n;; fprintf: format to a specific port (arity 3: port fmt args...)\n(call-with-output-string\n  (lambda (port)\n    (fprintf port \"Name: ~a, Age: ~a\" \"Alice\" 30)))\n;; => \"Name: Alice, Age: 30\"\n\n;; eprintf: format to stderr\n(eprintf \"Warning: ~a\\n\" \"disk full\")\n\n;; format: format to string (arity 2: fmt args...)\n(format \"Value: ~a, Count: ~a\" 42 10)\n;; => \"Value: 42, Count: 10\"\n\n;; Common format directives:\n;;   ~a  - any value (display format)\n;;   ~s  - S-expression (write format)\n;;   ~%  - newline\n;;   ~~  - literal tilde\n\n;; Multiple arguments:\n(format \"~a + ~a = ~a\" 2 3 5)\n;; => \"2 + 3 = 5\"\n\n;; Works with all types:\n(format \"List: ~a, Hash: ~a\" '(1 2 3) (hash (\"x\" 10)))\n;; => \"List: (1 2 3), Hash: #&lt;table #1&gt;\"",
    "notes": "This is a MAJOR improvement over v0.18 where :std/format required parameterize for string output. In v0.19, fprintf takes the port as a direct argument, and format returns a string. This matches Common Lisp conventions. The old :std/format used ~ escape but had limited directives and required parameterize. The new API is cleaner and more intuitive.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "list-builder-v19",
    "title": "Efficient O(1) list building with with-list-builder (v0.19 location)",
    "tags": [
      "list",
      "builder",
      "collect",
      "performance",
      "v0.19"
    ],
    "imports": [
      ":std/list/list-builder"
    ],
    "code": "(import :std/list/list-builder)\n\n;; with-list-builder provides O(1) append to a growing list\n;; Avoids O(n^2) from repeated (append lst (list new-item))\n(with-list-builder (push! peek)\n  (push! 'a)\n  (push! 'b)\n  (push! 'c)\n  (peek))  ;; => (a b c)\n\n;; Functional form:\n(call-with-list-builder\n  (lambda (push! peek)\n    (for (x (in-range 5))\n      (when (odd? x)\n        (push! x)))\n    (peek)))  ;; => (1 3)\n\n;; Common pattern: conditional collection\n(def (find-matching items pred)\n  (with-list-builder (collect)\n    (for-each (lambda (item)\n                (when (pred item)\n                  (collect item)))\n              items)))\n\n;; Nested collection with intermediate results\n(with-list-builder (push! peek)\n  (push! 'start)\n  (for (x '(1 2 3))\n    (push! (* x 10)))\n  (push! 'end)\n  (peek))  ;; => (start 10 20 30 end)",
    "notes": "In v0.19, list utilities moved from :std/misc/list-builder to :std/list/list-builder. The API is unchanged. This uses cons cell mutation internally: a sentinel cons cell [#f] is created, and push! mutates the cdr to append in O(1). Always prefer this over (set! result (append result (list item))). The peek function returns the current list without consuming it.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "object-cache-pattern-v19",
    "title": "Object pooling with defobject-cache (v0.19)",
    "tags": [
      "object",
      "cache",
      "pool",
      "performance",
      "memory",
      "v0.19"
    ],
    "imports": [
      ":std/object"
    ],
    "code": "(import :std/object)\n\n;; NEW in v0.19: defobject-cache for object pooling/reuse\n;; Reduces GC pressure by recycling objects instead of allocating new ones\n\n;; Define a reusable buffer class\n(defstruct buffer (data) mutable: #t)\n\n(def (make-new-buffer)\n  (make-buffer (make-u8vector 4096)))\n\n(def (reset-buffer! (b : buffer))\n  (u8vector-fill! (buffer-data b) 0))\n\n;; Create an object cache\n(defobject-cache buffer-cache buffer\n  make-new-buffer    ;; constructor\n  reset-buffer!)     ;; reset function\n\n;; Usage:\n;; Get a buffer from cache (reused or new)\n(def buf (buffer-cache.get))\n\n;; Use it...\n(u8vector-set! (buffer-data buf) 0 42)\n\n;; Return to cache for reuse\n(buffer-cache.put! buf)\n\n;; Expands to:\n;;   buffer-cache__cache   - list of available objects\n;;   buffer-cache__cache-mx - mutex protecting the cache\n;;   buffer-cache.get      - get object from cache or create new\n;;   buffer-cache.put!     - return object to cache after reset\n\n;; The cache is a simple stack (cons-based list)\n;; .get pops from cache or creates new\n;; .put! resets and pushes back to cache",
    "notes": "This is new in v0.19 (:std/object). Useful for high-frequency allocations where object reuse reduces GC pressure. The cache is thread-safe (uses mutex). Common use cases: buffers, temporary data structures, connection pools. The reset! function is called before returning the object to the cache to clear any state. Objects are stored in a list protected by a mutex.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "arithmetic-overflow-error-v19",
    "title": "New ArithmeticError and ArithmeticOverflow exceptions (v0.19)",
    "tags": [
      "error",
      "exception",
      "arithmetic",
      "overflow",
      "v0.19"
    ],
    "imports": [
      ":std/error"
    ],
    "code": "(import :std/error)\n\n;; NEW in v0.19: ArithmeticError exception hierarchy\n\n;; Raise arithmetic overflow error\n(def (safe-multiply a b)\n  (let ((result (* a b)))\n    (when (> result #x7FFFFFFFFFFFFFFF)  ;; fixnum max\n      (raise-arithmetic-overflow 'safe-multiply result))\n    result))\n\n;; Catch arithmetic errors\n(try\n  (safe-multiply 9999999999 9999999999)\n  (catch (ArithmeticOverflow e)\n    (displayln \"Overflow: \" (error-message e)))\n  (catch (ArithmeticError e)\n    (displayln \"Arithmetic error: \" (error-message e))))\n\n;; Check error type\n(def e (make-arithmetic-overflow-error \"overflow\" irritants: [value: 123]))\n(arithmetic-error? e)           ;; => #t (parent class)\n(arithmetic-overflow-error? e)  ;; => #t (specific class)\n\n;; Hierarchy:\n;;   Exception\n;;     RuntimeException\n;;       Error\n;;         ArithmeticError           (NEW)\n;;           ArithmeticOverflow      (NEW)",
    "notes": "New in v0.19: ArithmeticError and ArithmeticOverflow exception classes for arithmetic failures. Also note: raise-unsupported-method now takes a method argument: (raise-unsupported-method where method irritants ...). The method is stored in irritants with method: key. Similar changes to raise-contract-violation (contract: key) and raise-bad-argument (expectation: key).",
    "gerbil_version": "v0.19"
  },
  {
    "id": "v19-srfi-removal-warning",
    "title": "v0.19 WARNING: SRFI modules removed/moved to TODIE",
    "tags": [
      "v0.19",
      "breaking-change",
      "srfi",
      "migration",
      "warning"
    ],
    "imports": [],
    "code": ";; WARNING: In v0.19-dev-test-basis, SRFI modules have been REMOVED\n;; from src/std/srfi/ and moved to src/std/v0.19-TODIE/srfi/\n;;\n;; This means these modules are slated for removal:\n;;   :std/srfi/1   (list utilities)\n;;   :std/srfi/13  (string utilities)\n;;   :std/srfi/19  (time/date)\n;;   :std/srfi/42  (eager comprehensions)\n;;   and many others...\n;;\n;; IMPACT:\n;; - Any code using (import :std/srfi/19) will FAIL to compile\n;; - Recipes using SRFI-19 for date formatting will need updates\n;; - String utilities from SRFI-13 may need native :std/string replacements\n;;\n;; MIGRATION STATUS: Unknown\n;; - It's unclear what will replace these modules in v0.19\n;; - May need to use Gambit's built-in SRFI support instead\n;; - Or write native Gerbil replacements\n;;\n;; UNTIL v0.19 is finalized, DO NOT add new recipes using :std/srfi/* modules.\n;; Existing v0.18 recipes should be marked for review/update.",
    "notes": "This is a MAJOR breaking change. Many cookbook recipes use :std/srfi/19 for date formatting and :std/srfi/13 for string utilities. The current v0.19-dev-test-basis has these modules in v0.19-TODIE/ which suggests they will be removed. This branch is not yet stable - most stdlib is still in v0.19-TODO/ and not compiled.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "list-module-migration-v019",
    "title": "List modules moved from :std/misc to :std/list in v0.19",
    "tags": [
      "migration",
      "v0.19",
      "list",
      "alist",
      "plist",
      "list-builder",
      "walist",
      "import",
      "reorganization"
    ],
    "imports": [],
    "code": ";; In v0.18.x, list utilities were in :std/misc/*\n;; (import :std/misc/alist)\n;; (import :std/misc/plist)\n;; (import :std/misc/list-builder)\n;; (import :std/misc/walist)\n;; (import :std/misc/list)\n\n;; In v0.19+, they moved to :std/list/*\n(import :std/list/alist)\n(import :std/list/plist)\n(import :std/list/list-builder)\n(import :std/list/walist)\n(import :std/list/list)\n\n;; The APIs remained the same — only the module paths changed:\n;; alist:        asetq, aremq, acons, plist->alist, alist?, etc.\n;; plist:        pgetq, pputq, premq, etc.\n;; list-builder: with-list-builder, call-with-list-builder\n;; walist:       wasetq, waremq, wacollect, etc.\n;; list:         flatten, take, drop, split-at, etc.\n\n;; MIGRATION: Update all imports from :std/misc/* to :std/list/*\n;; No code changes needed — only import statements.",
    "notes": "This is a BREAKING CHANGE in v0.19. Code using :std/misc/alist etc. will fail with \"cannot find library module\" errors. The function APIs (asetq, aremq, plist->alist, etc.) are unchanged — only module paths changed. This reorganization groups all list-related utilities under :std/list/*, leaving :std/misc for other utilities. walist.ss was rewritten but the API is compatible.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "list-builder-v019",
    "title": "Efficient O(1) list building with with-list-builder (v0.19 import path)",
    "tags": [
      "list",
      "list-builder",
      "collect",
      "accumulate",
      "O(1)",
      "append",
      "v0.19"
    ],
    "imports": [
      ":std/list/list-builder"
    ],
    "code": "(import :std/list/list-builder)\n\n;; with-list-builder provides O(1) append to a growing list\n;; Avoids O(n^2) from repeated (append lst (list new-item))\n(with-list-builder (push! peek)\n  (push! 'a)\n  (push! 'b)\n  (push! 'c)\n  (peek))  ;; => (a b c)\n\n;; Functional form:\n(call-with-list-builder\n  (lambda (push! peek)\n    (for (x (in-range 5))\n      (when (odd? x)\n        (push! x)))\n    (peek)))  ;; => (1 3)\n\n;; Common pattern: conditional collection\n(def (find-matching items pred)\n  (with-list-builder (collect)\n    (for-each (lambda (item)\n                (when (pred item)\n                  (collect item)))\n              items)))\n\n;; Nested collection with intermediate results\n(with-list-builder (push! peek)\n  (push! 'start)\n  (for (x '(1 2 3))\n    (push! (* x 10)))\n  (push! 'end)\n  (peek))  ;; => (start 10 20 30 end)",
    "notes": "with-list-builder uses cons cell mutation internally: a sentinel cons cell [#f] is created, and push! mutates the cdr to append in O(1). This prevents the O(n^2) quadratic append pattern. Always prefer this over (set! result (append result (list item))). The peek function returns the current list without consuming it. push! always appends to the end (maintains insertion order). In v0.19, the module path changed from :std/misc/list-builder to :std/list/list-builder.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "iter-module-refactor-v019",
    "title": "Iterator module refactored into submodules in v0.19",
    "tags": [
      "migration",
      "v0.19",
      "iter",
      "for",
      "for/collect",
      "for/fold",
      "iterator",
      "refactor"
    ],
    "imports": [
      ":std/iter"
    ],
    "code": ";; In v0.18.x, :std/iter was a single monolithic file (926 lines)\n;; In v0.19+, :std/iter became a package with submodules:\n;;   :std/iter/api        — public API (re-exported by :std/iter)\n;;   :std/iter/interface  — Iterator interface definitions\n;;   :std/iter/iterators  — Built-in iterators (in-range, in-list, etc.)\n;;   :std/iter/macros     — for/for*/for-collect/for-fold macros\n\n;; USER CODE UNCHANGED: still import :std/iter for normal use\n(import :std/iter)\n\n;; Available iterators (same as v0.18.x):\n(for/collect (x (in-range 10)) (* x x))\n(for/collect (x (in-list '(a b c))) x)\n(for ((k v) (in-hash (hash (\"a\" 1) (\"b\" 2)))) (displayln k \": \" v))\n(for (k (in-hash-keys (hash (\"x\" 10)))) (displayln k))\n(for (v (in-hash-values (hash (\"y\" 20)))) (displayln v))\n\n;; New in v0.19: in-range-inclusive and in-number-series\n(for/collect (x (in-range-inclusive 1 5)) x)\n;; => (1 2 3 4 5)  -- includes endpoint\n\n;; in-integers is an alias for in-naturals\n(def naturals (in-integers))\n;; infinite sequence 0, 1, 2, 3, ...\n\n;; For INTERNAL/EXTENSION use, you can now import submodules directly:\n;; (import :std/iter/interface)  — Iterator protocol\n;; (import :std/iter/iterators)  — Built-in iterator constructors\n;; (import :std/iter/macros)     — Macro definitions",
    "notes": "This refactor is MOSTLY TRANSPARENT to user code. The public API exported by :std/iter remains compatible with v0.18.x. The main change is organizational: the monolithic file was split into interface, iterators, and macros. New iterators in v0.19: in-range-inclusive (includes endpoint), in-number-series (arithmetic/geometric sequences), in-integers (alias for in-naturals). The for macro now supports type contracts in bindings: (for (x expr :- :fixnum) ...). For advanced use (extending the iterator protocol), use :std/iter/interface.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "log-module-v019",
    "title": "New structured logging system in :std/log (v0.19)",
    "tags": [
      "logging",
      "log",
      "v0.19",
      "debug",
      "error",
      "warn",
      "info",
      "structured",
      "logger"
    ],
    "imports": [
      ":std/log"
    ],
    "code": ";; NEW in v0.19: Comprehensive structured logging framework\n;; NOT AVAILABLE in v0.18.x\n\n;; Core modules:\n;;   :std/log              — top-level package (imports all submodules)\n;;   :std/log/level        — log levels: CRITICAL ERROR WARN INFO DEBUG VERBOSE\n;;   :std/log/interface    — Logger and LogSink interfaces, Record struct\n;;   :std/log/macros       — log.debug, log.info, log.warn macros\n;;   :std/log/user         — user-facing logger (default logger)\n;;   :std/log/console      — console output sink\n;;   :std/log/format       — log formatting\n;;   :std/log/rotate       — log file rotation\n;;   :std/log/compress     — log compression support\n;;   :std/log/system       — system-wide logger\n;;   :std/log/default      — default logger configuration\n;;   :std/log/proto        — protocol definitions\n\n;; Log levels (predefined constants):\n;; CRITICAL = -1\n;; ERROR    =  0\n;; WARN     =  1\n;; INFO     =  2\n;; DEBUG    =  3\n;; VERBOSE  =  4\n\n;; Log record structure:\n;; (defstruct Record\n;;   ((ts     : Time)       ;; timestamp (from :std/time)\n;;    (level  : :fixnum)    ;; log level constant\n;;    (source : :symbol)    ;; source identifier (e.g., 'my-app)\n;;    (msg    : :string)    ;; log message\n;;    (data   : PureAList)) ;; structured key-value metadata\n;;   transparent: #t)\n\n;; Logger interface:\n;; (interface Logger\n;;   (name)                         => :symbol\n;;   (level)                        => :fixnum\n;;   (set-level! (level : :fixnum)) => :void\n;;   (log (obj : Record))           => :void)\n\n;; Environment variable: GERBIL_LOG_LEVEL\n;; Format: <default>:<source1>:<level1>:<source2>:<level2>:...\n;; Example: ERROR:myapp/http:DEBUG:myapp/db:VERBOSE\n;;   Sets global default to ERROR\n;;   Sets myapp/http to DEBUG\n;;   Sets myapp/db to VERBOSE\n\n;; Subsystem wildcards: \"myapp/*\" matches all myapp/... sources\n\n;; NOTE: Full logging API examples will be added once v0.19 is compiled.\n;; This recipe documents the module structure discovered from source.",
    "notes": "The :std/log module is COMPLETELY NEW in v0.19 — it did not exist in v0.18.x. It provides a comprehensive structured logging framework with: log levels (CRITICAL/ERROR/WARN/INFO/DEBUG/VERBOSE), timestamped log records with structured metadata (alist data), logger interfaces with configurable sinks, console/file/rotating output, environment-variable-based configuration (GERBIL_LOG_LEVEL), subsystem-level log filtering, and macro-based logging (log.debug, log.info, etc.). The framework integrates with :std/time for timestamps and :std/format for output formatting. This is a significant addition — equivalent to adding Python's logging module or Go's zap/logrus.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "time-module-v019",
    "title": "New time abstraction in :std/time (v0.19)",
    "tags": [
      "time",
      "timeout",
      "timestamp",
      "v0.19",
      "duration",
      "deadline"
    ],
    "imports": [
      ":std/time"
    ],
    "code": ";; NEW in v0.19: Abstract time types and timeout handling\n;; NOT AVAILABLE in v0.18.x\n\n;; Core modules:\n;;   :std/time/time     — Time type hierarchy (ExactTime, InexactTime)\n;;   :std/time/timeout  — Timeout and deadline handling (IOTimeout, AbsTimeout)\n;;   :std/time/format   — Time formatting (planned, not implemented yet)\n\n;; Time type hierarchy:\n;; (defstruct Time () ...)                          ;; base type\n;; (defstruct (ExactTime Time) () ...)              ;; exact time (future: timeval/timespec)\n;; (defstruct (InexactTime Time) ((time :- :flonum)) ...) ;; inexact (float seconds)\n\n;; Create current time (inexact):\n;; (def now (current-time-inexact))\n;; => #&lt;InexactTime #N&gt;\n;;\n;; Access the float timestamp:\n;; (InexactTime-time now)  ;; => 1234567890.123 (flonum)\n\n;; Timeout handling with IOTimeout:\n;; (defstruct IOTimeout (t) ...)  ;; wrapper for optional timeout\n;; (def !NoTimeout (IOTimeout #f))  ;; singleton for \"no timeout\"\n\n;; AbsTimeout interface: convert relative timeout to absolute deadline\n;; Implementations for: InexactTime, :flonum, :real, :time, IOTimeout\n;;\n;; (def timeout-5s (IOTimeout 5.0))  ;; 5 seconds from now\n;; (abs-timeout timeout-5s)          ;; => absolute :time deadline\n\n;; Timeout predicates and conversion:\n;; (timeout? obj)                   ;; #t if obj is a valid timeout\n;; (timeout->abs-timeout timeo)     ;; convert to absolute :time or absent-obj\n\n;; NOTE: Full API examples will be added once v0.19 is compiled.\n;; ExactTime (timeval/timespec FFI) is TODO in v0.19 source.\n;; Time formatting is planned but not yet implemented.",
    "notes": "The :std/time module is COMPLETELY NEW in v0.19 — it did not exist in v0.18.x. It provides abstract time types (Time, ExactTime, InexactTime) and timeout/deadline handling (IOTimeout, AbsTimeout interface). InexactTime wraps Gambit's ##current-time-point as a flonum. The AbsTimeout interface converts relative timeouts (e.g., 5.0 seconds) to absolute deadlines. This is used by the IO system for timeouts. ExactTime (timeval/timespec FFI) is planned but not yet implemented in v0.19 — source shows TODO comments. Time formatting is also planned (:std/time/format stub exists) but not implemented. This module separates time abstractions from the IO system, following the pattern of separating concerns across :std/time, :std/log, :std/format.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "format-module-v019",
    "title": "New structured formatting system in :std/format (v0.19)",
    "tags": [
      "format",
      "print",
      "display",
      "debug",
      "serialization",
      "v0.19",
      "writer",
      "reader"
    ],
    "imports": [
      ":std/format"
    ],
    "code": ";; NEW in v0.19: Generic object formatting and serialization framework\n;; NOT AVAILABLE in v0.18.x\n\n;; Core modules:\n;;   :std/format/env     — FormatEnv (formatting environment/context)\n;;   :std/format/io      — ObjectWriter and ObjectReader interfaces\n;;   :std/format/string  — to-string (Stringer interface)\n;;   :std/format/ioutil  — formatting utilities\n;;   :std/format/writer  — writer extensions (defwriter-ext)\n;;   :std/format/reader  — reader extensions (defreader-ext)\n\n;; ObjectWriter interface:\n;; (interface ObjectWriter\n;;   (write (writer : BufferedWriter) (env : FormatEnv)) => :fixnum)\n\n;; Writer methods (extension points):\n;;   (writer.println obj env)      — write object + newline + flush\n;;   (writer.display obj env)      — display style (FORMAT-DISPLAY)\n;;   (writer.debug obj env)        — debug style (FORMAT-DEBUG)\n;;   (writer.format obj env)       — default format (handles cycles via @serialize)\n;;   (writer.format-raw obj env)   — raw format (no cycle detection)\n\n;; Stringer interface (convert object to string):\n;; (interface Stringer\n;;   (to-string) => :string)\n;;\n;; (to-string obj)  ;; generic dispatcher, calls {to-string obj}\n\n;; Formatting environment:\n;; (defstruct FormatEnv\n;;   ((style : :fixnum)   ;; FORMAT-DISPLAY or FORMAT-DEBUG\n;;    (scan  : Scanner))  ;; cycle detection scanner from :std/serde/scan\n;;   ...)\n\n;; Cycle detection and anchors:\n;; (writer.format obj env) uses @serialize from :std/serde/serialize\n;; to detect cycles and emit #N= anchors and #N# references.\n\n;; NOTE: Full API examples will be added once v0.19 is compiled.\n;; This is a foundational module used by :std/encoding/json and :std/log.",
    "notes": "The :std/format module is COMPLETELY NEW in v0.19 — it did not exist in v0.18.x. It provides a generic formatting framework with: ObjectWriter/ObjectReader interfaces for custom type serialization, Stringer interface for to-string conversion, FormatEnv for contextual formatting (display vs debug style), cycle detection via :std/serde/serialize with #N= anchors and #N# references, writer/reader extension macros (defwriter-ext, defreader-ext). This module is the foundation for structured output in :std/log (log formatting) and :std/encoding/json (JSON serialization). It integrates with :std/io/bio for buffered I/O. This is a major architectural addition — equivalent to adding a generic serialization framework to the stdlib.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "test-module-v019",
    "title": "New unit testing framework in :std/test (v0.19)",
    "tags": [
      "test",
      "testing",
      "unit-test",
      "v0.19",
      "test-suite",
      "test-case",
      "assertions"
    ],
    "imports": [
      ":std/test"
    ],
    "code": ";; NEW in v0.19: Structured unit testing framework\n;; NOT AVAILABLE in v0.18.x (v0.18 had :std/test but with different API)\n\n;; Core modules:\n;;   :std/test/base — Testing infrastructure (TestObject, TestHarness, etc.)\n;;   :std/test/unit — Unit testing API (re-exports base)\n\n;; Test object hierarchy:\n;; TestObject (base class)\n;;   ├─ TestHarness  (top-level test runner with config)\n;;   ├─ TestModule   (module-level grouping)\n;;   ├─ TestSuite    (suite-level grouping)\n;;   └─ TestCase     (individual test with thunk)\n\n;; TestConfig settings:\n;; (defclass TestConfig\n;;   ((verbosity       : :fixnum)     ;; 0-7 (QUIET to CHATTY)\n;;    (capture-output? : :boolean))   ;; capture stdout/stderr\n;;   ...)\n\n;; Verbosity levels:\n;; VERBOSITY-QUIET   = 0  (silent)\n;; VERBOSITY-ERROR   = 1  (errors only)\n;; VERBOSITY-HARNESS = 2  (harness messages)\n;; VERBOSITY-MODULE  = 3  (module level)\n;; VERBOSITY-SUITE   = 4  (suite level)\n;; VERBOSITY-CASE    = 5  (test case level)\n;; VERBOSITY-CHECK   = 6  (individual checks)\n;; VERBOSITY-CHATTY  = 7  (everything)\n\n;; Test results:\n;; (defstruct TestResult ((context : :t) (result : :symbol)) ...)\n;; (defstruct (TestResultError TestResult) ((exn : :t)) ...)\n;; (defstruct (TestResultErrors TestResult) ((errors : :list)) ...)\n;;\n;; (test-result-ok ctx)      => TestResult with 'OK\n;; (test-result-error ctx e) => TestResultError with 'ERROR\n;; (test-result-ok? result)  => #t if result is 'OK\n;; (test-result-error? result) => #t if result is 'ERROR\n\n;; Test context (parameters):\n;; (current-test-config)   => TestConfig or #f\n;; (current-test-harness)  => TestHarness or #f\n;; (current-test-module)   => TestModule or #f\n;; (current-test-exit)     => exit continuation or #f\n;;\n;; (test-exit! result)     — exit current test with result\n\n;; NOTE: Full API examples (defining tests, running suites) will be\n;; added once v0.19 is compiled and the macro layer is available.",
    "notes": "The :std/test module was SIGNIFICANTLY REFACTORED in v0.19. The v0.18 :std/test had a simpler API (check, check-equal?, test-suite, run-tests!). The v0.19 version introduces a hierarchical test object model (TestHarness → TestModule → TestSuite → TestCase), structured result objects (TestResult, TestResultError), configurable verbosity levels (0-7), output capture, and parameterized test context (current-test-config, current-test-harness, etc.). The base infrastructure is in :std/test/base, exported by :std/test/unit. This brings the testing framework closer to Python's unittest or Go's testing package in terms of structure and configurability. The macro layer for defining tests is not yet visible in the source files examined.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "json-module-migration-v019",
    "title": "JSON module moved from :std/text/json to :std/encoding/json (v0.19)",
    "tags": [
      "migration",
      "v0.19",
      "json",
      "encoding",
      "refactor",
      "import"
    ],
    "imports": [
      ":std/encoding/json"
    ],
    "code": ";; In v0.18.x, JSON was in :std/text/json\n;; (import :std/text/json)\n\n;; In v0.19+, JSON moved to :std/encoding/json\n;; HOWEVER: :std/text/json still exists as a compatibility shim in v0.19-TODO\n;; (import :std/text/json)   ;; works but deprecated, re-exports :std/text/json/api\n;; (import :std/encoding/json)  ;; new canonical location (NOT YET IMPLEMENTED)\n\n;; The v0.19 JSON refactor is INCOMPLETE as of this commit:\n;; - :std/encoding/json/* modules exist (env, io, reader, writer)\n;; - But they're skeletal stubs with XXX placeholders\n;; - :std/text/json moved to :std/v0.19-TODO/text/json (deferred)\n;; - Production code should still use :std/text/json for now\n\n;; The planned v0.19 JSON structure:\n;;   :std/encoding/json/env     — JSONEnv (formatting environment)\n;;   :std/encoding/json/io      — JSONWriter/JSONReader interfaces\n;;   :std/encoding/json/reader  — JSON parsing\n;;   :std/encoding/json/writer  — JSON generation\n\n;; API changes planned (from :std/v0.19-TODO/text/json/api.ss):\n;; - read-json, write-json (same)\n;; - string->json-object, json-object->string (same)\n;; - bytes->json-object, json-object->bytes (same)\n;; - read-json-key-as-symbol?, read-json-object-as-walist? (same)\n;; - write-json-sort-keys? (same)\n;; - Deprecated: json-symbolic-keys, json-sort-keys, json-list-wrapper\n;;   (marked TO BE REMOVED in v0.19)\n\n;; MIGRATION: Wait for v0.19 JSON implementation to complete.\n;; For now, continue using :std/text/json as in v0.18.x.",
    "notes": "The JSON refactor in v0.19 is INCOMPLETE. The module was planned to move from :std/text/json to :std/encoding/json and integrate with the new :std/format framework (ObjectWriter/ObjectReader interfaces, cycle detection). However, the implementation is skeletal — :std/encoding/json/io.ss has XXX placeholders. The old :std/text/json was moved to :std/v0.19-TODO/text/json, indicating it's deferred. Until the refactor is complete, production code should continue using :std/text/json. The v0.19-TODO version notes that json-symbolic-keys, json-sort-keys, and json-list-wrapper are deprecated and marked for removal.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "serde-module-v019",
    "title": "New serialization framework in :std/serde (v0.19)",
    "tags": [
      "serde",
      "serialization",
      "cycle-detection",
      "v0.19",
      "scanner",
      "serialize"
    ],
    "imports": [
      ":std/serde"
    ],
    "code": ";; NEW in v0.19: Serialization and cycle detection framework\n;; NOT AVAILABLE in v0.18.x\n\n;; Core modules:\n;;   :std/serde/scan       — cycle detection scanner\n;;   :std/serde/scanner    — scanner implementation\n;;   :std/serde/serialize  — @serialize macro for safe traversal\n;;   :std/serde/interned   — interned object tracking\n;;   :std/serde/opaque     — opaque object handling\n\n;; The :std/serde module provides:\n;; 1. Cycle detection: detect when an object graph has cycles\n;; 2. Anchor/reference tracking: assign #N= anchors to shared objects\n;; 3. Safe serialization: traverse object graphs without infinite loops\n\n;; @serialize macro pattern (from :std/format/io):\n;; (@serialize obj scan do-object do-anchor do-reference)\n;;   scan          — scanner (from FormatEnv or SerdeEnv)\n;;   do-object     — (lambda (obj) ...) called for first-time objects\n;;   do-anchor     — (lambda (obj id) ...) called when object needs anchor\n;;   do-reference  — (lambda (id) ...) called for back-references\n\n;; Example usage (from :std/format/io.ss):\n;; (defwriter-ext (format writer obj (env : FormatEnv))\n;;   (defrule (do-object obj)\n;;     (writer.format-raw obj env))\n;;   (defrule (do-anchor obj id)\n;;     (writer.format-anchor obj id env))\n;;   (defrule (do-reference id)\n;;     (writer.format-reference id env))\n;;   (@serialize obj env.scan do-object do-anchor do-reference))\n\n;; This emits output like:\n;;   #0=(1 2 #0#)  ;; #0= is anchor, #0# is back-reference\n\n;; NOTE: Full API examples will be added once v0.19 is compiled.\n;; This is a foundational module for :std/format and future serializers.",
    "notes": "The :std/serde module is COMPLETELY NEW in v0.19 — it did not exist in v0.18.x. It provides a generic serialization framework with cycle detection. The @serialize macro traverses object graphs and calls: do-object for new objects, do-anchor when an object is seen multiple times (needs #N= anchor), do-reference for back-references (#N#). This prevents infinite loops when serializing cyclic structures. The scanner tracks which objects have been seen and assigns IDs. This is used by :std/format for safe object formatting and will be used by future serializers (JSON, protobuf, etc.). Interned objects (symbols, keywords) can be tracked separately. Opaque objects can be marked as non-traversable.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "io-bio-refactor-v019",
    "title": "Buffered I/O (bio) refactored with reader/writer split (v0.19)",
    "tags": [
      "io",
      "bio",
      "buffered-io",
      "reader",
      "writer",
      "v0.19",
      "refactor"
    ],
    "imports": [
      ":std/io/bio"
    ],
    "code": ";; MAJOR REFACTOR in v0.19: :std/io/bio split into reader/writer modules\n;; In v0.18.x, bio had: input.ss, output.ss, util.ss (large monoliths)\n;; In v0.19+, bio was reorganized:\n\n;; NEW modules:\n;;   :std/io/bio/reader   — BufferedReader API (563 lines, new)\n;;   :std/io/bio/writer   — BufferedWriter API (312 lines, new)\n;;   :std/io/bio/buffer   — Buffer management (54 lines, new)\n;;   :std/io/bio/cache    — Cache support (43 lines, new)\n;;   :std/io/bio/memory   — In-memory streams (93 lines, new)\n;;   :std/io/bio/message  — Message framing (13 lines, new)\n;;   :std/io/bio/srcsnk   — Source/sink abstractions (129 lines, new)\n;;   :std/io/bio/macros   — Shared macros (48 lines, new)\n\n;; REMOVED modules:\n;;   :std/io/bio/chunked  — removed (24 lines deleted)\n;;   :std/io/bio/inline   — removed (74 lines deleted)\n\n;; REFACTORED modules:\n;;   :std/io/bio/util     — shrunk from 732 lines to much smaller\n;;   :std/io/bio/input    — refactored (491 lines changed)\n;;   :std/io/bio/output   — refactored (160 lines changed)\n;;   :std/io/bio/delimited — refactored (177 lines changed)\n\n;; The strio/ package was REMOVED entirely:\n;;   :std/io/strio/*      — deleted (1223 lines removed)\n\n;; API impact: The public :std/io/bio API should remain compatible.\n;; Internal refactor: better separation between reader/writer,\n;; cleaner buffer management, memory streams as first-class.\n\n;; NOTE: Full migration examples will be added once v0.19 is compiled\n;; and the new bio API is tested.",
    "notes": "The :std/io/bio refactor in v0.19 is a MAJOR internal reorganization. The main changes: (1) Split reader/writer into separate modules with dedicated APIs (BufferedReader, BufferedWriter). (2) Added new abstractions: buffer management, cache, memory streams, message framing, source/sink. (3) Removed chunked and inline modules. (4) Shrunk util.ss from 732 lines. (5) Deleted the entire strio/ package (1223 lines) — its functionality was absorbed into bio/. The goal is cleaner separation of concerns and better abstractions. Public API compatibility should be maintained through :std/io/bio/api, but internal code using bio internals will need updates. This refactor supports the new :std/format framework's BufferedWriter/BufferedReader interfaces.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "net-address-module-v019",
    "title": "New network address abstractions in :std/net/address (v0.19)",
    "tags": [
      "network",
      "address",
      "inet",
      "resolver",
      "v0.19",
      "ip",
      "dns"
    ],
    "imports": [
      ":std/net/address"
    ],
    "code": ";; NEW in v0.19: Network address abstractions\n;; NOT AVAILABLE in v0.18.x\n\n;; Core modules:\n;;   :std/net/address/types    — Address type definitions\n;;   :std/net/address/inet     — Internet address (IPv4/IPv6)\n;;   :std/net/address/format   — Address formatting\n;;   :std/net/address/resolver — DNS resolution\n\n;; This provides higher-level abstractions over raw socket addresses.\n;; In v0.18.x, socket code used raw sockaddr structs directly.\n;; In v0.19+, :std/net/address provides typed address objects.\n\n;; Related OS-level modules (also new in v0.19):\n;;   :std/os/sockaddr  — OS-level sockaddr FFI\n;;   :std/os/sockopt   — Socket options FFI\n;;   :std/os/device    — Device/interface info\n;;   :std/os/file      — File operations\n;;   :std/os/time      — OS time FFI\n\n;; Socket modules also refactored:\n;;   :std/io/socket/client  — NEW: client connection helpers\n;;   :std/io/socket/types   — refactored type definitions\n;;   :std/io/socket/basic   — refactored basic operations\n\n;; NOTE: Full API examples will be added once v0.19 is compiled.\n;; This is part of a broader network stack refactor.",
    "notes": "The :std/net/address module is COMPLETELY NEW in v0.19 — it did not exist in v0.18.x. It provides higher-level network address abstractions (types, inet, format, resolver) to replace raw sockaddr manipulation. This is part of a broader v0.19 refactor of the network stack: new :std/os/sockaddr, :std/os/sockopt, :std/os/device, :std/os/file, :std/os/time modules for OS-level FFI, plus refactored :std/io/socket/* modules with a new :std/io/socket/client module. The goal is cleaner separation between OS FFI (:std/os/*), protocol abstractions (:std/net/address), and I/O operations (:std/io/socket/*). This brings the network stack closer to Go's net package organization.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "v019-migration-overview",
    "title": "Gerbil v0.19 migration guide: breaking changes and new modules",
    "tags": [
      "migration",
      "v0.19",
      "breaking-changes",
      "upgrade",
      "refactor",
      "new-modules"
    ],
    "imports": [],
    "code": ";; ============================================================================\n;; GERBIL v0.19 MIGRATION GUIDE\n;; ============================================================================\n\n;; BREAKING CHANGES — Code that MUST be updated:\n\n;; 1. List modules moved from :std/misc to :std/list\n;;    OLD: (import :std/misc/alist)\n;;    NEW: (import :std/list/alist)\n;;    Affected: alist, plist, list, list-builder, walist\n\n;; 2. Deprecated JSON aliases removed (in progress, not enforced yet)\n;;    Deprecated: json-symbolic-keys, json-sort-keys, json-list-wrapper\n;;    Use: read-json-key-as-symbol?, write-json-sort-keys? instead\n\n;; 3. JSON module relocation (deferred to later in v0.19 cycle)\n;;    FUTURE: :std/text/json → :std/encoding/json\n;;    CURRENT: Still use :std/text/json (compatibility shim exists)\n\n;; ============================================================================\n;; NEW MODULES — Features added in v0.19:\n\n;; :std/log               — Structured logging framework\n;;   Levels: CRITICAL/ERROR/WARN/INFO/DEBUG/VERBOSE\n;;   Features: timestamped records, metadata, sinks, log rotation\n;;   Config: GERBIL_LOG_LEVEL environment variable\n\n;; :std/time              — Time abstractions and timeout handling\n;;   Types: Time, ExactTime, InexactTime\n;;   Timeout: IOTimeout, AbsTimeout interface\n;;   NOTE: ExactTime (timeval/timespec FFI) is TODO\n\n;; :std/format            — Generic object formatting and serialization\n;;   Interfaces: ObjectWriter, ObjectReader, Stringer\n;;   Features: cycle detection, #N= anchors, display/debug styles\n;;   Integration: Used by :std/log and future :std/encoding/json\n\n;; :std/serde             — Serialization framework with cycle detection\n;;   Features: @serialize macro, scanner, interned/opaque objects\n;;   Purpose: Safe object graph traversal without infinite loops\n\n;; :std/test              — Enhanced unit testing framework\n;;   Structure: TestHarness → TestModule → TestSuite → TestCase\n;;   Features: configurable verbosity (0-7), output capture, structured results\n;;   NOTE: API changed from v0.18 (simpler check/test-suite model)\n\n;; :std/net/address       — Network address abstractions\n;;   Modules: types, inet, format, resolver\n;;   Purpose: Higher-level API over raw sockaddr\n\n;; :std/os/sockaddr       — OS-level socket address FFI\n;; :std/os/sockopt        — Socket options FFI\n;; :std/os/device         — Device/interface info\n;; :std/os/file           — File operations\n;; :std/os/time           — OS time FFI\n\n;; ============================================================================\n;; REFACTORED MODULES — Internal changes, API mostly compatible:\n\n;; :std/iter              — Split into submodules\n;;   Old: monolithic 926-line file\n;;   New: iter/api, iter/interface, iter/iterators, iter/macros\n;;   NEW iterators: in-range-inclusive, in-number-series, in-integers\n\n;; :std/io/bio            — Buffered I/O refactor\n;;   Split: reader.ss (563 lines), writer.ss (312 lines)\n;;   Added: buffer, cache, memory, message, srcsnk modules\n;;   Removed: chunked, inline modules\n;;   Deleted: entire :std/io/strio package (1223 lines)\n\n;; :std/io/socket         — Socket modules refactored\n;;   NEW: socket/client module\n;;   Refactored: types, basic, stream, datagram, server\n\n;; ============================================================================\n;; MODULES MOVED TO v0.19-TODO (deferred, may return later):\n\n;; Most of :std/os, :std/net/websocket, :std/parser, :std/protobuf,\n;; :std/pregexp, :std/text/*, :std/values, :std/source, :std/stxutil\n\n;; These modules exist in src/std/v0.19-TODO/ and are not yet compiled.\n;; They will be reintegrated after core refactoring is complete.",
    "notes": "Gerbil v0.19 is a MAJOR refactoring release with breaking changes and significant new features. The most critical breaking change is the list module migration (:std/misc/* → :std/list/*). New capabilities include structured logging (:std/log), time abstractions (:std/time), generic formatting (:std/format), serialization framework (:std/serde), enhanced testing (:std/test), and network address abstractions (:std/net/address). Many modules were refactored internally (iter, io/bio, io/socket) with mostly compatible public APIs. A large number of modules were temporarily moved to v0.19-TODO/ to focus on core infrastructure — they will be reintegrated in later v0.19 commits. The JSON refactor to :std/encoding/json is incomplete — continue using :std/text/json for now.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "v0-19-module-reorganization",
    "title": "v0.19 module reorganization: import path changes",
    "tags": [
      "v0.19",
      "import",
      "module",
      "reorganization",
      "migration",
      "breaking-change"
    ],
    "imports": [],
    "code": ";; BREAKING CHANGES in v0.19: Many modules moved from :std/misc to new packages\n\n;; === List utilities: :std/misc/X → :std/list/X ===\n;; OLD (v0.18):        NEW (v0.19):\n(import :std/misc/alist)      ;; → (import :std/list/alist)\n(import :std/misc/list)       ;; → (import :std/list/list)\n(import :std/misc/plist)      ;; → (import :std/list/plist)\n(import :std/misc/walist)     ;; → (import :std/list/walist)\n(import :std/misc/list-builder) ;; → (import :std/list/list-builder)\n\n;; === Synchronization: :std/misc/X → :std/sync/X ===\n(import :std/misc/barrier)    ;; → (import :std/sync/barrier)\n(import :std/misc/channel)    ;; → (import :std/sync/channel)\n(import :std/misc/completion) ;; → (import :std/sync/completion)\n(import :std/misc/rwlock)     ;; → (import :std/sync/rwlock)\n\n;; === String utilities: :std/misc/X → :std/string/X ===\n(import :std/misc/path)       ;; → (import :std/string/path)\n\n;; === Data structures: :std/misc/X → :std/struct/X ===\n(import :std/misc/queue)      ;; → (import :std/struct/queue)\n\n;; === JSON: :std/text/json → :std/encoding/json ===\n(import :std/text/json)       ;; → NO LONGER EXISTS\n;; The new JSON API is reorganized into submodules:\n;;   :std/encoding/json/io       - core JSONWriter/JSONReader interfaces\n;;   :std/encoding/json/reader   - parsing\n;;   :std/encoding/json/writer   - encoding\n;;   :std/encoding/json/env      - environment/config\n;; (Not yet fully available in v0.19-dev-test-basis)\n\n;; === Iterators: module split (backward compatible) ===\n(import :std/iter)  ;; Still works! Re-exports from submodules:\n;;   :std/iter/api       - main API (for, for/collect, in-range, etc.)\n;;   :std/iter/interface - iterator protocol\n;;   :std/iter/iterators - built-in iterators\n;;   :std/iter/macros    - for/for*/etc. macros\n\n;; === Format: NEW module hierarchy ===\n(import :std/format)  ;; NEW in v0.19: printf, fprintf, eprintf, format\n;;   :std/format/io       - core I/O\n;;   :std/format/string   - string formatting (to-string interface)\n;;   :std/format/reader   - parsing\n;;   :std/format/writer   - output\n;;   :std/format/env      - environment\n\n;; === REMOVED / MOVED TO v0.19-TODIE ===\n;; These modules are in src/std/v0.19-TODIE/ (scheduled for removal):\n;;   :std/srfi/1, :std/srfi/13, :std/srfi/19, :std/srfi/42, etc.\n;;   :std/generic/dispatch\n;;   :std/actor-v13/*\n;; Do NOT use these in new code - replacements TBD\n\n;; === NEW modules in v0.19 ===\n(import :std/object)          ;; Object utilities (defobject-cache)\n(import :std/ffi)             ;; FFI macrology (C-include, C-declare, etc.)\n(import :std/log)             ;; Logging framework (not yet compiled)\n(import :std/os/device)       ;; Device utilities\n(import :std/os/file)         ;; File operations\n(import :std/os/sockaddr)     ;; Socket address utilities\n(import :std/os/sockopt)      ;; Socket options\n(import :std/os/time)         ;; Time utilities\n(import :std/io/counter)      ;; I/O counter\n(import :std/io/socket/client) ;; Socket client\n(import :std/serde/interned)  ;; Serialization: interned objects\n(import :std/serde/opaque)    ;; Serialization: opaque objects",
    "notes": "CRITICAL MIGRATION GUIDE for v0.18 → v0.19. The v0.19 branch (v0.19-dev-test-basis) is NOT yet stable - many stdlib modules are still in v0.19-TODO/ and not compiled. This reorganization improves module hierarchy but requires import path updates. The :std/misc namespace was too broad and has been split into semantic packages: :std/list (list utilities), :std/sync (concurrency), :std/string (string manipulation), :std/struct (data structures). JSON moved from :std/text to :std/encoding with a new API. SRFIs are being removed - don't rely on them in new code. Use this as a reference when migrating v0.18 code or when encountering \"cannot find library module\" errors on v0.19.",
    "gerbil_version": "v0.19"
  },
  {
    "id": "make-will-struct-finalizer",
    "title": "Use make-will for Scheme-level struct GC finalizers",
    "tags": [
      "make-will",
      "finalizer",
      "GC",
      "cleanup",
      "struct",
      "resource",
      "memory",
      "leak"
    ],
    "imports": [],
    "code": ";; PATTERN: Wrap a foreign resource in a defstruct and register a\n;; will (weak finalizer) so GC automatically cleans up.\n;; Unlike c-define-type finalizers, this works at the Scheme level\n;; and can guard against double-free with a #f sentinel.\n\n;; 1. Define a wrapper struct\n(defstruct my-resource (handle) final: #t)\n\n;; 2. Define the cleanup function with double-free guard\n(def (my-resource-release! res)\n  (let ((h (my-resource-handle res)))\n    (when h\n      (foreign-release-the-handle h)  ;; your actual cleanup\n      (set! (my-resource-handle res) #f))))  ;; prevent double-free\n\n;; 3. Register a will at creation time\n(def (open-my-resource . args)\n  (let* ((raw-handle (ffi-create-resource args))\n         (res (make-my-resource raw-handle)))\n    (make-will res my-resource-release!)  ;; GC calls release!\n    res))\n\n;; Real example from gerbil-leveldb: snapshot wrapper\n;; The wrapper holds both the db reference (to keep it alive)\n;; and the raw snapshot pointer.\n;;\n;; (defstruct leveldb-snap (ldb ptr) final: #t)\n;;\n;; (def (leveldb-snapshot ldb)\n;;   (let* ((ptr (leveldb_create_snapshot (leveldb-db ldb)))\n;;          (snap (make-leveldb-snap ldb ptr)))\n;;     (make-will snap leveldb-snapshot-release!)\n;;     snap))\n;;\n;; (def (leveldb-snapshot-release! snap)\n;;   (let ((ptr (leveldb-snap-ptr snap)))\n;;     (when ptr\n;;       (let ((db (leveldb-db (leveldb-snap-ldb snap))))\n;;         (when db (leveldb_release_snapshot db ptr)))\n;;       (set! (leveldb-snap-ptr snap) #f))))\n\n;; KEY POINTS:\n;; - make-will registers a procedure called when the object becomes unreachable\n;; - The cleanup proc takes ONE argument: the object itself\n;; - Always check for #f before cleanup (will may fire after explicit release)\n;; - Hold references to parent objects in the struct to prevent premature GC\n;; - Works alongside explicit release: user can call release! manually,\n;;   and the will becomes a no-op thanks to the #f guard",
    "notes": "make-will is a Gambit builtin (no import needed). The will fires when the object becomes unreachable and GC runs. Unlike c-define-type finalizers which work at the C pointer level, make-will works on any Scheme object and gives you full Scheme-level control. Critical pattern for FFI wrappers where cleanup requires multiple C calls or depends on other Scheme objects being alive (e.g., releasing a snapshot requires both the db handle and snapshot pointer). The struct should hold references to all objects needed for cleanup to prevent them from being GC'd first.",
    "related": [
      "foreign-release-double-free",
      "force-gc-gambit",
      "gambit-ffi-pointer-types"
    ]
  },
  {
    "id": "u8vector-lexicographic-compare",
    "title": "Lexicographic comparison of u8vectors (bytes>=?)",
    "tags": [
      "u8vector",
      "bytes",
      "compare",
      "lexicographic",
      "ordering",
      "greater",
      "equal",
      "binary"
    ],
    "imports": [],
    "code": ";; Lexicographic comparison for u8vectors (byte arrays).\n;; Returns #t if a >= b in lexicographic (unsigned byte) order.\n;; Useful for range scans, key ordering, binary search bounds.\n\n(def (bytes>=? a b)\n  (let ((alen (u8vector-length a))\n        (blen (u8vector-length b)))\n    (let loop ((i 0))\n      (cond\n        ((>= i blen) #t)          ;; b exhausted: a >= b (a is longer or equal)\n        ((>= i alen) #f)          ;; a exhausted first: a < b\n        ((> (u8vector-ref a i)\n            (u8vector-ref b i)) #t)   ;; a[i] > b[i]: a > b\n        ((< (u8vector-ref a i)\n            (u8vector-ref b i)) #f)   ;; a[i] < b[i]: a < b\n        (else (loop (+ i 1)))))))     ;; equal so far, continue\n\n;; Examples:\n;; (bytes>=? #u8(1 2 3) #u8(1 2 3))   => #t  (equal)\n;; (bytes>=? #u8(1 2 4) #u8(1 2 3))   => #t  (greater)\n;; (bytes>=? #u8(1 2) #u8(1 2 3))     => #f  (prefix is less)\n;; (bytes>=? #u8(1 2 3) #u8(1 2))     => #t  (longer with same prefix)\n;; (bytes>=? #u8(2) #u8(1 9 9))       => #t  (first byte wins)\n\n;; For string keys, convert first:\n;; (bytes>=? (string->bytes \"key2\") (string->bytes \"key1\"))  => #t\n\n;; USE CASE: LevelDB range scan with exclusive upper bound\n;; Stop iteration when current key >= limit:\n;; (def (leveldb-iter-next iter limit)\n;;   (leveldb-iterator-next (leveldb-iter-itor iter))\n;;   (if (leveldb-iterator-valid? (leveldb-iter-itor iter))\n;;     (let ((key (leveldb-iterator-key (leveldb-iter-itor iter))))\n;;       (if (and limit (bytes>=? key limit))\n;;         iter-end    ;; past the limit\n;;         (values key (leveldb-iterator-value ...))))\n;;     iter-end))",
    "notes": "Standard equal? only checks exact match, not ordering. For range scans and ordered iteration (like LevelDB, B-trees, sorted indices), you need lexicographic comparison. This compares unsigned bytes left-to-right, with shorter prefixes sorting before longer ones (same as LevelDB's default byte comparator). GOTCHA: when using with optional start/limit parameters, always check for #f before calling bytes>=? — (bytes>=? #f limit) will crash since #f is not a u8vector.",
    "related": [
      "endian-aware-binary-access",
      "pass-u8vector-to-c"
    ]
  },
  {
    "id": "ffi-alloc-scmobj-failure-handling",
    "title": "Handle ___alloc_scmobj failure in FFI by returning ___FAL (#f)",
    "tags": [
      "ffi",
      "alloc",
      "scmobj",
      "OOM",
      "memory",
      "u8vector",
      "FAL",
      "false",
      "error-handling"
    ],
    "imports": [],
    "code": ";; PROBLEM: ___alloc_scmobj returns a fixnum error code on failure,\n;; NOT a proper Scheme object. If you return it directly to Scheme,\n;; the caller receives a fixnum instead of the expected type (e.g. u8vector),\n;; causing type errors or crashes.\n;;\n;; PATTERN: Check with ___FIXNUMP and return ___FAL (#f) on failure.\n;; Scheme callers then check for #f and return an appropriate error.\n\n;; In C (inside begin-ffi c-declare):\n;; ___SCMOBJ result = ___EXT(___alloc_scmobj)(___PSTATE, ___sU8VECTOR, len);\n;; if (___FIXNUMP(result)) {\n;;     ___return(___FAL);  // return #f to Scheme\n;; }\n;; memcpy(U8_DATA(result), src, len);\n;; ___return(result);\n\n;; In Scheme wrapper — check for #f before using:\n;; (def (wrap-write user-fn)\n;;   (lambda (path buf size offset fh)\n;;     (let (data (ffi-buffer-to-u8vector buf size))\n;;       (if (not data)          ;; #f means allocation failed\n;;         (- ENOMEM)            ;; return -ENOMEM to caller\n;;         (let (result (user-fn path data offset fh))\n;;           (if (fixnum? result) result (- EIO)))))))\n\n;; WRONG — returns fixnum error code directly:\n;; ___SCMOBJ result = ___EXT(___alloc_scmobj)(...);\n;; if (!___FIXNUMP(result)) { memcpy(...); }\n;; ___return(result);  // BUG: returns fixnum on OOM!\n\n;; CORRECT — converts to #f:\n;; if (___FIXNUMP(result)) { ___return(___FAL); }\n;; memcpy(U8_DATA(result), src, len);\n;; ___return(result);",
    "notes": "___alloc_scmobj is Gambit's low-level allocator for Scheme objects. On failure (OOM), it returns a fixnum error code — NOT #f or a tagged error. If you blindly return this to Scheme, callers expecting a u8vector/string will crash with type errors. The ___FAL constant is Gambit's internal representation of #f. Always use ___FIXNUMP() to detect failure. This pattern was discovered in gerbil-fuse where ffi-buffer-to-u8vector could return a fixnum on OOM, crashing user callbacks."
  },
  {
    "id": "ffi-posix-syscall-inline-errno",
    "title": "Wrap POSIX syscalls with inline C returning -errno on failure",
    "tags": [
      "ffi",
      "posix",
      "syscall",
      "errno",
      "access",
      "chmod",
      "inline-c",
      "c-lambda"
    ],
    "imports": [],
    "code": ";; PATTERN: Wrap POSIX syscalls via define-c-lambda with inline C\n;; that returns 0 on success or -errno on failure.\n;; This avoids needing a separate C shim file.\n\n;; Inside (begin-ffi (...) ...)\n;; Include required headers:\n;; (c-declare \"#include <unistd.h>\")\n;; (c-declare \"#include <sys/stat.h>\")\n;; (c-declare \"#include <errno.h>\")\n\n;; access() — check file permissions\n;; (define-c-lambda ffi-access (nonnull-UTF-8-string int) int\n;;   \"int r = access(___arg1, ___arg2); ___return(r == 0 ? 0 : -errno);\")\n\n;; chmod() — change file mode\n;; (define-c-lambda ffi-chmod (nonnull-UTF-8-string int) int\n;;   \"int r = chmod(___arg1, (mode_t)___arg2); ___return(r == 0 ? 0 : -errno);\")\n\n;; Constants for access():\n;; (define-const F_OK)  ;; existence check\n;; (define-const R_OK)  ;; read permission\n;; (define-const W_OK)  ;; write permission\n;; (define-const X_OK)  ;; execute permission\n\n;; Usage from Scheme:\n;; (ffi-access \"/tmp/test\" R_OK)  ;; => 0 or -13 (EACCES)\n;; (ffi-chmod \"/tmp/test\" #o644)  ;; => 0 or -1 (EPERM)\n\n;; IMPORTANT: Use nonnull-UTF-8-string (not char-string) for Unicode paths.\n;; Cast to appropriate C types (mode_t for chmod).\n;; Return -errno, not errno, so Scheme can check (< result 0) for errors.",
    "notes": "This pattern is ideal for simple POSIX syscalls that return 0/-1 and set errno. The inline C string avoids needing a separate .c file. Use ___arg1, ___arg2 etc. for positional args and ___return() for the return value. For syscalls that return data (like read()), you need a more complex C wrapper. Always use nonnull-UTF-8-string for paths to handle Unicode filenames. The -errno convention matches FUSE callback return conventions."
  },
  {
    "id": "ffi-scheme-object-u8vector-data",
    "title": "Pass u8vector data to C using scheme-object type with U8_DATA() macro",
    "tags": [
      "ffi",
      "scheme-object",
      "u8vector",
      "U8_DATA",
      "pointer",
      "memcpy",
      "c-lambda",
      "buffer"
    ],
    "imports": [],
    "code": ";; PROBLEM: You need to pass a u8vector's raw data to a C function.\n;; Using (pointer void) as the FFI type is WRONG — a u8vector is a\n;; Scheme object, not a C pointer.\n;;\n;; SOLUTION: Use scheme-object type and extract data with U8_DATA() macro.\n\n;; WRONG — type mismatch, crashes or corrupts:\n;; (define-c-lambda bad-copy! ((pointer void) size_t) void\n;;   \"memcpy(dest, ___arg1, ___arg2);\")\n;; (bad-copy! my-u8vector 10)  ;; BUG: passes object header, not data!\n\n;; CORRECT — use scheme-object + U8_DATA():\n;; (define-c-lambda ffi-xattr-set-result! (scheme-object size_t) int\n;;   \"___return(ffi_xattr_set_result((const char *)U8_DATA(___arg1), ___arg2));\")\n\n;; ALSO CORRECT — inline memcpy with scheme-object:\n;; (define-c-lambda ffi-copy-from-u8vec! (void* scheme-object int int) void\n;;   \"memcpy(___arg1, (char *)U8_DATA(___arg2) + ___arg3, ___arg4);\")\n\n;; U8_DATA macro extracts the raw byte pointer from a u8vector.\n;; It's defined as: #define U8_DATA(obj) ___CAST(___U8*, ___BODY_AS(obj, ___tSUBTYPED))\n\n;; For copying TO a u8vector (C buffer -> Scheme):\n;; Use ___alloc_scmobj to create, then memcpy into U8_DATA(result).\n;; See recipe: ffi-alloc-scmobj-failure-handling\n\n;; KEY RULES:\n;; 1. Never use (pointer void) for u8vector args — always scheme-object\n;; 2. Cast U8_DATA() result to appropriate C pointer type\n;; 3. The u8vector must remain live during the C call (GC safety)\n;; 4. For output buffers, allocate in C or pre-allocate in Scheme",
    "notes": "U8_DATA() is a Gambit macro that extracts the raw data pointer from a u8vector Scheme object. It works by skipping the object header to get to the actual byte array. The scheme-object FFI type passes the raw Scheme object handle to C without any conversion. CRITICAL: using (pointer void) for a u8vector is a type error — the C code receives the Scheme object address (including header), not the data bytes, causing memcpy to read/write the wrong memory. Discovered in gerbil-fuse where ffi-xattr-set-result! was declared with (pointer void) but called with u8vectors."
  },
  {
    "id": "ffi-c-buffer-overflow-error-return",
    "title": "Return error codes from C for buffer overflow instead of silent truncation",
    "tags": [
      "ffi",
      "buffer",
      "overflow",
      "truncation",
      "ENAMETOOLONG",
      "ERANGE",
      "error",
      "shim"
    ],
    "imports": [],
    "code": ";; PATTERN: When C functions copy data into fixed-size buffers,\n;; return an error code instead of silently truncating.\n\n;; WRONG — silent truncation (data loss!):\n;; void set_result(const char *data, size_t len) {\n;;     if (len > sizeof(buf)) len = sizeof(buf);  // silent truncation\n;;     memcpy(buf, data, len);\n;; }\n\n;; CORRECT — return error on overflow:\n;; int set_result(const char *data, size_t len) {\n;;     if (len > sizeof(buf))\n;;         return -ERANGE;  // or -ENAMETOOLONG for paths\n;;     memcpy(buf, data, len);\n;;     return 0;\n;; }\n\n;; Update FFI declaration to return int:\n;; (define-c-lambda ffi-set-result! (scheme-object size_t) int\n;;   \"___return(set_result((const char *)U8_DATA(___arg1), ___arg2));\")\n\n;; Scheme wrapper checks and propagates the error:\n;; (let (rc (ffi-set-result! data len))\n;;   (if (< rc 0) rc len))  ;; return -ERANGE or data length\n\n;; CONVENTIONS:\n;; -ERANGE    — generic buffer too small (xattr, statvfs)\n;; -ENAMETOOLONG — path/name too long (readlink, symlink)\n;; -E2BIG     — argument list too long\n;; -EOVERFLOW — value too large for data type",
    "notes": "Silent truncation in C shim functions is a common source of data corruption bugs. When data exceeds a fixed buffer, always return a negative errno value. The Scheme wrapper must check (< rc 0) before using the result. This pattern was applied in gerbil-fuse to fix silent truncation in readlink (4KB buffer) and xattr (64KB buffer) shim functions. Change the FFI return type from void to int, and update all callers to check the return value."
  },
  {
    "id": "fuse-unmount-safe-open-process",
    "title": "Safe command execution with open-process to avoid shell injection",
    "tags": [
      "security",
      "shell",
      "injection",
      "open-process",
      "command",
      "safe",
      "umount",
      "fusermount"
    ],
    "imports": [],
    "code": ";; PROBLEM: Using ##shell-command or (shell-command) with string concatenation\n;; allows shell injection. The string is passed to /bin/sh -c, so\n;; metacharacters (;, |, $, `, etc.) are interpreted.\n;;\n;; WRONG — shell injection vulnerability:\n;; (def (unmount mp)\n;;   (##shell-command (string-append \"umount \" mp)))\n;; ;; (unmount \"/tmp/foo; rm -rf /\")  => executes rm -rf /\n\n;; CORRECT — use open-process with explicit argv (no shell):\n(def (unmount mountpoint)\n  (let* ((on-mac? (equal? (cadr (system-type)) 'apple))\n         (cmd (if on-mac? \"/sbin/umount\" \"/usr/bin/fusermount3\"))\n         (args (if on-mac?\n                 [mountpoint]\n                 [\"-u\" mountpoint]))\n         (proc (open-process [path: cmd\n                              arguments: args\n                              stdout-redirection: #f\n                              stderr-redirection: #f])))\n    (process-status proc)))\n\n;; KEY POINTS:\n;; 1. open-process with path: + arguments: bypasses the shell entirely\n;; 2. Each argument is passed as a separate argv entry — no interpretation\n;; 3. Metacharacters in mountpoint are treated as literal characters\n;; 4. stdout-redirection: #f and stderr-redirection: #f let output\n;;    pass through to the terminal (or use #t to capture)\n;; 5. process-status waits for completion and returns exit code\n;;\n;; PLATFORM DETECTION:\n;; (cadr (system-type)) returns:\n;;   'apple on macOS\n;;   'linux-gnu on Linux\n;; Use this to choose the right unmount command.",
    "notes": "This is a critical security pattern. NEVER use ##shell-command or (shell-command) with user-controlled input. Always use open-process with separate path: and arguments: keywords. The arguments list is passed directly to execv() — no shell interpretation occurs. This pattern was applied to fix a command injection vulnerability in gerbil-fuse's fuse-unmount function where mountpoint was concatenated into a shell command. Also note: (cadr (system-type)) is the portable way to detect the OS in Gerbil/Gambit — software-type doesn't exist."
  },
  {
    "id": "ffi-initialize-return-check",
    "title": "Check FFI initialization function return values (void→int fix)",
    "tags": [
      "ffi",
      "initialize",
      "return",
      "check",
      "void",
      "int",
      "error",
      "libyaml",
      "yaml_parser_initialize"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": ";; PROBLEM: Many C library init functions return int (1=success, 0=failure)\n;; but FFI bindings often declare them as void, silently ignoring failures.\n;;\n;; Example: libyaml's yaml_parser_initialize returns int, not void.\n;;\n;; WRONG — in .scm FFI file:\n;; (define-c-lambda yaml_parser_initialize (yaml_parser_t*) void\n;;   \"yaml_parser_initialize\")\n;;\n;; CORRECT — return int so Scheme can check:\n;; (define-c-lambda yaml_parser_initialize (yaml_parser_t*) int\n;;   \"yaml_parser_initialize\")\n;;\n;; Then in the Scheme caller, check the return value:\n(def (yaml-parse-input file parser-set-input!)\n  (let* ((parser (make_yaml_parser))\n         (r      (yaml_parser_initialize parser))\n         (_      (when (zero? r)\n                   (error \"Failed to initialize YAML parser\")))\n         (_      (parser-set-input! parser file))\n         (event  (make_yaml_event)))\n    (try (yaml-parse parser event)\n      (finally (yaml_parser_delete parser)))))\n\n;; PATTERN: For any C function that returns 0=failure, 1=success:\n;; 1. Declare return type as int in define-c-lambda (not void)\n;; 2. Check (zero? r) in let* binding and raise error on failure",
    "notes": "Common C libraries affected: libyaml (yaml_parser_initialize, yaml_emitter_initialize), libxml2, sqlite3. The C convention is typically 0=failure, 1=success (opposite of Unix exit codes). Always check the C header to verify the actual return type before declaring void in FFI bindings."
  },
  {
    "id": "yaml-octal-1.1-1.2-compat",
    "title": "Parse YAML octal values for both 1.1 (0777) and 1.2 (0o777) formats",
    "tags": [
      "yaml",
      "octal",
      "parse",
      "regex",
      "yaml-1.1",
      "yaml-1.2",
      "pregexp"
    ],
    "imports": [
      ":std/pregexp"
    ],
    "code": ";; YAML 1.1 uses 0777 for octal, YAML 1.2 uses 0o777.\n;; A compatible parser should accept both formats.\n\n;; Regex matches both: 0o? makes the 'o' optional\n(def rx-scalar-octal\n  (pregexp \"^0o?[0-7]+$\"))\n\n;; When parsing, dynamically determine the prefix length to skip:\n(def (parse-yaml-octal str)\n  (let (skip (if (eqv? (string-ref str 1) #\\o) 2 1))\n    (string->number (substring str skip (string-length str)) 8)))\n\n;; Examples:\n;; (pregexp-match rx-scalar-octal \"0o777\")  => (\"0o777\")  ; YAML 1.2\n;; (pregexp-match rx-scalar-octal \"0777\")   => (\"0777\")   ; YAML 1.1\n;; (parse-yaml-octal \"0o777\")              => 511\n;; (parse-yaml-octal \"0777\")               => 511",
    "notes": "YAML 1.1 (used by PyYAML, many Ruby tools) uses C-style 0777. YAML 1.2 (the current spec) uses 0o777 like Python 3. When implementing a YAML parser, support both for maximum compatibility. The key insight is using `0o?` in the regex and checking `(string-ref str 1)` to determine the skip length at parse time."
  },
  {
    "id": "ffi-event-delete-leak-prevention",
    "title": "Always call event_delete on FFI event structs before discarding",
    "tags": [
      "ffi",
      "event",
      "delete",
      "memory",
      "leak",
      "libyaml",
      "yaml_event_delete",
      "resource"
    ],
    "imports": [],
    "code": ";; PROBLEM: C libraries that use event structs (libyaml, libxml2, etc.)\n;; often allocate internal data (strings, buffers) inside the event.\n;; You must call the delete/free function for EVERY event that contains\n;; allocated data, not just some branches.\n;;\n;; WRONG — leaks event data for STREAM_END and DOCUMENT_END:\n;; (cond\n;;   ((eq? t YAML_STREAM_END_EVENT))          ;; LEAK! no delete\n;;   ((eq? t YAML_DOCUMENT_START_EVENT)\n;;    (yaml_event_delete event)                ;; OK\n;;    (process-document))\n;;   ((eq? t YAML_DOCUMENT_END_EVENT)          ;; LEAK! no delete\n;;    (lp))\n;;   ((eq? t YAML_NO_EVENT)                    ;; OK — no data allocated\n;;    (lp)))\n;;\n;; CORRECT — delete before every branch that discards the event:\n;; (cond\n;;   ((eq? t YAML_STREAM_END_EVENT)\n;;    (yaml_event_delete event))               ;; FIXED\n;;   ((eq? t YAML_DOCUMENT_START_EVENT)\n;;    (yaml_event_delete event)\n;;    (process-document))\n;;   ((eq? t YAML_DOCUMENT_END_EVENT)\n;;    (yaml_event_delete event)                ;; FIXED\n;;    (lp))\n;;   ((eq? t YAML_NO_EVENT)\n;;    (lp)))                                   ;; OK — NO_EVENT has no data\n;;\n;; RULE OF THUMB:\n;; - Call event_delete for every event type EXCEPT NO_EVENT\n;; - NO_EVENT means the parser returned without producing an event\n;; - All other event types may have internal allocations\n;; - This includes \"simple\" events like STREAM_END, DOCUMENT_END,\n;;   SEQUENCE_END, MAPPING_END — even if they carry no user-visible data",
    "notes": "This pattern applies to any C library with event/message structs: libyaml (yaml_event_delete), libxml2 SAX (xmlFreeNode), libevent, etc. The bug is insidious because the leak only manifests under sustained parsing of many documents. The NO_EVENT case genuinely does not need deletion because it means the parser had nothing to report (polling scenario)."
  },
  {
    "id": "hash-table-equal-test-normalize",
    "title": "Compare hash tables in tests by normalizing to sorted alists",
    "tags": [
      "hash",
      "table",
      "equal",
      "compare",
      "test",
      "normalize",
      "alist",
      "sort"
    ],
    "imports": [
      ":std/sort"
    ],
    "code": ";; PROBLEM: Hash tables do NOT compare with equal? in Gerbil:\n;; (equal? (hash (\"a\" 1)) (hash (\"a\" 1)))  => #f\n;;\n;; This means (check (some-fn) => (hash (\"a\" 1))) ALWAYS FAILS\n;; in :std/test, even when the values match.\n;;\n;; SOLUTION: Recursively normalize values, converting hash tables\n;; to sorted alists. Then use check ... => ... on normalized values.\n\n(import :std/sort)\n\n(def (normalize val)\n  (cond\n   ((hash-table? val)\n    (sort (map (lambda (p) (cons (normalize (car p)) (normalize (cdr p))))\n               (hash->list val))\n          (lambda (a b) (string<? (object->string (car a))\n                                  (object->string (car b))))))\n   ((list? val)\n    (map normalize val))\n   (else val)))\n\n;; Usage in tests:\n;; (check (normalize (hash (\"b\" 2) (\"a\" 1)))\n;;        => '((\"a\" . 1) (\"b\" . 2)))\n;;\n;; For functions that return hash tables:\n;; (check (normalize (my-fn input))\n;;        => '((\"key1\" . \"val1\") (\"key2\" . \"val2\")))\n;;\n;; For nested structures (list of hash tables):\n;; (check (normalize (list (hash (\"x\" 1)) (hash (\"y\" 2))))\n;;        => '(((\"x\" . 1)) ((\"y\" . 2))))",
    "notes": "This is essential for testing ANY function that returns hash tables. The normalize function handles nested structures recursively: hash tables inside lists, hash tables inside hash tables, etc. Keys are sorted by (object->string key) so it works with string, symbol, and keyword keys. Note that a hash table with a list value like (\"items\" . (1 2 3)) becomes (\"items\" 1 2 3) in alist form since (cons \"items\" (1 2 3)) = (\"items\" 1 2 3).",
    "related": [
      "write-tests-with-std-test",
      "hash-table-basics"
    ]
  },
  {
    "id": "yaml-round-trip-test-pattern",
    "title": "Round-trip test pattern for yaml-dump and yaml-load",
    "tags": [
      "yaml",
      "dump",
      "load",
      "round-trip",
      "test",
      "temporary",
      "file"
    ],
    "imports": [
      ":std/os/temporaries",
      ":clan/text/yaml"
    ],
    "code": ";; yaml-dump writes to a file, yaml-load reads from a file.\n;; Round-trip testing requires a temporary file.\n;;\n;; yaml-load-string parses a string and returns a LIST of documents.\n;; yaml-dump takes a filename and REST args, each arg = one document.\n\n(import :std/os/temporaries :clan/text/yaml)\n\n;; Round-trip helper: dump objects, load back\n(def (round-trip . objs)\n  (call-with-temporary-file-name \"yaml-rt\"\n    (lambda (tmp)\n      (apply yaml-dump tmp objs)\n      (yaml-load tmp))))\n\n;; Examples:\n(round-trip \"hello\")           ;; => (\"hello\")\n(round-trip 42)                ;; => (42)\n(round-trip #t #f)             ;; => (#t #f)\n(round-trip '(1 2 3))          ;; => ((1 2 3))\n(round-trip (hash (\"a\" 1)))    ;; => (#&lt;HashTable&gt;)\n\n;; Multiple documents:\n(round-trip \"doc1\" \"doc2\")     ;; => (\"doc1\" \"doc2\")\n\n;; Symbols dump as strings:\n(round-trip 'my-sym)           ;; => (\"my-sym\")\n\n;; Vectors dump as lists:\n(round-trip #(1 2 3))          ;; => ((1 2 3))\n\n;; void/null round-trips:\n(void? (car (round-trip (void)))) ;; => #t\n\n;; NaN requires special check (NaN != NaN):\n(nan? (car (round-trip +nan.0)))  ;; => #t",
    "notes": "yaml-load-string and yaml-load both return a LIST of documents, even for single-document YAML. Always use (car result) to get the first document. yaml-dump takes rest args where each arg becomes a separate YAML document. call-with-temporary-file-name from :std/os/temporaries handles cleanup automatically. NaN cannot be compared with equal? so use (nan? ...) instead. Hash table results need the normalize pattern (see hash-table-equal-test-normalize recipe).",
    "related": [
      "hash-table-equal-test-normalize",
      "write-tests-with-std-test"
    ]
  },
  {
    "id": "path-normalize-throws-nonexistent",
    "title": "Gambit path-normalize throws for non-existent files",
    "tags": [
      "path",
      "normalize",
      "error",
      "file",
      "nonexistent",
      "exception"
    ],
    "imports": [],
    "code": ";; GOTCHA: Gambit's path-normalize throws an exception for\n;; non-existent paths, unlike most path utilities in other languages.\n;;\n;; (path-normalize \"/nonexistent/file.yaml\")\n;; => ERROR: No such file or directory\n;;\n;; This means any function that calls path-normalize on user input\n;; will throw BEFORE your own error handling runs.\n;;\n;; Example from yaml-load:\n;; (def (yaml-load fname)\n;;   (cond\n;;    ((open_yaml_input_file (path-normalize fname))  ;; throws HERE\n;;     => ...)\n;;    (else\n;;     (error \"Cannot open yaml input file\" fname)))) ;; never reached\n;;\n;; The error raised is a no-such-file-or-directory-exception,\n;; NOT a Gerbil Error. It's wrapped in a RuntimeException.\n;;\n;; To handle it:\n(try (path-normalize \"/nonexistent/path\")\n  (catch (e) (displayln \"caught\")))",
    "notes": "This is important for testing error cases: if you expect (error \"Cannot open...\") from your yaml-load function, you'll actually get a no-such-file-or-directory-exception from path-normalize instead. The exception is a Gambit exception wrapped in RuntimeException, not a Gerbil Error, so error-message returns #f. Use display-exception or with-output-to-string + display-exception to get the message.",
    "related": [
      "error-handling",
      "error-message-returns-false"
    ]
  }
]
