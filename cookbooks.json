[
  {
    "id": "crypto-digest-sha256-md5",
    "title": "Compute SHA256 or MD5 hash of data",
    "tags": [
      "sha256",
      "md5",
      "hash",
      "digest",
      "crypto",
      "checksum",
      "bytes"
    ],
    "imports": [
      ":std/crypto/digest"
    ],
    "code": "(import :std/crypto/digest)\\n\\n;; SHA256 of a u8vector — returns u8vector\\n(def hash256 (sha256 #u8(104 101 108 108 111)))\\n\\n;; SHA256 of a string (convert to bytes first)\\n(def hash256-str (sha256 (string->bytes \\\"hello\\\")))\\n\\n;; MD5 of bytes — returns u8vector\\n(def hash-md5 (md5 (string->bytes \\\"hello\\\")))\\n\\n;; To get hex string, combine with :std/text/hex\\n(import :std/text/hex)\\n(hex-encode (sha256 (string->bytes \\\"hello\\\")))\\n;; => \\\"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824\\\"",
    "notes": "sha256 and md5 each take a single u8vector argument and return a u8vector. Other available digests: sha1, sha384, sha512, ripemd160, blake2s256, blake2b512. All from :std/crypto/digest.",
    "related": [
      "base64-encode-decode"
    ]
  },
  {
    "id": "base64-encode-decode",
    "title": "Base64 encode and decode data",
    "tags": [
      "base64",
      "encode",
      "decode",
      "bytes",
      "string",
      "u8vector",
      "binary"
    ],
    "imports": [
      ":std/text/base64"
    ],
    "code": "(import :std/text/base64)\\n\\n;; Encode u8vector to base64 string\\n(u8vector->base64-string (string->bytes \\\"hello\\\"))\\n;; => \\\"aGVsbG8=\\\"\\n\\n;; Decode base64 string to u8vector\\n(base64-string->u8vector \\\"aGVsbG8=\\\")\\n;; => #u8(104 101 108 108 111)\\n\\n;; Encode/decode raw strings\\n(base64-encode \\\"hello\\\")\\n;; => \\\"aGVsbG8=\\\"\\n(base64-decode \\\"aGVsbG8=\\\")\\n;; => \\\"hello\\\"",
    "notes": "u8vector->base64-string and base64-string->u8vector work with binary data. base64-encode and base64-decode work with strings. Useful for HTTP headers like Content-MD5 which require base64-encoded digests.",
    "related": [
      "crypto-digest-sha256-md5"
    ]
  },
  {
    "id": "deferror-class-defraise",
    "title": "Define error class with deferror-class and defraise/context",
    "tags": [
      "error",
      "exception",
      "deferror",
      "defraise",
      "custom",
      "raise",
      "class",
      "context"
    ],
    "imports": [
      ":std/error"
    ],
    "code": "(import :std/error)\\n\\n;; Define an error class (creates predicate automatically)\\n(deferror-class (MyServiceError Error) () my-service-error?)\\n\\n;; Define a raise helper with automatic 'where' context\\n(defraise/context (raise-my-error where message irritants ...)\\n  (MyServiceError message irritants: [irritants ...]))\\n\\n;; Usage — 'where' is automatically set to the calling function name\\n(def (connect host port)\\n  (unless host\\n    (raise-my-error connect \\\"host is required\\\" \\\"host\\\"))\\n  ...)\\n\\n;; Catch it\\n(try (connect #f 80)\\n  (catch (my-service-error? e)\\n    (displayln \\\"Service error: \\\" (error-message e))))",
    "notes": "deferror-class is more concise than defstruct for error types — it automatically inherits Error fields (message, irritants, where). defraise/context auto-fills the 'where' field. The first arg to defraise/context after 'where' becomes the error message, rest become irritants.",
    "related": [
      "error-handling"
    ]
  },
  {
    "id": "cli-getopt-subcommands",
    "title": "Build CLI with getopt (v0.19+ API)",
    "tags": [
      "getopt",
      "CLI",
      "command",
      "option",
      "flag",
      "argument",
      "subcommand"
    ],
    "imports": [
      ":std/cli/getopt",
      ":std/sugar"
    ],
    "code": "(import :std/cli/getopt :std/sugar)\n\n;; Simple CLI with options (no subcommands) — handler takes ONE arg:\n(def (main . args)\n  (call-with-getopt\n    (lambda (opt)\n      (let-hash opt\n        (when .?verbose (displayln \"verbose mode\"))\n        (displayln \"output: \" (or .?output \"default.txt\"))))\n    args\n    program: \"my-tool\"\n    help: \"My CLI tool\"\n    (flag 'verbose \"--verbose\" \"-v\"\n      help: \"Verbose output\")\n    (option 'output \"--output\" \"-o\"\n      help: \"Output file\"\n      default: #f)))\n\n;; CLI with subcommands — handler takes TWO args (cmd opt):\n(def list-cmd\n  (command 'list\n    help: \"List items\"\n    (option 'filter \"--filter\" \"-f\" default: #f help: \"Filter\")))\n\n(def create-cmd\n  (command 'create\n    help: \"Create an item\"\n    (argument 'name help: \"Item name\")))\n\n(def (main . args)\n  (call-with-getopt\n    (lambda (cmd opt)\n      (case cmd\n        ((list)\n         (let-hash opt\n           (displayln \"listing with filter: \" .?filter)))\n        ((create)\n         (let-hash opt\n           (displayln \"creating: \" .name)))))\n    args\n    program: \"my-tool\"\n    help: \"My CLI tool\"\n    list-cmd create-cmd))",
    "notes": "IMPORTANT: In Gerbil v0.19+, call-with-getopt handler signature DIFFERS based on whether subcommands are used. WITHOUT subcommands: handler takes ONE arg (lambda (opt) ...). WITH subcommands (command forms): handler takes TWO args (lambda (cmd opt) ...) where cmd is the command symbol and opt is the options hash. Using (lambda (opt) ...) with subcommands causes \"Wrong number of arguments\" error. For exe builds, the main module MUST have (export main).",
    "related": [
      "let-hash-destructure",
      "getopt-subcommand-handler-two-args"
    ]
  },
  {
    "id": "srfi19-date-time-format",
    "title": "Date/time formatting with SRFI-19",
    "tags": [
      "date",
      "time",
      "srfi",
      "srfi-19",
      "format",
      "timestamp",
      "iso8601",
      "utc",
      "current"
    ],
    "imports": [
      ":std/srfi/19"
    ],
    "code": "(import :std/srfi/19)\\n\\n;; Current date/time (UTC)\\n(def now (current-date))\\n\\n;; Format as ISO 8601 timestamp\\n(date->string now \\\"~Y~m~dT~H~M~SZ\\\")\\n;; => \\\"20250115T143052Z\\\"\\n\\n;; Format date portion only\\n(date->string now \\\"~Y~m~d\\\")\\n;; => \\\"20250115\\\"\\n\\n;; Format human-readable\\n(date->string now \\\"~Y-~m-~d ~H:~M:~S\\\")\\n;; => \\\"2025-01-15 14:30:52\\\"\\n\\n;; Common format directives:\\n;;   ~Y  4-digit year    ~m  2-digit month   ~d  2-digit day\\n;;   ~H  24-hour hour    ~M  minute          ~S  second\\n;;   ~Z  timezone offset  ~A  weekday name    ~B  month name",
    "notes": "current-date returns UTC. date->string uses SRFI-19 format directives (tilde-based, not strftime). Commonly needed for AWS signature timestamps (yyyyMMddTHHmmssZ format) and date-scoped signing keys (yyyyMMdd)."
  },
  {
    "id": "xml-parse-sxml",
    "title": "Parse XML string to SXML",
    "tags": [
      "xml",
      "parse",
      "sxml",
      "markup",
      "html",
      "response",
      "api"
    ],
    "imports": [
      ":std/markup/xml"
    ],
    "code": "(import :std/markup/xml)\\n\\n;; Parse XML string to SXML tree\\n(def sxml\\n  (call-with-input-string\\n    \\\"<root><item>hello</item><item>world</item></root>\\\"\\n    read-xml))\\n;; => (*TOP* (root (item \\\"hello\\\") (item \\\"world\\\")))\\n\\n;; GOTCHA: XML with <?xml ...?> declaration produces a *PI* node\\n(def sxml-with-pi\\n  (call-with-input-string\\n    \\\"<?xml version=\\\\\\\"1.0\\\\\\\" encoding=\\\\\\\"UTF-8\\\\\\\"?><root><item>hello</item></root>\\\"\\n    read-xml))\\n;; => (*TOP* (*PI* xml \\\"version=...\\\") (root (item \\\"hello\\\")))\\n;; Note the *PI* node — you must skip it when searching for the root element!\\n\\n;; Navigate SXML — it's just nested lists\\n;; (tag child1 child2 ...) where children are strings or nested tags\\n(def root (cadr sxml))    ;; skip *TOP*, get (root ...)\\n(def items (cdr root))    ;; get children: ((item \\\"hello\\\") (item \\\"world\\\"))\\n(def first-text (cadar items))  ;; => \\\"hello\\\"",
    "notes": "read-xml from :std/markup/xml returns SXML (S-expression XML). It takes a single port argument. The result is always wrapped in (*TOP* ...). IMPORTANT: When the XML source has a <?xml ...?> processing instruction, a (*PI* xml ...) node appears in the SXML tree — you must skip it (along with @ and *NAMESPACES*) when traversing to find the root element, or it will be mistaken for the content root. See the sxml-skip-pi-nodes recipe for a correct traversal pattern. Use cadr to skip *TOP*, then navigate with car/cdr/assoc.",
    "related": [
      "sxml-skip-pi-nodes"
    ]
  },
  {
    "id": "using-typed-struct-access",
    "title": "Typed struct field access with using macro",
    "tags": [
      "using",
      "struct",
      "typed",
      "access",
      "field",
      "slot",
      "dot",
      "optimize",
      "defstruct"
    ],
    "imports": [],
    "code": "(defstruct point (x y) final: #t)\\n(defstruct (point3d point) (z) final: #t)\\n\\n;; using gives typed access — dot notation without dynamic dispatch\\n(def (distance p1 p2)\\n  (using ((p1 :- point) (p2 :- point))\\n    (sqrt (+ (expt (- p1.x p2.x) 2)\\n             (expt (- p1.y p2.y) 2)))))\\n\\n(distance (make-point 0 0) (make-point 3 4))  ;; => 5.0\\n\\n;; Single binding form\\n(def (describe-point p)\\n  (using (p :- point)\\n    (format \\\"(~a, ~a)\\\" p.x p.y)))\\n\\n;; Works with mutation too\\n(def (move-point! p dx dy)\\n  (using (p :- point)\\n    (set! p.x (+ p.x dx))\\n    (set! p.y (+ p.y dy))))",
    "notes": "using provides typed struct access that compiles to direct field access (no hash-table lookup). Use with defstruct types. The :- annotation is a type declaration. Pair with final: #t on defstruct for best optimization. Unlike (@ obj slot), using is compile-time checked."
  },
  {
    "id": "let-hash-destructure",
    "title": "Destructure hash tables with let-hash",
    "tags": [
      "let-hash",
      "hash",
      "destructure",
      "sugar",
      "optional",
      "field",
      "config",
      "options"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": "(import :std/sugar)\\n\\n(def config (hash (name \\\"app\\\") (port 8080) (debug #f)))\\n\\n(let-hash config\\n  ;; .field — required (hash-ref with symbol key, error if missing)\\n  (displayln \\\"name: \\\" .name)\\n\\n  ;; .?field — optional (hash-get, returns #f if missing)\\n  (when .?debug\\n    (displayln \\\"debug mode\\\"))\\n\\n  ;; Use .?field with defaults via 'or'\\n  (def timeout (or .?timeout 30))\\n  (displayln \\\"port: \\\" .port \\\" timeout: \\\" timeout))\\n\\n;; With string keys, use .$field\\n(def headers (hash (\\\"Content-Type\\\" \\\"text/html\\\") (\\\"X-Custom\\\" \\\"val\\\")))\\n(let-hash headers\\n  (displayln .$Content-Type))  ;; uses string key \\\"Content-Type\\\"",
    "notes": "let-hash is from :std/sugar. Three accessor forms: .field (symbol key, required — errors if missing), .?field (symbol key, optional — returns #f), .$field (string key, optional). Very useful for CLI option hashes from getopt and API response hashes. Nests well — (let-hash outer (let-hash .inner-hash ...)).",
    "related": [
      "cli-getopt-subcommands"
    ]
  },
  {
    "id": "parse-ini-file",
    "title": "Parse INI/config file into nested hash tables",
    "tags": [
      "ini",
      "config",
      "parse",
      "file",
      "section",
      "profile",
      "aws",
      "credentials",
      "settings"
    ],
    "imports": [
      ":std/sugar",
      ":std/srfi/13"
    ],
    "code": "(import :std/sugar (only-in :std/srfi/13 string-trim-both string-prefix? string-index))\\n\\n;; Parse INI file into hash of sections, each section is a hash of key=value\\n(def (parse-ini-file path)\\n  (let ((result (make-hash-table))\\n        (current-section #f))\\n    (when (file-exists? path)\\n      (call-with-input-file path\\n        (lambda (port)\\n          (let loop ()\\n            (let (line (read-line port))\\n              (unless (eof-object? line)\\n                (let (trimmed (string-trim-both line))\\n                  (cond\\n                    ((or (equal? trimmed \\\"\\\") (string-prefix? \\\"#\\\" trimmed)\\n                         (string-prefix? \\\";\\\" trimmed))\\n                     (void))  ;; skip blank/comment lines\\n                    ((and (string-prefix? \\\"[\\\" trimmed))\\n                     (let (end (string-index trimmed #\\\\]))\\n                       (when end\\n                         (set! current-section (substring trimmed 1 end))\\n                         (unless (hash-key? result current-section)\\n                           (hash-put! result current-section (make-hash-table))))))\\n                    (else\\n                     (when current-section\\n                       (let (eq-pos (string-index trimmed #\\\\=))\\n                         (when eq-pos\\n                           (let ((key (string-trim-both (substring trimmed 0 eq-pos)))\\n                                 (val (string-trim-both (substring trimmed (+ eq-pos 1)\\n                                                          (string-length trimmed)))))\\n                             (hash-put! (hash-ref result current-section) key val))))))))\\n                (loop)))))))\\n    result))\\n\\n;; Usage:\\n;; (def config (parse-ini-file \\\"~/.aws/credentials\\\"))\\n;; (hash-ref (hash-ref config \\\"default\\\") \\\"aws_access_key_id\\\")",
    "notes": "Handles [section] headers, key=value pairs, blank lines, and # or ; comments. Returns a hash of hashes: outer keys are section names, inner keys are setting names. Useful for parsing AWS credentials/config files, .gitconfig, and similar INI-style configs. Uses string-trim-both and string-index from :std/srfi/13."
  },
  {
    "id": "http-post-form-encoded",
    "title": "HTTP POST with form-url-encoded body",
    "tags": [
      "http",
      "post",
      "form",
      "urlencoded",
      "uri",
      "encode",
      "request",
      "api",
      "query"
    ],
    "imports": [
      ":std/net/request",
      ":std/net/uri"
    ],
    "code": "(import :std/net/request :std/net/uri)\\n\\n;; Build form-encoded body from alist of (key . value) pairs\\n(def params '((\\\"Action\\\" . \\\"DescribeInstances\\\")\\n              (\\\"Version\\\" . \\\"2016-11-15\\\")\\n              (\\\"MaxResults\\\" . \\\"10\\\")))\\n\\n(def body (form-url-encode params))\\n;; => \\\"Action=DescribeInstances&Version=2016-11-15&MaxResults=10\\\"\\n\\n;; POST with form-encoded body\\n(def resp (http-post \\\"https://api.example.com/\\\"\\n            data: body\\n            headers: '((\\\"Content-Type\\\" . \\\"application/x-www-form-urlencoded\\\"))))\\n\\n(request-status resp)   ;; HTTP status code\\n(request-text resp)     ;; response body as string\\n(request-close resp)    ;; release connection",
    "notes": "form-url-encode from :std/net/uri takes an alist of (key . value) string pairs and produces a URL-encoded query string. This is the standard format for AWS Query API services (EC2, STS, IAM, SNS, CloudFormation). Always call request-close after reading the response to release the connection.",
    "related": [
      "http-get",
      "http-post-json"
    ]
  },
  {
    "id": "sigv4-aws-request-signing",
    "title": "AWS SigV4 request signing",
    "tags": [
      "aws",
      "sigv4",
      "signing",
      "signature",
      "authentication",
      "s3",
      "ec2",
      "request",
      "api"
    ],
    "imports": [
      ":std/net/s3/sigv4",
      ":std/crypto/digest",
      ":std/text/hex",
      ":std/srfi/19",
      ":std/net/request"
    ],
    "code": "(import :std/net/s3/sigv4 :std/crypto/digest :std/text/hex\\n        :std/srfi/19 :std/net/request)\\n\\n;; Prepare timestamp and scope\\n(def now (current-date))\\n(def ts (date->string now \\\"~Y~m~dT~H~M~SZ\\\"))     ;; e.g. \\\"20250115T143052Z\\\"\\n(def scopets (date->string now \\\"~Y~m~d\\\"))           ;; e.g. \\\"20250115\\\"\\n(def scope (string-append scopets \\\"/us-east-1/sts\\\")) ;; date/region/service\\n\\n;; Build headers list as alist with :: syntax\\n(def body-bytes (string->bytes \\\"Action=GetCallerIdentity&Version=2011-06-15\\\"))\\n(def body-hash (sha256 body-bytes))\\n(def host \\\"sts.amazonaws.com\\\")\\n(def headers [[\\\"Host\\\" :: host]\\n              [\\\"x-amz-date\\\" :: ts]\\n              [\\\"Content-Type\\\" :: \\\"application/x-www-form-urlencoded\\\"]])\\n\\n;; Create canonical request\\n(def creq (aws4-canonical-request\\n             verb: 'POST uri: \\\"/\\\" query: #f\\n             headers: headers hash: body-hash))\\n\\n;; Generate Authorization header\\n(def auth (aws4-auth scope creq ts headers\\n                     \\\"SECRET_KEY\\\" \\\"ACCESS_KEY\\\"))\\n\\n;; Make the signed request\\n(def signed-headers (cons [\\\"Authorization\\\" :: auth] headers))\\n(def resp (http-post (string-append \\\"https://\\\" host \\\"/\\\")\\n            headers: signed-headers\\n            data: (bytes->string body-bytes)))",
    "notes": "aws4-canonical-request and aws4-auth are from :std/net/s3/sigv4 (works for ALL AWS services, not just S3). The scope format is \\\"YYYYMMDD/region/service\\\". Headers must be an alist with [key :: value] pairs. body-hash is the SHA256 of the request body as a u8vector. For GET requests with no body, use (sha256 #u8()) for the hash.",
    "related": [
      "http-post-form-encoded",
      "crypto-digest-sha256-md5",
      "srfi19-date-time-format"
    ]
  },
  {
    "id": "hash-table-basics",
    "title": "Hash table operations",
    "tags": [
      "hash",
      "table",
      "get",
      "ref",
      "put",
      "key",
      "remove",
      "lookup",
      "default"
    ],
    "imports": [],
    "code": "(def ht (hash (\"name\" \"alice\") (\"age\" 30)))   ;; literal syntax\n(hash-ref ht \"name\")          ;; => \"alice\" (error if missing)\n(hash-ref ht \"missing\" 42)    ;; => 42 (hash-ref takes optional 3rd arg default)\n(hash-get ht \"name\")          ;; => \"alice\" (returns #f if missing)\n;; IMPORTANT: hash-get takes EXACTLY 2 args (table, key). Returns #f if missing.\n;; For a default value, use hash-ref with 3 args: (hash-ref ht key default)\n(hash-put! ht \"email\" \"a@b\")  ;; mutate\n(hash-key? ht \"name\")         ;; => #t\n(hash-remove! ht \"age\")\n(hash->list ht)               ;; => ((\"name\" . \"alice\") ...)\n\n;; Multi-arity wrapper if you want hash-get with defaults:\n(def* hget\n  ((ht key) (hash-get ht key))\n  ((ht key default) (hash-ref ht key default)))",
    "notes": "CRITICAL: hash-get is STRICTLY 2-arity in Gerbil. (hash-get ht key default) is WRONG and will error. Use hash-ref for 3-arg lookups with a default. The hget wrapper pattern (using def*) provides a convenient multi-arity alternative. Use (hash ...) for string keys, (hash-eq ...) for symbol keys.",
    "related": [
      "iterate-hash",
      "hash-table-merge"
    ]
  },
  {
    "id": "exe-build-static-modules",
    "title": "Build statically-linked executable with dependencies",
    "tags": [
      "exe",
      "build",
      "static",
      "link",
      "binary",
      "executable",
      "release",
      "defbuild-script"
    ],
    "imports": [
      ":std/build-script"
    ],
    "code": ";; build.ss — with exe target\n#!/usr/bin/env gxi\n(import :std/build-script)\n(defbuild-script\n  '(\"module-a\"\n    \"module-b\"\n    (exe: \"main\" bin: \"my-app\")))\n\n;; REQUIREMENTS for exe linking:\n;; 1. The main module MUST export its main function:\n;;    (export main)\n;;\n;; 2. All dependencies must have static modules (.scm files in static/ dir).\n;;    Build dependencies with --release:\n;;      cd /path/to/dependency && gerbil build --release\n;;\n;; 3. GERBIL_LOADPATH must include the dependency's .gerbil/lib/ directory\n;;    so the linker can find static modules:\n;;      GERBIL_LOADPATH=/path/to/dep/.gerbil/lib gerbil build --release\n;;\n;; 4. Build YOUR project with --release too:\n;;      gerbil build --release",
    "notes": "Common errors: (1) \"cannot find static module foo__bar.scm\" — the dependency wasn't built with --release, or its .gerbil/lib/ isn't in GERBIL_LOADPATH. (2) \"module does not export symbol: main\" — add (export main) to the main module. (3) Linker warnings about dlopen/getaddrinfo are harmless for static Gambit binaries. The resulting binary is fully self-contained and doesn't need Gerbil installed to run.",
    "related": [
      "cli-getopt-subcommands"
    ]
  },
  {
    "id": "export-t-does-not-reexport-imports",
    "title": "(export #t) does NOT re-export imported symbols",
    "tags": [
      "export",
      "import",
      "re-export",
      "module",
      "gotcha",
      "transitive"
    ],
    "imports": [],
    "code": ";; Module A (a.ss) — imports and re-exports\n(import :some-library/foo)  ;; provides make-foo\n(export #t)\n\n(def (helper x) (make-foo x))  ;; make-foo is usable here\n\n;; Module B (b.ss) — imports Module A\n(import ./a)\n\n;; (make-foo 42)  ;; ERROR: make-foo is NOT available!\n;; (export #t) only exports symbols DEFINED in the module,\n;; not symbols imported from other modules.\n\n;; WORKAROUND 1: Import the library directly in Module B\n(import :some-library/foo)  ;; now make-foo is available\n\n;; WORKAROUND 2: Explicitly re-export in Module A\n;; (export (import: :some-library/foo))  ;; re-exports foo's bindings",
    "notes": "In Gerbil, (export #t) exports all bindings DEFINED in the current module's scope, but does NOT transitively re-export symbols imported from other modules. If module A imports :lib/foo and uses (export #t), module B importing A will NOT get :lib/foo's symbols. Module B must import :lib/foo directly, or module A must use (export (import: :lib/foo)) for explicit re-export. This is a common source of \"Reference to unbound identifier\" errors when refactoring."
  },
  {
    "id": "cons-pair-in-bracket-list-gotcha",
    "title": "Dotted pair syntax inside [] is a function call, not a cons pair",
    "tags": [
      "cons",
      "pair",
      "list",
      "bracket",
      "dotted",
      "gotcha",
      "alist",
      "dimensions"
    ],
    "imports": [],
    "code": ";; WRONG: Dotted pair syntax with a variable inside [] list sugar\n;; This is interpreted as calling \"Key\" as a function with value as arg!\n(def key-name \"MyKey\")\n;; [(\"Key\" . key-name)]  ;; ERROR: Bad syntax; invalid match target\n;; Expands to (@list (\"Key\" . key-name)) where (\"Key\" . key-name)\n;; is treated as (%%app \"Key\" . key-name) — a function application.\n\n;; CORRECT: Use (cons ...) to build pairs with variables\n[(cons \"Key\" key-name)]        ;; => ((\"Key\" . \"MyKey\"))\n\n;; Literal dotted pairs (both sides are constants) work inside quote:\n'((\"Key\" . \"literal-value\"))   ;; OK — quoted datum\n\n;; Common use case: building alists for AWS API dimensions\n(def instance-id \"i-abc123\")\n;; Wrong:  dimensions: [(\"InstanceId\" . instance-id)]\n;; Right:  dimensions: [(cons \"InstanceId\" instance-id)]\n\n;; Multiple pairs:\n(def name \"my-func\")\n(def dims [(cons \"FunctionName\" name)\n           (cons \"Resource\" \"my-resource\")])\n;; => ((\"FunctionName\" . \"my-func\") (\"Resource\" . \"my-resource\"))",
    "notes": "In Gerbil, [x y z] is sugar for (@list x y z). Each element is an expression. The syntax (\"Key\" . var) in expression position is NOT a cons pair — it's a function application where \"Key\" is the operator. This causes \"Bad syntax; invalid match target\" or similar errors. Use (cons \"Key\" var) instead. Literal pairs work fine inside quote: '((\"k\" . \"v\")). This commonly bites when building alists (e.g., AWS API dimension parameters) where keys are string literals but values are variables."
  },
  {
    "id": "gerbil-build-loadpath-for-packages",
    "title": "gerbil build needs GERBIL_LOADPATH to find installed packages",
    "tags": [
      "build",
      "GERBIL_LOADPATH",
      "package",
      "import",
      "cannot find",
      "library module",
      "Makefile"
    ],
    "imports": [],
    "code": ";; If your project imports a third-party package installed via gerbil pkg:\n;; (import :my-library/module)\n;;\n;; Running bare `gerbil build` may fail with:\n;;   Syntax Error: cannot find library module\n;;   form: :my-library/module\n;;\n;; The fix: set GERBIL_LOADPATH to include ~/.gerbil/lib\n;;\n;; Option 1: Shell environment variable\n;; $ GERBIL_LOADPATH=~/.gerbil/lib gerbil build\n;;\n;; Option 2: Makefile (recommended for projects)\n;; ------- Makefile -------\n;; GERBIL_PATH = $(HOME)/.gerbil\n;; export GERBIL_LOADPATH = $(GERBIL_PATH)/lib\n;;\n;; build:\n;; \tgerbil build\n;;\n;; clean:\n;; \tgerbil clean\n;; ------- end -------\n;;\n;; Note: gxi (the REPL) finds packages without GERBIL_LOADPATH,\n;; but the build subprocess spawned by `gerbil build` does not.\n;; This is a common source of confusion when imports work in gxi\n;; but fail during compilation.",
    "notes": "The gerbil build command spawns a subprocess to compile, and that subprocess does not inherit the default package search paths that gxi uses. You must explicitly set GERBIL_LOADPATH=$HOME/.gerbil/lib (or wherever packages are installed). A Makefile with `export GERBIL_LOADPATH` is the standard pattern. This explains why `gxi -e '(import :pkg/mod)'` works but `gerbil build` fails with \"cannot find library module\"."
  },
  {
    "id": "gerbil-aws-query-vs-json-response-keys",
    "title": "gerbil-aws Query API vs JSON API response key differences",
    "tags": [
      "gerbil-aws",
      "query",
      "json",
      "XML",
      "symbol",
      "string",
      "keys",
      "AWS",
      "migration",
      "CloudWatch",
      "RDS",
      "ELBv2"
    ],
    "imports": [],
    "code": ";; gerbil-aws has two API protocols with DIFFERENT response formats:\n;;\n;; 1. Query API (XML): EC2, STS, IAM, CloudWatch, RDS, ELBv2, SNS, SQS, CloudFormation\n;;    - Keys are SYMBOLS: 'Average, 'InstanceId, 'DBInstanceIdentifier\n;;    - Values are STRINGS (from XML text): \"30.5\", \"true\", \"i-abc123\"\n;;    - Lists use {member: [...]} wrapper from XML <member> elements\n;;    - Booleans are strings: \"true\" / \"false\"\n;;\n;; 2. JSON API: Lambda, CloudWatch Logs, DynamoDB, Compute Optimizer, Cost Optimization Hub\n;;    - Keys are STRINGS: \"Average\", \"instanceId\", \"functionName\"\n;;    - Values are TYPED: 30.5 (number), #t (boolean), \"i-abc123\" (string)\n;;    - Lists are plain lists (JSON arrays)\n;;    - Booleans are #t / #f\n;;\n;; When migrating from AWS CLI (JSON output) to native Query API:\n;;   (hget resp \"Datapoints\")          ;; CLI: string key, list value\n;;   ;; becomes:\n;;   ;; get-metric-statistics returns the list directly (no wrapper key)\n;;\n;;   (hget dp \"Average\")               ;; CLI: string key, number value\n;;   ;; becomes:\n;;   (safe-number (hash-ref dp 'Average #f) 0)  ;; Query: symbol key, STRING value\n;;\n;; When migrating from AWS CLI to native JSON API:\n;;   (hget resp \"Functions\")           ;; CLI: string key, list value\n;;   ;; stays the same — JSON API matches CLI output format\n;;\n;; IMPORTANT: Query API numeric values MUST be converted with string->number\n;; or a safe-number wrapper. They come back as strings like \"30.5\" not 30.5.",
    "notes": "This is the most common source of bugs when migrating from AWS CLI calls to native gerbil-aws. Query API services return symbol keys and string values from XML parsing, while JSON API services return string keys and typed values (matching CLI output). Always use hash-ref with symbol keys ('Key) for Query API responses, and convert numeric strings with string->number or a safe wrapper.",
    "related": [
      "http-post-form-encoded",
      "parse-xml-to-sxml"
    ]
  },
  {
    "id": "extract-member-list-xml-normalization",
    "title": "Normalize XML member-list structures from gerbil-aws Query API",
    "tags": [
      "gerbil-aws",
      "XML",
      "member",
      "list",
      "normalize",
      "query",
      "API",
      "dimensions",
      "CloudWatch"
    ],
    "imports": [],
    "code": ";; AWS Query API XML uses <member> elements for lists:\n;;   <Dimensions>\n;;     <member><Name>InstanceId</Name><Value>i-abc</Value></member>\n;;     <member><Name>ImageId</Name><Value>ami-xyz</Value></member>\n;;   </Dimensions>\n;;\n;; After sxml->hash parsing, this becomes different structures depending\n;; on the number of <member> elements:\n;;\n;;   Single member:  {member: {Name: \"InstanceId\", Value: \"i-abc\"}}\n;;   Multiple:       {member: [{Name: \"InstanceId\", ...}, {Name: \"ImageId\", ...}]}\n;;   Empty:          #f or missing key\n;;\n;; Use this helper to normalize to a plain list in all cases:\n\n(def (extract-member-list raw)\n  \"Normalize XML member-list to a plain list.\n   Handles: #f -> [], list -> list, {member: list} -> list,\n            {member: hash} -> [hash], string -> [string]\"\n  (cond\n    ((not raw) [])\n    ((list? raw) raw)\n    ((hash-table? raw)\n     (let ((m (hash-get raw 'member)))\n       (cond\n         ((list? m) m)\n         ((not m) [])\n         (else [m]))))          ;; single member: wrap in list\n    (else [])))\n\n;; Example: extracting CloudWatch dimensions from list-metrics response\n;; (def metric (car (list-metrics cw metric-name: \"CPUUtilization\" ...)))\n;; (def dims-raw (hash-ref metric 'Dimensions #f))\n;; (def dims (extract-member-list dims-raw))\n;; ;; dims is now always a list of hashes with 'Name and 'Value keys\n;; (def dims-alist\n;;   (map (lambda (d) (cons (hash-ref d 'Name \"\") (hash-ref d 'Value \"\")))\n;;        dims))",
    "notes": "The gerbil-aws Query API functions like cw-action/items extract the outer member list, but inner nested member-list structures (e.g., Dimensions within a Metric) remain in raw XML-parsed form. This helper normalizes the three possible shapes (single hash, list of hashes, or #f) into a consistent list. Essential when processing CloudWatch list-metrics dimensions, IAM policy documents, or any Query API response with nested lists.",
    "related": [
      "gerbil-aws-query-vs-json-response-keys"
    ]
  },
  {
    "id": "sxml-skip-pi-nodes",
    "title": "Skip *PI* processing instruction nodes when traversing SXML",
    "tags": [
      "sxml",
      "xml",
      "parsing",
      "processing-instruction",
      "PI",
      "read-xml",
      "traverse",
      "gotcha",
      "*PI*",
      "*TOP*"
    ],
    "imports": [
      ":std/markup/xml"
    ],
    "code": "\n(import :std/markup/xml)\n\n;; XML responses often start with <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n;; read-xml parses this into a *PI* (Processing Instruction) SXML node:\n;;\n;;   (*TOP*\n;;     (@ (*NAMESPACES* ...))\n;;     (*PI* xml \"version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"\")   ;; <-- gotcha!\n;;     (ns:RootElement ...))\n;;\n;; When traversing SXML to find the root element, you MUST skip *PI* nodes\n;; along with @, *NAMESPACES*, and *TOP*. Otherwise *PI* gets mistakenly\n;; treated as the root element.\n\n;; WRONG — misses *PI*, returns wrong node:\n(def (find-root-BAD xml)\n  (let find ((node xml))\n    (cond\n      ((not (pair? node)) #f)\n      ((memq (car node) '(@ *NAMESPACES*)) #f)        ;; missing *PI*!\n      ((not (eq? (car node) '*TOP*)) node)\n      (else (ormap find (cdr node))))))\n\n;; CORRECT — skips *PI* nodes:\n(def (find-root-GOOD xml)\n  (let find ((node xml))\n    (cond\n      ((not (pair? node)) #f)\n      ((memq (car node) '(@ *NAMESPACES* *PI*)) #f)   ;; includes *PI*\n      ((not (eq? (car node) '*TOP*)) node)\n      (else (ormap find (cdr node))))))\n\n;; Example: parsing an S3 response with XML declaration\n(def xml (read-xml\n           \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><Root><Item>hello</Item></Root>\"\n           namespaces: '()))\n\n(find-root-BAD xml)   ;; => (*PI* xml \"version=\\\"1.0\\\" ...\") — WRONG!\n(find-root-GOOD xml)  ;; => (Root (Item \"hello\")) — correct\n",
    "notes": "The *PI* node appears in SXML when the source XML contains processing instructions like <?xml ...?>. Most real-world XML APIs (AWS S3, etc.) include this declaration. The SXML metadata nodes to always skip when searching for content elements are: *TOP* (document root wrapper), @ (attributes), *NAMESPACES* (namespace declarations), and *PI* (processing instructions). Forgetting *PI* causes silent data loss — the PI node gets processed as if it were the root element, typically producing an empty string or #f instead of the expected parsed data."
  },
  {
    "id": "stale-global-static-files-segfault",
    "title": "Stale global static files cause segfaults in compiled binaries",
    "tags": [
      "segfault",
      "static",
      "linking",
      "build",
      "stale",
      "global",
      "GERBIL_LOADPATH",
      "ABI",
      "mismatch",
      "crash",
      "exe"
    ],
    "imports": [],
    "code": ";; PROBLEM: Compiled binary segfaults but code works fine in gxi REPL.\n;;\n;; ROOT CAUSE: Stale static files (.scm, .c, .o) in ~/.gerbil/lib/static/\n;; shadow locally compiled versions. When GERBIL_LOADPATH includes\n;; ~/.gerbil/lib BEFORE the local project path, the exe linker picks up\n;; the old global .o files instead of the current local ones.\n;;\n;; This causes ABI mismatches: e.g., cost-explorer calls\n;;   aws-billing/aws#first-of-month-string__%  (new split variant)\n;; but the stale global aws module only defines\n;;   aws-billing/aws#first-of-month-string     (old monolithic variant)\n;; Calling an undefined symbol → SIGSEGV.\n;;\n;; HOW STALE FILES GET THERE:\n;; - Running `gerbil build` or `gxpkg build` from within a project\n;;   that has its .gerbil/lib/ in GERBIL_LOADPATH\n;; - A previous `gerbil pkg install` of the package\n;; - Manually copying build artifacts\n;;\n;; DIAGNOSIS:\n;; 1. Check for duplicate static files:\n;;    find ~/.gerbil/lib -name 'YOURPKG__*.scm' -o -name 'YOURPKG__*.o'\n;;\n;; 2. Compare with local project files:\n;;    ls -la ~/.gerbil/lib/static/YOURPKG__module.scm   # stale (old timestamp)\n;;    ls -la ./project/.gerbil/lib/static/YOURPKG__module.scm  # current\n;;\n;; 3. Check build output: if BOTH paths appear during exe compilation,\n;;    the global one may win.\n;;\n;; FIX:\n;; Remove ALL stale global artifacts (.scm, .c, .o, .ssi):\n;;   rm -rf ~/.gerbil/lib/YOURPKG/\n;;   rm -f  ~/.gerbil/lib/static/YOURPKG__*.scm\n;;   rm -f  ~/.gerbil/lib/static/YOURPKG__*.c\n;;   rm -f  ~/.gerbil/lib/static/YOURPKG__*.o\n;;\n;; Then clean rebuild:\n;;   make clean && make build\n;;\n;; IMPORTANT: `gerbil clean` only removes LOCAL .gerbil/ artifacts.\n;; It does NOT clean ~/.gerbil/lib/. You must manually remove stale\n;; global files. Also note: removing just .scm files is NOT enough —\n;; the linker uses the .o files directly if they exist.",
    "notes": "The Gerbil compiler may change how optional-arg functions are compiled across versions (monolithic closure vs split __%/__0 variants). If global static files are from an older compilation, the ABI won't match modules compiled with the current compiler. The segfault typically occurs at the call site in `(declare (not safe))` blocks where the undefined function symbol resolves to null/garbage. The `strings` command won't find Gerbil string literals in compiled binaries (they're stored as Gambit string objects, not C strings), so use `grep` on the `.scm` static files to verify which version the linker uses.",
    "related": [
      "static-exe-with-deps",
      "gerbil-build-loadpath"
    ]
  },
  {
    "id": "debug-compiled-only-segfault",
    "title": "Debug segfaults that only occur in compiled binaries (not REPL)",
    "tags": [
      "debug",
      "segfault",
      "compiled",
      "binary",
      "REPL",
      "gdb",
      "static",
      "linking",
      "crash"
    ],
    "imports": [],
    "code": ";; When code works in gxi but segfaults as a compiled binary:\n;;\n;; STEP 1: Test in REPL to confirm the logic is correct\n;;   echo '(import :mymodule) (my-function args)' | \\\n;;     GERBIL_LOADPATH=... gxi\n;;\n;; STEP 2: Add debug displayln/force-output INSIDE the crashing function\n;;   (def (my-function arg)\n;;     (displayln \"[dbg] entering\") (force-output)\n;;     (let ((x (step-1)))\n;;       (displayln \"[dbg] step-1 ok\") (force-output)\n;;       ...))\n;;\n;; STEP 3: Rebuild and check if debug output appears in binary\n;;   ;; Gerbil string literals are NOT plain C strings in the binary.\n;;   ;; Check the static .scm file instead:\n;;   grep 'dbg' .gerbil/lib/static/YOURPKG__module.scm\n;;\n;; STEP 4: If debug strings are in .scm but NOT in behavior,\n;;   check for stale global copies shadowing local files:\n;;   find ~/.gerbil/lib -name 'YOURPKG__*' -type f\n;;\n;; STEP 5: Compare compiled function signatures between versions\n;;   ;; Old compilation style (monolithic optional-arg function):\n;;   ;;   (define pkg#my-fn (let ((opt-lambda ...)) (lambda _g_ ...)))\n;;   ;;\n;;   ;; New compilation style (split variants):\n;;   ;;   (define pkg#my-fn__% (lambda (arg) ...))    ; implementation\n;;   ;;   (define pkg#my-fn__0 (lambda () ...))        ; zero-arg wrapper\n;;   ;;   (define pkg#my-fn (lambda _g_ (cond ...)))   ; dispatch\n;;   ;;\n;;   ;; If caller uses my-fn__% but linked module only defines my-fn,\n;;   ;; the symbol is undefined → segfault in (declare (not safe)) context.\n;;\n;; STEP 6: GDB can identify the hosting function but not the exact line:\n;;   ;; ___H_pkg____module is Gambit's C hosting function for the module.\n;;   ;; All compiled Scheme code for that module lives inside this one\n;;   ;; C function, so the crash address isn't very informative.\n;;   ;; Use debug displayln to narrow down instead.",
    "notes": "Key insight: in compiled Gerbil binaries with (declare (not safe)), calling an undefined/unresolved symbol doesn't raise a Scheme exception — it causes a raw SIGSEGV because the null function pointer is called without any safety checks. The REPL doesn't have this problem because it resolves symbols dynamically. Also: `gerbil clean` does NOT remove ~/.gerbil/lib/ artifacts — only local .gerbil/ files.",
    "related": [
      "stale-global-static-files-segfault",
      "static-exe-with-deps"
    ]
  },
  {
    "id": "srfi-19-current-time-shadows-gambit",
    "title": "SRFI-19 current-time shadows Gambit's current-time (causes time->seconds crash)",
    "tags": [
      "srfi-19",
      "current-time",
      "time",
      "gambit",
      "shadow",
      "time->seconds",
      "mutex",
      "rate-limit",
      "gotcha"
    ],
    "imports": [
      ":std/srfi/19"
    ],
    "code": ";; PROBLEM: Importing :std/srfi/19 shadows Gambit's built-in (current-time).\n;;\n;; Gambit's (current-time) returns a Gambit time object (##type #2 time).\n;; SRFI-19's (current-time) returns an SRFI-19 time object (different type).\n;; Gambit's (time->seconds) only accepts Gambit time objects.\n;;\n;; If you import :std/srfi/19 and then call:\n;;   (time->seconds (current-time))\n;; You get: \"Instance of #<type #2 time> expected\"\n;; because (current-time) now returns SRFI-19 time, but (time->seconds)\n;; expects Gambit time.\n;;\n;; This commonly bites in rate-limiting code, mutex timing, or anywhere\n;; you mix SRFI-19 date formatting with Gambit timing primitives.\n\n;; WRONG — crashes at runtime:\n;; (import :std/srfi/19)\n;; (def (rate-limit!)\n;;   (let ((now (time->seconds (current-time))))  ;; BOOM\n;;     ...))\n\n;; FIX: Use ##current-time to bypass the SRFI-19 shadow:\n(import :std/srfi/19)\n(def (rate-limit!)\n  (let ((now (exact->inexact (time->seconds (##current-time)))))\n    ;; ##current-time always returns Gambit's native time object\n    ;; time->seconds works correctly on it\n    now))\n\n;; ALTERNATIVE: Use SRFI-19's own time conversion instead:\n;; (import :std/srfi/19)\n;; (def (current-seconds)\n;;   (let ((t (current-time)))  ;; SRFI-19 time\n;;     (+ (time-second t)       ;; SRFI-19 accessor\n;;        (/ (time-nanosecond t) 1e9))))",
    "notes": "The ## prefix accesses Gambit's raw (unshadowed) primitives. ##current-time is safe to use even when SRFI-19 is imported. This issue only manifests at runtime — compilation succeeds because both versions of current-time have the same arity. The error message \"Instance of #<type #2 time> expected\" is the key diagnostic clue. Also note: exact->inexact is needed because time->seconds may return an exact rational.",
    "related": [
      "date-time-formatting-srfi-19"
    ]
  },
  {
    "id": "mutex-unwind-protect-deadlock-prevention",
    "title": "Always wrap mutex-lock!/unlock! with unwind-protect to prevent deadlocks",
    "tags": [
      "mutex",
      "unwind-protect",
      "deadlock",
      "thread",
      "lock",
      "concurrency",
      "exception",
      "safety"
    ],
    "imports": [],
    "code": ";; PROBLEM: If an exception occurs between mutex-lock! and mutex-unlock!,\n;; the mutex stays locked forever, deadlocking all subsequent callers.\n;;\n;; WRONG — deadlocks after first exception:\n;; (def my-lock (make-mutex 'my-lock))\n;; (def (unsafe-operation!)\n;;   (mutex-lock! my-lock)\n;;   (do-something-that-might-throw)  ;; if this throws...\n;;   (mutex-unlock! my-lock))         ;; ...this never runs → deadlock\n\n;; CORRECT — always unlocks, even on exception:\n(def my-lock (make-mutex 'my-lock))\n\n(def (safe-operation!)\n  (mutex-lock! my-lock)\n  (unwind-protect\n    (do-something-that-might-throw)\n    (mutex-unlock! my-lock)))\n\n;; PATTERN: Rate limiter with mutex + timing\n(def _api-lock (make-mutex 'api-lock))\n(def _last-call-time 0.0)\n(defconst API-DELAY 0.1)  ;; 100ms between calls\n\n(def (rate-limit!)\n  (mutex-lock! _api-lock)\n  (unwind-protect\n    (let* ((now (exact->inexact (time->seconds (##current-time))))\n           (elapsed (fl- now _last-call-time)))\n      (when (fl< elapsed API-DELAY)\n        (thread-sleep! (fl- API-DELAY elapsed)))\n      (set! _last-call-time\n        (exact->inexact (time->seconds (##current-time)))))\n    (mutex-unlock! _api-lock)))\n\n;; DIAGNOSTIC: Deadlock symptoms in Gerbil:\n;; - Program hangs after first API error\n;; - GDB backtrace shows ##mutex-lock-out-of-line!\n;; - Error log shows \"Deadlock detected\" with mutex name",
    "notes": "unwind-protect guarantees the cleanup form (mutex-unlock!) runs regardless of whether the body completes normally or throws an exception. This is analogous to try/finally in other languages. Without it, any exception between lock and unlock permanently locks the mutex. This is especially critical in rate-limiting code where API calls may throw network exceptions, timeout errors, or AWS service errors. The deadlock typically manifests on the SECOND call after the first exception.",
    "related": [
      "srfi-19-current-time-shadows-gambit",
      "error-handling"
    ]
  },
  {
    "id": "error-message-returns-false-for-non-error",
    "title": "error-message returns #f for non-Gerbil-Error exceptions — use display-exception",
    "tags": [
      "error-message",
      "exception",
      "display-exception",
      "error",
      "catch",
      "non-error",
      "gambit",
      "gotcha",
      "exception->string"
    ],
    "imports": [
      ":std/error"
    ],
    "code": ";; PROBLEM: (error-message e) only works for Gerbil Error objects.\n;; For Gambit exceptions, AWS errors, or other non-Error exceptions,\n;; it returns #f — making error messages invisible.\n;;\n;; WRONG — loses error information for non-Error exceptions:\n;; (try (some-operation)\n;;   (catch (e)\n;;     (displayln \"Error: \" (error-message e))))\n;; ;; Prints: \"Error: #f\" for Gambit/AWS exceptions\n\n;; CORRECT — use display-exception which handles ALL exception types:\n(def (exception->string e)\n  \"Convert any exception to a readable string.\"\n  (with-output-to-string (lambda () (display-exception e))))\n\n;; Usage in catch blocks:\n(try (some-operation)\n  (catch (e)\n    (displayln \"Error: \" (exception->string e))))\n\n;; WHY: Gerbil has multiple exception types:\n;; - (Error message irritants where) — Gerbil's own error type\n;;   → (error-message e) works, returns the message string\n;;\n;; - Gambit exceptions (error-exception, type-exception, etc.)\n;;   → (error-message e) returns #f\n;;   → (display-exception e port) works for all types\n;;\n;; - AWS service errors (from gerbil-aws)\n;;   → Usually Gambit error-exception objects\n;;   → (error-message e) returns #f\n;;\n;; display-exception is Gambit's universal exception printer.\n;; It knows how to format ALL exception types including stack traces.",
    "notes": "This is a common gotcha when writing generic error handlers. error-message is defined on the Gerbil Error struct and returns the 'message' slot. But catch (e) catches ALL exceptions, not just Gerbil Errors. Gambit runtime exceptions (type errors, arity errors, I/O errors, network errors) are NOT Gerbil Error objects. The exception->string helper using display-exception is the universal solution. Also: (object->string e) sometimes works but may not include the full formatted error message that display-exception provides.",
    "related": [
      "error-handling",
      "custom-error",
      "deferror-class"
    ]
  },
  {
    "id": "gerbil-json-arrays-are-lists-not-vectors",
    "title": "Gerbil JSON arrays are lists, not vectors — never use (vector? x) to check",
    "tags": [
      "json",
      "vector",
      "list",
      "array",
      "vector?",
      "read-json",
      "gerbil-aws",
      "ensure-list",
      "gotcha",
      "silent-failure"
    ],
    "imports": [
      ":std/text/json"
    ],
    "code": ";; PROBLEM: Gerbil's read-json (and gerbil-aws JSON API responses) return\n;; JSON arrays as Scheme LISTS, not vectors. Code that checks (vector? x)\n;; silently drops all data because (vector? '(1 2 3)) => #f.\n;;\n;; This is a SILENT FAILURE — no error, no exception, just empty results.\n\n;; WRONG — silently discards all JSON array data:\n;; (let ((results (hget resp \"ResultsByTime\")))\n;;   (if (vector? results)          ;; ALWAYS #f for JSON arrays!\n;;     (vector->list results)       ;; never reached\n;;     []))                         ;; always returns empty list\n\n;; WRONG — silently skips processing:\n;; (let ((groups (hget resp \"Groups\")))\n;;   (when (vector? groups)         ;; ALWAYS #f!\n;;     (for-each process groups)))  ;; never runs\n\n;; CORRECT — use a defensive ensure-list helper:\n(def (ensure-list v)\n  \"Coerce a vector, list, or other value to a list.\"\n  (cond ((list? v) v)\n        ((vector? v) (vector->list v))  ;; handles the rare vector case\n        (else [])))\n\n;; Usage:\n(let ((results (ensure-list (hget resp \"ResultsByTime\"))))\n  (for-each process results))\n\n;; For extracting the first element of a \"Keys\" array:\n;; WRONG:\n;; (if (vector? keys) (vector-ref keys 0) \"Unknown\")\n;; CORRECT:\n(let ((ks (ensure-list keys)))\n  (if (pair? ks) (car ks) \"Unknown\"))\n\n;; WHY THIS HAPPENS:\n;; - Gerbil's :std/text/json read-json maps JSON arrays to Scheme lists\n;; - gerbil-aws JSON API (Cost Explorer, Lambda, etc.) uses read-json\n;; - Many AWS SDK examples in other languages use arrays/vectors,\n;;   so it's natural to write (vector? ...) but WRONG in Gerbil\n;; - The gerbil-aws Query API (EC2, RDS, etc.) also returns lists\n;;   (from XML member parsing), never vectors",
    "notes": "This is one of the most insidious bugs because it causes SILENT data loss — no exceptions, no errors, just empty results everywhere. The code appears to run successfully but produces no output. Diagnosis: add (displayln (object-type results)) to see that results is a list, not a vector. Prevention: never use (vector? x) to guard JSON array processing — use (list? x) or the ensure-list helper instead. This applies to ALL gerbil-aws responses (both Query API and JSON API) and to any data parsed by Gerbil's read-json.",
    "related": [
      "gerbil-aws-query-vs-json-response-keys",
      "json-parse"
    ]
  },
  {
    "id": "ec2-xml-lowercase-camelcase-keys",
    "title": "EC2 Query API XML uses lowercase camelCase keys, not PascalCase",
    "tags": [
      "ec2",
      "query-api",
      "xml",
      "camelCase",
      "lowercase",
      "regionName",
      "instanceId",
      "symbol",
      "key",
      "gotcha"
    ],
    "imports": [],
    "code": ";; PROBLEM: AWS API documentation shows PascalCase names like\n;; \"RegionName\", \"InstanceId\", \"VolumeId\". But the EC2 Query API\n;; XML response uses lowercase camelCase: <regionName>, <instanceId>.\n;;\n;; After XML parsing in gerbil-aws, these become lowercase symbols:\n;;   'regionName  NOT 'RegionName\n;;   'instanceId  NOT 'InstanceId\n;;   'volumeId    NOT 'VolumeId\n;;   'vpcId       NOT 'VpcId\n;;\n;; WRONG — throws UnboundKeyError:\n;; (hash-ref region-hash 'RegionName)   ;; key not found!\n;; (hash-ref instance 'InstanceId)      ;; key not found!\n;;\n;; CORRECT — use lowercase camelCase:\n;; (hash-ref region-hash 'regionName)   ;; works\n;; (hash-ref instance 'instanceId)      ;; works\n;;\n;; This applies to ALL ec2-action/items responses in gerbil-aws:\n;;   describe-regions     → 'regionName, 'regionEndpoint\n;;   describe-instances   → 'instanceId, 'instanceType, 'imageId\n;;   describe-volumes     → 'volumeId, 'size, 'volumeType\n;;   describe-snapshots   → 'snapshotId, 'volumeId, 'startTime\n;;   describe-addresses   → 'publicIp, 'allocationId\n;;   describe-nat-gateways → 'natGatewayId, 'vpcId, 'subnetId\n;;   describe-images      → 'imageId, 'name, 'creationDate\n;;\n;; But OTHER Query API services may use different casing:\n;;   CloudWatch  → 'MetricName, 'Namespace (PascalCase)\n;;   RDS         → 'DBInstanceIdentifier (PascalCase)\n;;   ELBv2       → 'LoadBalancerArn (PascalCase)\n;;\n;; The casing matches the actual XML element names in each service's\n;; API response, which varies by service. EC2 happens to use lowercase.",
    "notes": "The AWS documentation and CLI both show PascalCase (RegionName, InstanceId), but EC2's actual XML response uses lowercase camelCase. Other Query API services like CloudWatch and RDS use PascalCase in their XML. There's no universal rule — you must check the actual XML element names for each service. When in doubt, add a debug line: (displayln (hash->list my-hash)) to see the actual keys.",
    "related": [
      "gerbil-aws-query-vs-json-response-keys"
    ]
  },
  {
    "id": "write-json-cannot-serialize-cons-pairs",
    "title": "write-json cannot serialize cons pairs from hash->list — convert to hashes first",
    "tags": [
      "write-json",
      "hash->list",
      "cons",
      "pair",
      "alist",
      "serialize",
      "json",
      "Missing method",
      "gotcha"
    ],
    "imports": [
      ":std/text/json"
    ],
    "code": ";; PROBLEM: (hash->list ht) returns alist pairs: ((\"key1\" . val1) (\"key2\" . val2) ...)\n;; write-json does NOT know how to serialize cons pairs (dotted pairs).\n;; It throws: \"Missing method --- irritants: (\"key\" . value) :json\"\n;;\n;; This commonly happens when you sort a hash table and embed the\n;; sorted result in a data structure that later gets written to JSON.\n\n;; WRONG — crashes at JSON serialization time:\n;; (def sorted-services\n;;   (sort (hash->list service-totals)\n;;         (lambda (a b) (> (cdr a) (cdr b)))))\n;; (hash-put! data \"top_services\" sorted-services)\n;; ;; Later: (write-json data port)\n;; ;; ERROR: Missing method (\"EC2 - Other\" . 1073969.83) :json\n\n;; CORRECT — convert cons pairs to hashes before storing:\n(import :std/text/json)\n(def sorted-services\n  (sort (hash->list service-totals)\n        (lambda (a b) (> (cdr a) (cdr b)))))\n\n;; Convert alist pairs to list of hashes for JSON serialization:\n(def json-safe-services\n  (map (lambda (p) (hash (\"service\" (car p)) (\"cost\" (cdr p))))\n       sorted-services))\n\n(hash-put! data \"top_services\" json-safe-services)\n;; Now write-json works: [{\"service\":\"EC2\",\"cost\":1073969.83}, ...]\n\n;; write-json handles these types:\n;;   hash-table  → JSON object {\"key\": value}\n;;   list        → JSON array [...]\n;;   string      → JSON string \"...\"\n;;   number      → JSON number\n;;   #t / #f     → true / false\n;;   void / #!void → null\n;;\n;; It does NOT handle:\n;;   cons pair (\"k\" . v) → ERROR: Missing method :json\n;;   struct             → ERROR (unless has :json method)\n;;   symbol             → ERROR",
    "notes": "This error only surfaces at JSON write time, not when building the data structure. It's easy to miss during development if you only test the markdown output (which uses car/cdr on pairs directly). The fix is to convert alist pairs to hashes at the point where they're stored in the data structure, before they reach write-json. An alternative is to define a recursive sanitizer that walks the data tree and converts all cons pairs to hashes, but it's cleaner to convert at the source.",
    "related": [
      "gerbil-json-arrays-are-lists-not-vectors",
      "json-generate"
    ]
  },
  {
    "id": "gerbil-aws-sts-nested-response",
    "title": "STS GetCallerIdentity returns nested hash — Account is under GetCallerIdentityResult",
    "tags": [
      "sts",
      "get-caller-identity",
      "account-id",
      "nested",
      "gerbil-aws",
      "query-api"
    ],
    "imports": [
      ":gerbil-aws/sts/api",
      ":gerbil-aws/sts/operations"
    ],
    "code": ";; gerbil-aws STS uses the Query API (XML). The GetCallerIdentity\n;; response XML is:\n;;   <GetCallerIdentityResponse>\n;;     <GetCallerIdentityResult>\n;;       <Account>123456789012</Account>\n;;       <Arn>arn:aws:iam::123456789012:user/me</Arn>\n;;       <UserId>AIDAXXXXXXX</UserId>\n;;     </GetCallerIdentityResult>\n;;     <ResponseMetadata>...</ResponseMetadata>\n;;   </GetCallerIdentityResponse>\n;;\n;; After aws-response->hash, the result is a NESTED hash:\n;;   {GetCallerIdentityResult: {Account: \"123456789012\", Arn: \"...\", UserId: \"...\"},\n;;    ResponseMetadata: {RequestId: \"...\"}}\n\n;; WRONG — 'Account is NOT at the top level:\n;; (def identity (get-caller-identity sts))\n;; (hash-ref identity 'Account \"\")  ;; => \"\" (always!)\n\n;; CORRECT — navigate to GetCallerIdentityResult first:\n(def sts (STSClient))\n(def identity (get-caller-identity sts))\n(def result (hash-ref identity 'GetCallerIdentityResult identity))\n(def account-id (hash-ref result 'Account \"\"))\n;; account-id => \"123456789012\"\n\n;; The same pattern applies to other STS operations:\n;; - AssumeRole → 'AssumeRoleResult → 'Credentials, 'AssumedRoleUser\n;; - GetSessionToken → 'GetSessionTokenResult → 'Credentials",
    "notes": "This is because gerbil-aws's aws-response->hash (in aws/xml.ss) converts the entire XML response to a nested hash, including the *Result wrapper element. The Query API always wraps the actual data in an ActionNameResult element. Using (hash-ref identity 'GetCallerIdentityResult identity) as a fallback ensures forward compatibility if the library ever changes to unwrap automatically.",
    "related": [
      "gerbil-aws-query-vs-json-response-keys",
      "ec2-lowercase-camelcase-keys"
    ]
  },
  {
    "id": "gerbil-aws-empty-xml-tagset-string",
    "title": "Empty XML elements like tagSet become \"\" not [] — guard with list? before iterating",
    "tags": [
      "xml",
      "sxml",
      "tagSet",
      "empty-element",
      "type-exception",
      "gerbil-aws",
      "ec2"
    ],
    "imports": [],
    "code": ";; PROBLEM: In gerbil-aws EC2 responses, empty XML elements like <tagSet/>\n;; are parsed by sxml->hash as \"\" (empty string), not [] (empty list).\n;;\n;; This happens because of this clause in sxml->hash:\n;;   ((null? (cdr element)) \"\")  ;; Empty element: (tag) → \"\"\n;;\n;; So when a resource has no tags:\n;;   <tagSet/>  →  \"\" in the hash table\n;;\n;; And (hash-ref resource 'tagSet []) returns \"\" (key exists with value \"\"),\n;; NOT the default [].\n\n;; WRONG — crashes with type-exception: PAIR expected from (car \"\")\n;; (def (get-name tags)\n;;   (let loop ((ts (or tags [])))  ;; (or \"\" []) => \"\" (truthy!)\n;;     (if (null? ts) \"\"            ;; (null? \"\") => #f\n;;       (let ((t (car ts)))        ;; (car \"\") => TYPE EXCEPTION!\n;;         ...))))\n\n;; CORRECT — check (list? tags) before iterating:\n(def (get-name tags)\n  (let ((ts (if (list? tags) tags [])))\n    (let loop ((ts ts))\n      (if (null? ts) \"\"\n        (let ((t (car ts)))\n          (if (and (hash-table? t)\n                   (string=? (hash-ref t 'key \"\") \"Name\"))\n            (hash-ref t 'value \"\")\n            (loop (cdr ts))))))))\n\n;; This affects ANY EC2 field that can be an empty XML element:\n;;   tagSet, blockDeviceMapping, networkInterfaceSet,\n;;   securityGroupSet, natGatewayAddressSet, etc.\n;;\n;; General rule: always use (list? x) not (or x []) when the\n;; value might be \"\" from empty XML elements.",
    "notes": "This is a silent type-exception that only manifests when a resource happens to have no tags (or other empty set elements). Resources with at least one tag work fine because tagSet gets parsed as a list of items. The bug is intermittent — it depends on whether specific resources in specific regions have tags. Use (if (list? val) val []) instead of (or val []) for XML-parsed set fields.",
    "related": [
      "ec2-lowercase-camelcase-keys",
      "gerbil-aws-query-vs-json-response-keys"
    ]
  },
  {
    "id": "aws-pricing-api-endpoint",
    "title": "AWS Pricing API endpoint is api.pricing not pricing — CloudFront 403 on wrong endpoint",
    "tags": [
      "aws",
      "pricing",
      "endpoint",
      "api.pricing",
      "cloudfront",
      "403",
      "gerbil-aws",
      "json-api"
    ],
    "imports": [
      ":gerbil-aws/aws/json-api"
    ],
    "code": ";; PROBLEM: The AWS Pricing API uses a DIFFERENT endpoint pattern\n;; than most AWS services. The standard pattern is:\n;;   service.region.amazonaws.com\n;;\n;; But the Pricing API uses:\n;;   api.pricing.region.amazonaws.com\n;;\n;; Using the standard pattern (pricing.us-east-1.amazonaws.com) hits\n;; a CloudFront distribution that only serves GET requests for the\n;; pricing website. POST requests get:\n;;   403 ERROR: \"This distribution is not configured to allow the\n;;   HTTP request method that was used for this request.\"\n\n;; WRONG — hits CloudFront, gets 403:\n;; (AWSJsonClient service: \"pricing\"\n;;               target-prefix: \"AWSPriceListService\"\n;;               region: \"us-east-1\")\n;; ;; Constructs endpoint: pricing.us-east-1.amazonaws.com\n\n;; CORRECT — explicitly set the api.pricing endpoint:\n(def pricing-client\n  (AWSJsonClient service: \"pricing\"\n                 target-prefix: \"AWSPriceListService\"\n                 endpoint: \"api.pricing.us-east-1.amazonaws.com\"\n                 region: \"us-east-1\"))\n\n;; For a configurable region:\n(def (make-pricing-client (region \"us-east-1\"))\n  (AWSJsonClient service: \"pricing\"\n                 target-prefix: \"AWSPriceListService\"\n                 endpoint: (string-append \"api.pricing.\" region \".amazonaws.com\")\n                 region: region))\n\n;; Other AWS services with non-standard endpoints:\n;;   Cost Explorer: ce.us-east-1.amazonaws.com (standard pattern, works)\n;;   S3: s3.region.amazonaws.com or s3.amazonaws.com (path-style)\n;;   STS: sts.amazonaws.com (global) or sts.region.amazonaws.com (regional)",
    "notes": "The AWS Pricing API is only available in us-east-1 and ap-south-1. Always pass the endpoint explicitly when creating the client. The AWSJsonClient default endpoint construction (service.region.amazonaws.com) does NOT work for the Pricing API. This manifests as a confusing CloudFront 403 error rather than an obvious endpoint error.",
    "related": [
      "gerbil-aws-query-vs-json-response-keys"
    ]
  },
  {
    "id": "aws-pricing-api-content-type-1-1",
    "title": "AWS Pricing API requires content-type application/x-amz-json-1.1, not 1.0",
    "tags": [
      "pricing",
      "aws",
      "content-type",
      "json",
      "1.1",
      "AWSJsonClient",
      "UnknownOperationException",
      "404"
    ],
    "imports": [
      ":gerbil-aws/aws/json-api"
    ],
    "code": ";; PROBLEM: The AWS Pricing API requires content-type \"application/x-amz-json-1.1\"\n;; but AWSJsonClient defaults to \"application/x-amz-json-1.0\".\n;;\n;; Without the correct content-type, ALL Pricing API calls fail with:\n;;   HTTP 404: <UnknownOperationException/>\n;;\n;; This is a SILENT CASCADING FAILURE — pricing lookups return #f,\n;; causing downstream code to skip hundreds of resources.\n\n;; WRONG — uses default content-type 1.0, gets 404 on every call:\n;; (def (make-pricing-client (region \"us-east-1\"))\n;;   (AWSJsonClient service: \"pricing\"\n;;                  target-prefix: \"AWSPriceListService\"\n;;                  endpoint: (string-append \"api.pricing.\" region \".amazonaws.com\")\n;;                  region: region))\n\n;; CORRECT — explicitly set content-type to 1.1:\n(def (make-pricing-client (region \"us-east-1\"))\n  (AWSJsonClient service: \"pricing\"\n                 target-prefix: \"AWSPriceListService\"\n                 endpoint: (string-append \"api.pricing.\" region \".amazonaws.com\")\n                 content-type: \"application/x-amz-json-1.1\"\n                 region: region))\n\n;; AWS services and their JSON protocol versions:\n;;   application/x-amz-json-1.1:\n;;     Pricing, Lambda, CloudWatch Logs, ECS, SSM, Secrets Manager\n;;   application/x-amz-json-1.0:\n;;     DynamoDB, Compute Optimizer, Cost Optimization Hub, SWF\n;;\n;; Check the AWS service's API reference for the correct version.\n;; The version is listed in the \"Common Headers\" section of each API doc.",
    "notes": "The AWSJsonClient in gerbil-aws defaults content-type to \"application/x-amz-json-1.0\" (set in json-api.ss line 45). AWS services that require 1.1 will reject ALL requests with HTTP 404 UnknownOperationException. This is extremely hard to debug because: (1) the error is XML even though it's a JSON API, (2) 404 suggests a wrong URL, not a wrong content-type, (3) the endpoint IS correct (api.pricing.region.amazonaws.com). Combined with the endpoint issue (see aws-pricing-api-endpoint recipe), there are TWO things you must get right for the Pricing API: the api.pricing prefix AND the 1.1 content-type.",
    "related": [
      "aws-pricing-api-endpoint"
    ]
  },
  {
    "id": "gerbil-aws-strip-ns-uri-namespace-bug",
    "title": "gerbil-aws strip-ns breaks on full URI namespace prefixes — finds first colon not last",
    "tags": [
      "strip-ns",
      "namespace",
      "XML",
      "SXML",
      "URI",
      "gerbil-aws",
      "STS",
      "RDS",
      "ELBv2"
    ],
    "imports": [],
    "code": ";; PROBLEM: gerbil-aws's strip-ns function in aws/xml.ss finds the FIRST\n;; colon in a symbol name, but URI namespace prefixes contain multiple colons.\n;;\n;; The function is:\n;;   (def (strip-ns sym)\n;;     (let (s (symbol->string sym))\n;;       (let (pos (string-contains s \":\"))   ;; finds FIRST \":\"\n;;         (if pos\n;;           (string->symbol (substring s (+ pos 1) (string-length s)))\n;;           sym))))\n;;\n;; For EC2, namespaces are mapped to short prefixes like \"ec2:\",\n;; so strip-ns works: 'ec2:instanceId → 'instanceId\n;;\n;; But for services WITHOUT namespace mappings (STS, RDS, ELBv2, CloudWatch),\n;; the XML parser produces full URI prefixes:\n;;   '//sts.amazonaws.com/doc/2011-06-15/:Account\n;;   '//rds.amazonaws.com/doc/2014-10-31/:DBInstances\n;;\n;; strip-ns finds the first \":\" in \"//sts.amazonaws.com/doc/2011-06-15/:Account\"\n;; which is in \"http:\" — producing '//sts.amazonaws.com/doc/2011-06-15/:Account\n;; (unchanged!) instead of 'Account.\n;;\n;; WORKAROUND: Add namespace mappings to your client, like EC2 does:\n;; (AWSClient ...\n;;   namespaces: '((\"https://sts.amazonaws.com/doc/2011-06-15/\" . \"sts\")))\n;;\n;; Or fix strip-ns to find the LAST colon:\n(def (strip-ns sym)\n  (let* ((s (symbol->string sym))\n         (len (string-length s)))\n    (let loop ((i (- len 1)))\n      (cond\n        ((< i 0) sym)\n        ((char=? (string-ref s i) #\\:)\n         (string->symbol (substring s (+ i 1) len)))\n        (else (loop (- i 1)))))))\n\n;; Test:\n;; (strip-ns '//sts.amazonaws.com/doc/2011-06-15/:Account) => 'Account\n;; (strip-ns 'ec2:instanceId) => 'instanceId\n;; (strip-ns 'noNamespace) => 'noNamespace\n\n;; AFFECTED SERVICES (no namespace mappings by default):\n;;   STS  — get-caller-identity returns empty account-id\n;;   RDS  — describe-db-instances returns 0 items\n;;   ELBv2 — describe-load-balancers returns 0 items\n;;   CloudWatch — some responses may be affected\n;;\n;; EC2 WORKS because it has explicit namespace mappings in ec2/xml.ss:\n;;   '((\"http://ec2.amazonaws.com/doc/2016-11-15/\" . \"ec2\"))",
    "notes": "This is a bug in gerbil-aws/aws/xml.ss. The proper fix is to change strip-ns to find the LAST colon instead of the first. The workaround is to add namespace mappings to each client (like EC2 does), but this requires knowing the exact namespace URI for each AWS service version. The bug causes SILENT DATA LOSS — API calls succeed (HTTP 200) but the response parsing can't match expected keys, so functions return empty lists or empty strings. Symptoms: get-account-id returns \"\", describe-db-instances returns 0 items, describe-load-balancers returns 0 items.",
    "related": [
      "aws-pricing-api-endpoint",
      "gerbil-aws-query-vs-json-response-keys",
      "ec2-lowercase-camelcase-keys"
    ]
  },
  {
    "id": "force-gc-gambit",
    "title": "Force garbage collection with ##gc in Gambit/Gerbil",
    "tags": [
      "gc",
      "garbage collection",
      "memory",
      "gambit",
      "heap",
      "oom"
    ],
    "imports": [],
    "code": ";; Force a full garbage collection using Gambit's ##gc primitive.\n;; Useful between memory-intensive sections to prevent heap from\n;; growing unboundedly when processing large datasets.\n\n;; Basic usage:\n(##gc)\n\n;; Pattern: Insert between heavy processing sections\n(def (process-large-dataset)\n  ;; Section 1: fetch and process data\n  (let ((data1 (fetch-large-data-1)))\n    (process data1)\n    (store-results data1))\n\n  ;; Force GC to reclaim temporary data from section 1\n  ;; before starting section 2\n  (##gc)\n\n  ;; Section 2: fetch more data\n  (let ((data2 (fetch-large-data-2)))\n    (process data2)\n    (store-results data2))\n\n  (##gc))\n\n;; Real-world example: AWS report data collection\n;; Without ##gc, parsed JSON from API responses accumulates\n;; until Gambit decides to collect, which may be too late\n;; on memory-constrained systems.\n;;\n;; (displayln \"  Fetching snapshots...\")\n;; (fetch-snapshots)\n;; (##gc)  ;; reclaim parsed API responses\n;; (displayln \"  Analyzing rightsizing...\")\n;; (analyze-rightsizing)  ;; another memory-heavy operation\n;; (##gc)\n",
    "notes": "##gc is a Gambit primitive (double-hash prefix). It triggers a full GC cycle synchronously. Returns void. Safe to call at any time. Particularly important in multi-threaded applications where many short-lived objects are created rapidly (e.g., parsing large JSON API responses) and the GC can't keep up with allocation pressure. Also useful in long-running batch programs that process data in phases. Note: calling ##gc too frequently adds overhead; use it between major processing phases, not in tight loops.",
    "related": [
      "srfi-19-current-time-shadows-gambit"
    ]
  },
  {
    "id": "thread-safe-list-accumulation",
    "title": "Thread-safe list accumulation — avoid O(n²) append anti-pattern",
    "tags": [
      "append",
      "cons",
      "thread",
      "parallel",
      "mutex",
      "performance",
      "memory",
      "accumulate"
    ],
    "imports": [],
    "code": ";; PROBLEM: When accumulating results from parallel threads, using\n;; (append accumulated new-items) copies the ENTIRE accumulated list\n;; on every call, creating O(n²) memory and time behavior.\n;;\n;; With large result sets across many threads, this wastes gigabytes\n;; of memory on redundant list copies before GC can reclaim them.\n\n;; WRONG — O(n²) memory, copies all-results on every append:\n;; (def result-mx (make-mutex 'result-mx))\n;; (def all-results [])\n;; ;; ... in each thread:\n;; (mutex-lock! result-mx)\n;; (set! all-results (append all-results new-results))  ;; BAD\n;; (mutex-unlock! result-mx)\n;; ;; append copies its FIRST argument, so (append big-list small-list)\n;; ;; copies big-list entirely. This grows quadratically.\n\n;; CORRECT — O(n) total, only copies the small new-results list:\n(def result-mx (make-mutex 'result-mx))\n(def all-results [])\n;; ... in each thread:\n(mutex-lock! result-mx)\n(set! all-results (append new-results all-results))  ;; GOOD\n(mutex-unlock! result-mx)\n;; append copies its first arg (small new-results) and links to second\n;; arg (large all-results) without copying it. O(k) per call where\n;; k = length of new-results.\n\n;; ALTERNATIVE — cons individual items (best for single results):\n(mutex-lock! result-mx)\n(set! all-results (cons single-result all-results))\n(mutex-unlock! result-mx)\n\n;; NOTE: Both correct approaches prepend, so results are in reverse\n;; order. Use (reverse all-results) at the end if order matters.\n;; But for many use cases (sorting results anyway), order doesn't matter.\n",
    "notes": "Scheme's append copies all cons cells of every argument except the last. So (append big-list small-list) copies big-list entirely. In a parallel accumulation loop, the accumulated list grows on each iteration, making the copy cost grow linearly and total cost quadratic. Swapping argument order — (append small-list big-list) — means only the small per-thread result is copied, keeping total cost linear. This matters when accumulating thousands of results across many threads: the O(n²) version can waste gigabytes of memory on intermediate copies that become garbage.",
    "related": [
      "mutex-unwind-protect"
    ]
  },
  {
    "id": "gerbil-function-signature-keyword-args-arity",
    "title": "gerbil_function_signature reports arity:1 for functions with keyword args",
    "tags": [
      "function-signature",
      "arity",
      "keyword",
      "args",
      "misleading",
      "gerbil-mcp"
    ],
    "imports": [],
    "code": ";; GOTCHA: gerbil_function_signature (and gerbil_doc) reports arity:1\n;; for functions that accept keyword arguments. This is technically correct\n;; (the compiled lambda takes 1 positional arg — the client/object) but\n;; misleading because the function actually accepts many keyword params.\n;;\n;; Example from gerbil-aws:\n;;   gerbil_function_signature for describe-alarms reports:\n;;     arity:1  (gerbil-aws/cloudwatch/operations#describe-alarms)\n;;\n;;   But the ACTUAL signature (from reading source) is:\n;;     (describe-alarms client\n;;       alarm-names: (alarm-names #f)\n;;       state-value: (state-value #f)\n;;       next-token: (next-token #f)\n;;       max-records: (max-records #f))\n;;\n;;   Similarly, describe-instances reports arity:1 but actually accepts:\n;;     (describe-instances client\n;;       instance-ids: (instance-ids [])\n;;       filters: (filters [])\n;;       max-results: (max-results #f)\n;;       next-token: (next-token #f))\n;;\n;; WORKAROUND: When gerbil_function_signature shows arity:1, ALWAYS\n;; read the actual source code (via gerbil_find_definition with\n;; source_preview: true, or by reading the .ss file directly) to\n;; discover keyword arguments.\n;;\n;; This is especially important for gerbil-aws library functions where\n;; most API operations accept keyword args for optional parameters like\n;; filters:, max-results:, next-token:, etc.",
    "notes": "Gambit compiles keyword arguments into a rest-args list internally, so the arity reflects only positional parameters. The gerbil_function_signature tool cannot currently extract keyword parameter names from compiled modules. Always verify by reading source when arity seems too low for an API wrapper function.",
    "related": [
      "optional-keyword-arguments"
    ]
  },
  {
    "id": "ec2-monitoring-state-filter",
    "title": "Filter EC2 instances by monitoring state instead of running state",
    "tags": [
      "EC2",
      "describe-instances",
      "filter",
      "monitoring",
      "detailed-monitoring",
      "gerbil-aws"
    ],
    "imports": [
      ":gerbil-aws/ec2/instances",
      ":gerbil-aws/ec2/api"
    ],
    "code": ";; To count instances with detailed monitoring enabled, use the\n;; \"monitoring-state\" filter instead of fetching ALL running instances.\n;;\n;; BAD — fetches every running instance (5-20KB each, thousands possible):\n;; (describe-instances ec2 filters: '((\"instance-state-name\" \"running\")))\n;; ;; Then manually check each instance's monitoring.state field\n;;\n;; GOOD — fetches only instances with detailed monitoring (typically few):\n(import :gerbil-aws/ec2/instances :gerbil-aws/ec2/api)\n(let* ((ec2 (EC2Client region: \"us-east-1\"))\n       (reservations (describe-instances ec2\n                       filters: '((\"monitoring-state\" \"enabled\")))))\n  ;; Count instances directly — no need to check monitoring.state\n  (let ((count 0))\n    (for-each\n     (lambda (res)\n       (let ((instances (hash-ref res 'instancesSet [])))\n         (set! count (+ count (if (list? instances) (length instances) 0)))))\n     reservations)\n    count))\n;; This avoids loading full instance metadata for potentially thousands\n;; of running instances when you only need the few with detailed monitoring.",
    "notes": "The \"monitoring-state\" filter is a standard EC2 DescribeInstances filter that returns only instances matching the given monitoring state (\"enabled\" or \"disabled\"). Using this instead of \"instance-state-name\" + manual filtering reduces API response size from potentially hundreds of MBs (all running instances with full metadata) to KBs (just the few with detailed monitoring). Remember that instancesSet may be \"\" (empty string) instead of [] for empty XML elements — always guard with (list? ...) check.",
    "related": [
      "ec2-lowercase-camelcase-keys",
      "ec2-empty-tagset-string"
    ]
  },
  {
    "id": "ec2-paginated-query-with-action-hash",
    "title": "Paginate EC2 API calls using ec2-action/hash to avoid OOM",
    "tags": [
      "ec2",
      "pagination",
      "nextToken",
      "ec2-action/hash",
      "memory",
      "describe-instances",
      "MaxResults"
    ],
    "imports": [
      ":gerbil-aws/ec2/api"
    ],
    "code": ";; PROBLEM: gerbil-aws high-level functions like describe-instances use\n;; ec2-action/items, which returns only the extracted items list and\n;; DISCARDS the NextToken from the response. This means ALL results\n;; are fetched in a single API call with no pagination.\n;;\n;; For large accounts (thousands of instances), this loads hundreds of\n;; MB of instance metadata into memory at once, causing OOM.\n;;\n;; SOLUTION: Use ec2-action/hash directly to get the full response\n;; hash including nextToken, and paginate manually.\n\n(import :gerbil-aws/ec2/api)\n\n;; Example: count instances with detailed monitoring, paginated\n(def (count-detailed-monitoring ec2)\n  (let loop ((next-token #f) (count 0))\n    (let* ((result (ec2-action/hash ec2 \"DescribeInstances\"\n                     (append\n                       [[\"MaxResults\" :: \"50\"]\n                        [\"Filter.1.Name\" :: \"monitoring-state\"]\n                        [\"Filter.1.Value.1\" :: \"enabled\"]]\n                       (if next-token [[\"NextToken\" :: next-token]] []))))\n           ;; reservationSet is a list of reservation hashes (EC2 uses lowercase)\n           (reservations (let ((rs (hash-get result 'reservationSet)))\n                           (if (list? rs) rs [])))\n           ;; Count instances across all reservations in this page\n           (page-count (let pc ((res reservations) (n 0))\n                         (if (null? res) n\n                           (let ((is (hash-get (car res) 'instancesSet)))\n                             (pc (cdr res) (+ n (if (list? is) (length is) 0)))))))\n           (new-count (+ count page-count))\n           ;; EC2 uses lowercase 'nextToken (not 'NextToken)\n           (nt (hash-get result 'nextToken)))\n      (if (and (string? nt) (> (string-length nt) 0))\n        (loop nt new-count)\n        new-count))))\n\n;; KEY POINTS:\n;; - ec2-action/hash returns the FULL response as a hash, including nextToken\n;; - EC2 uses lowercase camelCase keys: 'nextToken, 'reservationSet, 'instancesSet\n;; - MaxResults limits items per page (5-1000 for DescribeInstances)\n;; - Filter params use dot notation: Filter.N.Name, Filter.N.Value.M\n;; - Always check (list? ...) for set fields — empty XML elements become \"\"\n;; - Only accumulate what you need (counts, IDs) — let each page be GC'd",
    "notes": "The high-level describe-instances function uses ec2-action/items which extracts items from a specific XML tag but discards the rest of the response (including nextToken). This makes pagination impossible through the high-level API. You MUST drop down to ec2-action/hash for paginated queries. The same pattern applies to all EC2 Describe* operations. Remember EC2 uses lowercase camelCase keys (nextToken not NextToken), unlike CloudWatch which uses PascalCase.",
    "related": [
      "ec2-lowercase-camelcase-keys",
      "ec2-empty-tagset-string",
      "ec2-monitoring-state-filter"
    ]
  },
  {
    "id": "cloudwatch-paginated-describe-alarms",
    "title": "Paginate CloudWatch DescribeAlarms using cw-action/hash",
    "tags": [
      "cloudwatch",
      "pagination",
      "NextToken",
      "cw-action/hash",
      "describe-alarms",
      "MaxRecords",
      "memory"
    ],
    "imports": [
      ":gerbil-aws/cloudwatch/api"
    ],
    "code": ";; PROBLEM: The describe-alarms function in :gerbil-aws/cloudwatch/operations\n;; uses cw-action/hash internally but only returns MetricAlarms and\n;; CompositeAlarms — it DISCARDS the NextToken. No pagination possible.\n;;\n;; SOLUTION: Use cw-action/hash directly to paginate.\n\n(import :gerbil-aws/cloudwatch/api)\n\n;; Helper to unwrap CloudWatch member-list structures\n(def (cw-member-list raw)\n  (cond\n    ((not raw) [])\n    ((list? raw) raw)\n    ((hash-table? raw)\n     (let ((m (hash-get raw 'member)))\n       (cond ((list? m) m) ((not m) []) (else [m]))))\n    (else [])))\n\n;; Example: count alarms by type across all pages\n(def (count-alarms-by-type cw)\n  (let loop ((next-token #f) (std 0) (hires 0) (comp 0))\n    (let* ((full-hash (cw-action/hash cw \"DescribeAlarms\"\n                        (append\n                          [[\"MaxRecords\" :: \"100\"]]\n                          (if next-token [[\"NextToken\" :: next-token]] []))))\n           ;; CloudWatch wraps response in DescribeAlarmsResult\n           (result (or (hash-get full-hash 'DescribeAlarmsResult) full-hash))\n           (result (if (hash-table? result) result (hash)))\n           (metric-alarms (cw-member-list (hash-get result 'MetricAlarms)))\n           (composite-alarms (cw-member-list (hash-get result 'CompositeAlarms)))\n           ;; Count standard vs high-resolution metric alarms\n           (page-std 0) (page-hires 0))\n      (for-each\n       (lambda (a)\n         (if (and (hash-table? a)\n                  (< (string->number (hash-ref a 'Period \"60\")) 60))\n           (set! page-hires (+ page-hires 1))\n           (set! page-std (+ page-std 1))))\n       metric-alarms)\n      (let ((new-std (+ std page-std))\n            (new-hires (+ hires page-hires))\n            (new-comp (+ comp (length composite-alarms)))\n            ;; CloudWatch uses PascalCase 'NextToken (not lowercase)\n            (nt (hash-get result 'NextToken)))\n        (if (and (string? nt) (> (string-length nt) 0))\n          (loop nt new-std new-hires new-comp)\n          (values new-std new-hires new-comp))))))\n\n;; KEY POINTS:\n;; - cw-action/hash returns full response; navigate to 'DescribeAlarmsResult\n;; - CloudWatch uses PascalCase: 'NextToken, 'MetricAlarms, 'Period\n;; - MetricAlarms/CompositeAlarms use &lt;member&gt; tags — use cw-member-list helper\n;; - MaxRecords limits alarms per page (1-100, default 50)",
    "notes": "CloudWatch Query API uses PascalCase keys (NextToken, MetricAlarms) unlike EC2 which uses lowercase camelCase (nextToken, reservationSet). The DescribeAlarmsResult wrapper must be navigated to before accessing alarms. The member-list extraction is needed because CloudWatch XML uses member elements instead of item elements, and sxml->hash only auto-unwraps item elements.",
    "related": [
      "normalize-xml-member-list",
      "ec2-paginated-query-with-action-hash",
      "ec2-lowercase-camelcase-keys"
    ]
  },
  {
    "id": "aws-sxml-lightweight-counting",
    "title": "Use raw SXML (cw-action/ec2-action) instead of hash conversion for memory-efficient counting",
    "tags": [
      "sxml",
      "memory",
      "optimization",
      "cw-action",
      "ec2-action",
      "cloudwatch",
      "ec2",
      "hash-table",
      "count",
      "strip-ns"
    ],
    "imports": [
      ":gerbil-aws/cloudwatch/api",
      ":gerbil-aws/ec2/api",
      ":gerbil-aws/aws/xml"
    ],
    "code": ";; PROBLEM: cw-action/hash and ec2-action/hash parse the ENTIRE XML response\n;; into deeply nested hash tables via sxml->hash. For DescribeAlarms with\n;; 100 alarms (each with 25+ fields), this creates thousands of hash table\n;; entries per page — but you may only need a count or one field.\n;;\n;; SOLUTION: Use cw-action / ec2-action (raw SXML) and navigate the tree\n;; directly with strip-ns + sxml-items + sxml-text from :gerbil-aws/aws/xml.\n;; No hash tables are allocated per-object.\n\n(import :gerbil-aws/cloudwatch/api\n        :gerbil-aws/ec2/api\n        (only-in :gerbil-aws/aws/xml strip-ns sxml-items sxml-text))\n\n;; Helper: navigate past *TOP* to the response element\n(def (sxml-unwrap-top sxml)\n  (if (and (pair? sxml) (eq? (car sxml) '*TOP*))\n    (let loop ((children (cdr sxml)))\n      (cond\n        ((null? children) sxml)\n        ((and (pair? (car children))\n              (symbol? (caar children))\n              (not (memq (caar children) '(@ *NAMESPACES* *PI*))))\n         (car children))\n        (else (loop (cdr children)))))\n    sxml))\n\n;; Helper: find first direct child by tag (handles namespace prefixes)\n(def (sxml-child node tag)\n  (and (pair? node)\n       (let loop ((children (cdr node)))\n         (cond\n           ((null? children) #f)\n           ((and (pair? (car children))\n                 (symbol? (caar children))\n                 (eq? (strip-ns (caar children)) tag))\n            (car children))\n           (else (loop (cdr children)))))))\n\n;; Helper: get text of a named child\n(def (sxml-child-text node tag)\n  (let ((child (sxml-child node tag)))\n    (and child (sxml-text child))))\n\n;; Example: count CloudWatch alarms by type from raw SXML\n;; (cw-action returns SXML, NOT hash tables)\n(def (count-alarms-page cw next-token)\n  (let* ((sxml (cw-action cw \"DescribeAlarms\"\n                 (append [[\"MaxRecords\" :: \"100\"]]\n                         (if next-token [[\"NextToken\" :: next-token]] []))))\n         (resp (sxml-unwrap-top sxml))\n         (result (or (sxml-child resp 'DescribeAlarmsResult) resp))\n         ;; sxml-items finds <member> children (CW uses member, EC2 uses item)\n         (ma (sxml-child result 'MetricAlarms))\n         (members (if ma (sxml-items ma 'member) []))\n         (ca (sxml-child result 'CompositeAlarms))\n         (composites (if ca (sxml-items ca 'member) [])))\n    ;; Only extract Period — no hash tables built for each alarm\n    (let ((std 0) (hires 0))\n      (for-each (lambda (m)\n                  (let ((p (sxml-child-text m 'Period)))\n                    (if (and p (< (string->number p) 60))\n                      (set! hires (+ hires 1))\n                      (set! std (+ std 1)))))\n                members)\n      (values std hires (length composites)\n              (sxml-child-text result 'NextToken)))))\n\n;; Example: count EC2 instances from raw SXML\n;; (ec2-action returns SXML; EC2 uses 'item not 'member)\n(def (count-instances-page ec2 next-token)\n  (let* ((sxml (ec2-action ec2 \"DescribeInstances\"\n                 (append [[\"MaxResults\" :: \"50\"]\n                          [\"Filter.1.Name\" :: \"monitoring-state\"]\n                          [\"Filter.1.Value.1\" :: \"enabled\"]]\n                         (if next-token [[\"NextToken\" :: next-token]] []))))\n         (resp (sxml-unwrap-top sxml))\n         (res-set (sxml-child resp 'reservationSet))\n         ;; sxml-items default tag is 'item (EC2 convention)\n         (reservations (if res-set (sxml-items res-set) [])))\n    (let ((count (let loop ((res reservations) (n 0))\n                   (if (null? res) n\n                     (let ((is (sxml-child (car res) 'instancesSet)))\n                       (loop (cdr res)\n                             (+ n (if is (length (sxml-items is)) 0))))))))\n      (values count (sxml-child-text resp 'nextToken)))))",
    "notes": "Key insight: cw-action/hash and ec2-action/hash call sxml->hash which recursively creates make-hash-table + hash-put! for EVERY XML element. For responses with 100+ objects (alarms, instances), this is the dominant memory cost. Using the raw SXML APIs (cw-action, ec2-action) and navigating with strip-ns/sxml-items/sxml-text avoids all hash allocation.\n\nImportant details:\n- CloudWatch XML uses <member> elements: (sxml-items container 'member)\n- EC2 XML uses <item> elements: (sxml-items container) — default tag is 'item\n- CloudWatch uses PascalCase tags: 'DescribeAlarmsResult, 'NextToken, 'Period\n- EC2 uses lowercase camelCase: 'reservationSet, 'instancesSet, 'nextToken\n- strip-ns handles both full URI namespaces (CloudWatch) and short prefixes (ec2:)\n- sxml-text only works for (tag \"text\") leaf elements — exactly 2 elements\n- sxml-items uses strip-ns internally, so namespace handling is automatic\n- Semaphore concurrency should be reduced when using this pattern (less memory headroom needed but still good practice)",
    "related": [
      "paginate-ec2-action-hash",
      "sxml-skip-pi-nodes",
      "parse-xml-to-sxml",
      "ec2-lowercase-camelcase-keys"
    ]
  },
  {
    "id": "serialize-regions-gc-bound-memory",
    "title": "Serialize multi-region AWS calls with GC to bound peak memory",
    "tags": [
      "memory",
      "GC",
      "sequential",
      "region",
      "OOM",
      "serialize",
      "paginate",
      "page-size",
      "aws"
    ],
    "imports": [],
    "code": ";; PROBLEM: Processing all AWS regions concurrently with semaphore/threads\n;; causes OOM when each region produces large SXML trees (e.g., DescribeAlarms\n;; with 100 records/page, DescribeInstances with 50 full instance records).\n;; Even with raw SXML (no hash conversion), 2+ concurrent regions parsing\n;; large XML responses can exhaust memory before GC runs.\n;;\n;; SOLUTION: Three combined techniques:\n;; 1. Process regions sequentially (for-each, no threads/semaphore)\n;; 2. Use small page sizes (MaxRecords 25, MaxResults 10)\n;; 3. Force GC between phases and after each region\n\n;; BEFORE (OOM-prone):\n;; (let ((sem (make-semaphore 2)))\n;;   (for-each\n;;    (lambda (region)\n;;      (semaphore-wait! sem)\n;;      (spawn (lambda ()\n;;        (try\n;;          (do-alarms region)       ;; large SXML\n;;          (do-dashboards region)   ;; more SXML\n;;          (do-instances region)    ;; huge SXML (full instance details)\n;;          (finally (semaphore-post! sem))))))\n;;    regions))\n\n;; AFTER (memory-bounded):\n(def (process-all-regions regions)\n  (let ((total-count 0))\n    (for-each\n     (lambda (region)\n       (try\n        ;; Phase 1: alarms (small pages)\n        (let loop ((next-token #f))\n          (let* ((sxml (api-call region \"DescribeAlarms\"\n                         [[\"MaxRecords\" :: \"25\"]]))  ;; was 100\n                 (count (count-items sxml))\n                 (nt (extract-next-token sxml)))\n            (set! total-count (+ total-count count))\n            (when nt (loop nt))))\n        (##gc)  ;; free alarm SXML before next phase\n\n        ;; Phase 2: instances (very small pages — response includes\n        ;; ALL instance attributes: security groups, network interfaces,\n        ;; block devices, tags, etc.)\n        (let loop ((next-token #f))\n          (let* ((sxml (api-call region \"DescribeInstances\"\n                         [[\"MaxResults\" :: \"10\"]]))  ;; was 50\n                 (count (count-items sxml))\n                 (nt (extract-next-token sxml)))\n            (set! total-count (+ total-count count))\n            (when nt (loop nt))))\n\n        (catch (e) (handle-error region e))\n        (finally (##gc))))  ;; free everything before next region\n     regions)\n    total-count))\n\n;; WHY SMALL PAGES MATTER:\n;; - DescribeInstances returns FULL instance details for each instance\n;;   (security groups, network interfaces, block devices, tags, etc.)\n;;   A single instance can be 50+ SXML elements.\n;; - MaxResults=50 → ~2500 SXML elements per page\n;; - MaxResults=10 → ~500 SXML elements per page (5x less peak memory)\n;; - More API calls, but each page is GC-friendly\n;;\n;; TRADEOFF: Sequential is slower than concurrent, but won't OOM.\n;; For counting/aggregation tasks, correctness > speed.",
    "notes": "This pattern applies when you only need aggregated results (counts, sums) from AWS API responses, not the full data. The key insight is that DescribeInstances responses are disproportionately large because they include ALL instance attributes even when you only need a count. Reducing MaxResults from 50 to 10 cuts peak SXML memory ~5x per page. Combined with sequential processing and GC between phases, this bounds memory to roughly one small page worth of SXML at a time. If you need the actual data (not just counts), consider processing each page immediately and discarding the SXML before fetching the next page.",
    "related": [
      "force-gc-gambit",
      "sxml-counting-raw",
      "paginate-ec2-action-hash"
    ]
  },
  {
    "id": "memory-snapshot-profiling",
    "title": "Memory snapshot profiling with RSS + GC heap stats",
    "tags": [
      "memory",
      "profiling",
      "debug",
      "heap",
      "RSS",
      "VmRSS",
      "gc",
      "leak",
      "snapshot"
    ],
    "imports": [
      ":std/debug/heap",
      ":std/format"
    ],
    "code": ";; Complete memory profiling utility that combines:\n;; 1. OS-level RSS from /proc/self/status (actual process memory)\n;; 2. GC heap stats from :std/debug/heap memory-usage\n;;\n;; Returns an alist: ((gc-heap-size . N) (gc-alloc . N) (gc-live . N)\n;;                    (gc-movable . N) (gc-still . N))\n\n(import :std/debug/heap :std/format)\n\n;; Get VmRSS from /proc/self/status (Linux only)\n(def (get-rss-kb)\n  (try\n    (call-with-input-file \"/proc/self/status\"\n      (lambda (port)\n        (let loop ((line (read-line port)))\n          (if (eof-object? line) 0\n            (if (and (>= (string-length line) 6)\n                     (string=? \"VmRSS:\" (substring line 0 6)))\n              ;; Parse the number from \"VmRSS:   12345 kB\"\n              (let find-num ((i 6))\n                (cond\n                  ((>= i (string-length line)) 0)\n                  ((char-numeric? (string-ref line i))\n                   (let end-num ((j (+ i 1)))\n                     (if (or (>= j (string-length line))\n                             (not (char-numeric? (string-ref line j))))\n                       (string->number (substring line i j))\n                       (end-num (+ j 1)))))\n                  (else (find-num (+ i 1)))))\n              (loop (read-line port)))))))\n    (catch (e) 0)))\n\n;; Print + return memory snapshot\n(def (mem-snapshot label)\n  (let* ((rss-kb (get-rss-kb))\n         (rss-mb (/ rss-kb 1024.0))\n         (heap (memory-usage))\n         (gc-heap-mb (/ (cdr (assoc 'gc-heap-size heap)) (* 1024.0 1024.0)))\n         (gc-live-mb (/ (cdr (assoc 'gc-live heap)) (* 1024.0 1024.0))))\n    (fprintf (current-error-port)\n             \"[MEM ~a] RSS=~aMB | GC-heap=~aMB live=~aMB~n\"\n             label\n             (number->string (inexact->exact (round rss-mb)))\n             (number->string (inexact->exact (round gc-heap-mb)))\n             (number->string (inexact->exact (round gc-live-mb))))\n    (force-output (current-error-port))\n    (list (cons 'rss-kb rss-kb) (cons 'rss-mb rss-mb)\n          (cons 'gc-heap-mb gc-heap-mb) (cons 'gc-live-mb gc-live-mb))))\n\n;; Print delta from previous snapshot\n(def (mem-delta label prev)\n  (let* ((snap (mem-snapshot label))\n         (d-rss (- (cdr (assoc 'rss-mb snap)) (cdr (assoc 'rss-mb prev))))\n         (d-live (- (cdr (assoc 'gc-live-mb snap)) (cdr (assoc 'gc-live-mb prev)))))\n    (fprintf (current-error-port)\n             \"[MEM-DELTA ~a] RSS=~a~aMB live=~a~aMB~n\"\n             label\n             (if (>= d-rss 0) \"+\" \"-\") (number->string (inexact->exact (round (abs d-rss))))\n             (if (>= d-live 0) \"+\" \"-\") (number->string (inexact->exact (round (abs d-live)))))\n    (force-output (current-error-port))\n    snap))\n\n;; Usage: wrap suspect sections\n;; (let ((s (mem-snapshot \"before-heavy-work\")))\n;;   (heavy-work)\n;;   (mem-delta \"after-heavy-work\" s)\n;;   (##gc)\n;;   (mem-delta \"after-gc\" s))",
    "notes": "memory-usage from :std/debug/heap returns an alist with keys: gc-heap-size, gc-alloc, gc-live, gc-movable, gc-still (all in bytes). The gc-live value shows how much memory is actually retained after GC. RSS from /proc/self/status shows the OS-level resident set — this includes memory that Gambit has allocated from the OS but may not have returned yet (the GC heap can grow but rarely shrinks). Output goes to stderr via current-error-port so it doesn't pollute stdout. The :std/debug/heap import triggers some Gambit warnings about undefined variables (macro-slot, macro-will-action, macro-will-testator) — these are harmless and can be ignored.",
    "related": [
      "force-gc-gambit",
      "serialize-multi-region-gc"
    ]
  },
  {
    "id": "run-standalone-script-with-project-imports",
    "title": "Run standalone gxi script that imports project modules",
    "tags": [
      "gxi",
      "script",
      "standalone",
      "import",
      "GERBIL_LOADPATH",
      "package",
      "relative",
      "module context"
    ],
    "imports": [],
    "code": ";; PROBLEM: You have a standalone test/utility script that needs to\n;; import modules from your project. Relative imports fail:\n;;\n;;   ;; test-script.ss\n;;   (import ./aws ./resources)  ;; FAILS!\n;;   ;; Error: \"cannot resolve relative module path; not in module context\"\n;;\n;; Relative imports (./module) only work inside a module being compiled\n;; as part of a build. When running a .ss file directly with `gxi`,\n;; the file is NOT in a module context.\n;;\n;; SOLUTION: Use package-qualified imports and set GERBIL_LOADPATH.\n;;\n;; Given a project with gerbil.pkg:\n;;   (package: my-project)\n;;\n;; And modules: aws.ss, resources.ss, etc.\n\n;; test-script.ss — correct way:\n;; (import :my-project/aws\n;;         :my-project/resources\n;;         :my-project/pricing)\n;;\n;; Run with GERBIL_LOADPATH pointing to the project's compiled libs:\n;;   GERBIL_LOADPATH=.gerbil/lib gxi test-script.ss\n;;\n;; Or with absolute path:\n;;   GERBIL_LOADPATH=/path/to/project/.gerbil/lib gxi test-script.ss\n;;\n;; If the project also depends on external packages:\n;;   GERBIL_LOADPATH=/path/to/project/.gerbil/lib:~/.gerbil/lib gxi test-script.ss\n\n;; IMPORTANT: The project must be built first (`gerbil build` or `make`)\n;; so that .gerbil/lib/ contains the compiled module files.\n\n;; Full example — standalone memory test script:\n;; #!/usr/bin/env gxi\n;; (import :std/format\n;;         :std/debug/heap\n;;         :my-project/aws\n;;         :my-project/resources)\n;;\n;; (def (main . args)\n;;   (let ((snap (mem-snapshot \"START\")))\n;;     (get-resources)\n;;     (mem-delta \"END\" snap)))\n;;\n;; (apply main (cdr (command-line)))",
    "notes": "Key points: (1) ./module syntax ONLY works inside compiled modules, not standalone gxi scripts. (2) Use :package/module paths matching your gerbil.pkg package: declaration. (3) GERBIL_LOADPATH must include the project's .gerbil/lib/ directory. (4) The project must be built first so compiled modules exist. (5) Multiple LOADPATH entries are colon-separated. (6) For CLI scripts, use (command-line) to get args and (apply main (cdr (command-line))) to invoke.",
    "related": [
      "gerbil-build-loadpath"
    ]
  },
  {
    "id": "resolve-import-naming-conflicts",
    "title": "Resolve naming conflicts when importing modules with only-in/except-in",
    "tags": [
      "import",
      "only-in",
      "except-in",
      "conflict",
      "naming",
      "duplicate",
      "shadow",
      "string-split",
      "string-prefix"
    ],
    "imports": [],
    "code": ";; PROBLEM: Your module defines a function that has the same name as\n;; something exported by a standard library module you want to import.\n;;\n;; Example: Your aws.ss defines its own string-split and string-prefix?\n;; but you also want to import :std/misc/string for other utilities.\n;;\n;; WRONG — duplicate definition error:\n;; (import :std/misc/string)  ;; exports string-split, string-prefix?, etc.\n;; (def (string-split s sep) ...)  ;; CONFLICT! already imported\n;;\n;; SOLUTION 1: Use only-in to import specific non-conflicting symbols\n;; (import (only-in :std/misc/string\n;;           string-trim-prefix\n;;           string-trim-suffix\n;;           string-trim-eol))\n;;\n;; SOLUTION 2: Use except-in to exclude conflicting symbols\n;; (import (except-in :std/misc/string\n;;           string-split\n;;           string-prefix?))\n;;\n;; SOLUTION 3: Use prefix-in to namespace all imports\n;; (import (prefix-in str: :std/misc/string))\n;; ;; Now use str:string-split, str:string-prefix?, etc.\n;; ;; Your own string-split is unaffected\n;;\n;; SOLUTION 4: Skip the import entirely if you only need the\n;; conflicting symbols and already have local implementations.\n;; This is the simplest approach when the overlap is large.\n;;\n;; SOLUTION 5: Use rename-in to rename specific conflicting imports\n;; (import (rename-in :std/misc/string\n;;           (string-split std-string-split)\n;;           (string-prefix? std-string-prefix?)))\n;; ;; Now both versions available under different names\n\n;; CHECKING what a module exports before importing:\n;; Use gerbil_module_exports MCP tool, or in the REPL:\n;;   (import :std/misc/string)\n;;   ;; then check which names appeared",
    "notes": "Common conflict sources: (1) :std/misc/string exports string-split, string-prefix?, string-suffix? which many projects define locally. (2) :std/srfi/1 exports map, for-each, filter etc. which shadow Gerbil's built-ins. (3) :std/iter exports for which shadows Gerbil's for (though they're usually compatible). Always use gerbil_module_exports to check what a module exports BEFORE importing it. The only-in approach is safest — you explicitly list what you need and won't get surprise conflicts if the upstream module adds new exports.",
    "related": [
      "export-t-no-reexport"
    ]
  },
  {
    "id": "def-self-shadow-infinite-recursion",
    "title": "Local def shadows imported/intended function — causes infinite recursion",
    "tags": [
      "shadow",
      "def",
      "infinite recursion",
      "SIGSEGV",
      "stack overflow",
      "self-call",
      "gotcha"
    ],
    "imports": [
      ":std/error"
    ],
    "code": ";; PROBLEM: Defining a function with the same name as one you intend to call\n;; creates accidental infinite recursion. The local def shadows any import.\n;;\n;; WRONG — infinite recursion, manifests as SIGSEGV (stack overflow):\n;; (def (exception->string e)\n;;   (or (exception->string e)   ;; calls ITSELF, not some library function\n;;       (call-with-output-string (lambda (p) (display-exception e p)))))\n;;\n;; The author likely intended to call a library's exception->string first,\n;; then fall back. But no such function exists in Gerbil's stdlib, and\n;; even if it did, the local def would shadow it.\n;;\n;; This causes SIGSEGV because:\n;; 1. An exception occurs somewhere (e.g., API error)\n;; 2. A catch block calls exception->string\n;; 3. The function calls itself infinitely\n;; 4. Stack overflow hits the guard page → SIGSEGV\n;; 5. GDB may report the crash in a DIFFERENT module's code\n;;    (wherever the stack pointer lands)\n\n;; CORRECT — use type-dispatch, never self-reference unless intended:\n(def (exception->string e)\n  (cond\n    ((Error? e) (Error-message e))              ;; Gerbil Error struct\n    ((error-exception? e)                        ;; Gambit error-exception\n     (error-exception-message e))\n    (else                                        ;; everything else\n     (call-with-output-string\n       (lambda (p) (display-exception e p))))))\n\n;; GENERAL RULE: In Gerbil, a top-level (def (foo ...) ...) in a module\n;; creates a binding for 'foo' that shadows ANY imported 'foo'.\n;; If you call 'foo' inside the body of that def, you call YOURSELF.\n;; There is no way to \"fall through\" to the imported version.\n;;\n;; If you need the imported version, rename on import:\n;; (import (rename-in :some-lib (foo lib-foo)))\n;; (def (foo e)\n;;   (or (lib-foo e)  ;; calls the imported version\n;;       (fallback e)))",
    "notes": "This is a subtle bug because: (1) it compiles without warning, (2) it only crashes when the code path is actually hit (e.g., when an exception is caught), (3) the SIGSEGV crash location in GDB may point to a completely different module due to how stack overflow works in compiled Gambit code. The key diagnostic clue is a SIGSEGV during exception handling. Always check that your catch-block helper functions don't accidentally recurse.",
    "related": [
      "error-message-returns-false",
      "error-handling"
    ]
  },
  {
    "id": "hash-list-to-json-consumer-gotcha",
    "title": "After converting alist pairs to hashes for JSON, consumers must use hget not car/cdr",
    "tags": [
      "hash",
      "json",
      "car",
      "cdr",
      "hget",
      "alist",
      "pair",
      "write-json",
      "read-json",
      "consume",
      "iterate"
    ],
    "imports": [
      ":std/text/json",
      ":std/sort"
    ],
    "code": ";; SCENARIO: You have hash->list pairs that you convert to hashes for JSON\n;; serialization (as required by write-json), but the code that reads\n;; them back still uses car/cdr — causing \"PAIR expected\" errors.\n\n;; === DATA PRODUCTION (correct) ===\n;; Convert alist pairs to hashes for write-json compatibility:\n(def service-totals (hash (\"EC2\" 5000) (\"S3\" 2000) (\"RDS\" 1500)))\n(def sorted (sort (hash->list service-totals)\n                  (lambda (a b) (> (cdr a) (cdr b)))))\n;; sorted = ((\"EC2\" . 5000) (\"S3\" . 2000) (\"RDS\" . 1500))\n\n;; Convert for JSON:\n(def top-services\n  (map (lambda (p) (hash (\"service\" (car p)) (\"cost\" (cdr p))))\n       sorted))\n;; top-services = list of hash tables\n\n;; === DATA CONSUMPTION (the gotcha) ===\n\n;; WRONG — crashes with \"PAIR expected\" because items are hash tables:\n;; (for (item top-services)\n;;   (let ((svc (car item)) (cost (cdr item)))  ;; ERROR!\n;;     (displayln svc \": \" cost)))\n\n;; CORRECT — use hget to access hash table fields:\n(for (item top-services)\n  (let ((svc (hash-ref item \"service\" \"Unknown\"))\n        (cost (hash-ref item \"cost\" 0)))\n    (displayln svc \": \" cost)))\n;; EC2: 5000\n;; S3: 2000\n;; RDS: 1500",
    "notes": "This is the follow-on bug from the \"write-json cannot serialize cons pairs\" recipe. After you fix JSON serialization by converting (hash->list) pairs to hash tables, ALL consumer code must be updated from car/cdr to hget/hash-ref. The error message is: \"PAIR expected (car '#&lt;HashTable #N&gt;)\". The backtrace will show car being called on a hash table. Common in report/display code that was written when data was still alist pairs.",
    "related": [
      "write-json-cons-pair-error",
      "gerbil-json-arrays-are-lists-not-vectors",
      "hash-table-basics"
    ]
  },
  {
    "id": "debounce-thread-pattern",
    "title": "Debounce pattern with thread-sleep! and thread-terminate!",
    "tags": [
      "debounce",
      "thread",
      "timer",
      "cancel",
      "sleep",
      "spawn"
    ],
    "imports": [],
    "code": ";; Debounce pattern: cancel previous timer, start new one.\n;; Useful for running expensive operations after a quiet period.\n\n(def *debounce-thread* #f)\n(def *debounce-mutex* (make-mutex 'debounce))\n\n(def (schedule-debounced! delay-ms action)\n  (mutex-lock! *debounce-mutex*)\n  ;; Cancel previous debounce thread if running\n  (let ((prev *debounce-thread*))\n    (when prev\n      (with-catch (lambda (e) (void))\n        (lambda () (thread-terminate! prev)))))\n  ;; Spawn new timer thread\n  (let ((t (spawn\n              (lambda ()\n                (with-catch\n                  (lambda (e) (void))  ;; silently handle termination\n                  (lambda ()\n                    (thread-sleep! (/ delay-ms 1000.0))\n                    (action)))))))\n    (set! *debounce-thread* t))\n  (mutex-unlock! *debounce-mutex*))\n\n(def (cancel-debounce!)\n  (mutex-lock! *debounce-mutex*)\n  (let ((prev *debounce-thread*))\n    (when prev\n      (with-catch (lambda (e) (void))\n        (lambda () (thread-terminate! prev)))\n      (set! *debounce-thread* #f)))\n  (mutex-unlock! *debounce-mutex*))\n\n;; Usage:\n;; (schedule-debounced! 1500 (lambda () (run-expensive-task)))\n;; (cancel-debounce!)  ;; cancels if still pending",
    "notes": "thread-terminate! on a thread that already exited throws an exception, so always wrap in with-catch. The debounce thread gets terminated when a new event arrives before the delay expires. thread-sleep! accepts seconds as a real number, so divide milliseconds by 1000.0.",
    "related": [
      "mutex-unwind-protect"
    ]
  },
  {
    "id": "open-process-capture-output",
    "title": "Run external process and capture stdout+stderr with exit status",
    "tags": [
      "process",
      "open-process",
      "spawn",
      "capture",
      "stdout",
      "stderr",
      "exit-status"
    ],
    "imports": [
      ":std/misc/ports"
    ],
    "code": "(import :std/misc/ports)\n\n;; Use open-process (not run-process) when you need to read output\n;; from a command that may exit non-zero. run-process throws on\n;; non-zero exit, but open-process lets you read output first.\n\n(let* ((proc (open-process\n               (list path: \"gerbil\"\n                     arguments: (list \"test\" \"myfile.ss\")\n                     stderr-redirection: #t    ;; merge stderr into stdout\n                     stdout-redirection: #t)))\n       (output (read-all-as-string proc))\n       (status (process-status proc)))\n  ;; status is raw waitpid value: 0 = success, non-zero = failure\n  (if (= status 0)\n    (displayln \"Success: \" output)\n    (displayln \"Failed with status \" status \": \" output)))",
    "notes": "process-status returns the raw waitpid status. Normal exit code N gives N*256 for Gambit's open-process, but in practice checking (= status 0) vs non-zero works. stderr-redirection: #t merges stderr into stdout so read-all-as-string captures both. Use run-process from :std/misc/process when you want automatic exception on failure.",
    "related": [
      "spawn-threads"
    ]
  },
  {
    "id": "u8vector-character-classifier",
    "title": "Classify string characters into categories using u8vector",
    "tags": [
      "u8vector",
      "classify",
      "string",
      "character",
      "scanner",
      "lexer",
      "parser"
    ],
    "imports": [],
    "code": ";; Pattern: Use a u8vector parallel to a string to classify each\n;; character position (e.g., code=0, string=1, comment=2).\n;; Much faster than re-scanning for each query.\n\n(def (classify-chars text)\n  (let* ((len (string-length text))\n         (regions (make-u8vector len 0)))  ;; default: 0 = code\n    ;; Walk through text, setting classification\n    (let loop ((i 0))\n      (when (< i len)\n        (let ((c (string-ref text i)))\n          (cond\n            ;; String literal: mark all chars as 1\n            ((char=? c #\\\")\n             (u8vector-set! regions i 1)\n             (let str-loop ((j (+ i 1)))\n               (if (>= j len) (loop j)\n                 (let ((sc (string-ref text j)))\n                   (u8vector-set! regions j 1)\n                   (cond\n                     ((char=? sc #\\\\)  ;; skip escape\n                      (when (< (+ j 1) len)\n                        (u8vector-set! regions (+ j 1) 1))\n                      (str-loop (+ j 2)))\n                     ((char=? sc #\\\") (loop (+ j 1)))\n                     (else (str-loop (+ j 1))))))))\n            ;; Line comment: mark rest of line as 2\n            ((char=? c #\\;)\n             (let cmt-loop ((j i))\n               (if (or (>= j len)\n                       (char=? (string-ref text j) #\\newline))\n                 (loop j)\n                 (begin (u8vector-set! regions j 2)\n                        (cmt-loop (+ j 1))))))\n            (else (loop (+ i 1)))))))\n    regions))\n\n;; Query: check if offset is in a non-code region\n(def (in-non-code? regions offset)\n  (and (< offset (u8vector-length regions))\n       (> (u8vector-ref regions offset) 0)))\n\n;; Example:\n;; (def r (classify-chars \"(def x \\\"hi\\\") ; comment\"))\n;; (in-non-code? r 7)  ;; #t — inside string\n;; (in-non-code? r 13) ;; #t — inside comment\n;; (in-non-code? r 0)  ;; #f — code",
    "notes": "u8vector is ideal for per-character classification because it uses 1 byte per position (vs 8 bytes for a vector of fixnums). make-u8vector accepts an initial fill value. This scan-once-query-many pattern avoids O(n*m) cost when checking multiple positions against string/comment boundaries. Extend the cond for block comments (#| ... |#) with a depth counter for nesting."
  },
  {
    "id": "defstruct-positional-constructor",
    "title": "Defstruct constructors use positional args, not keywords",
    "tags": [
      "defstruct",
      "make-struct",
      "constructor",
      "positional",
      "arity",
      "keyword"
    ],
    "imports": [],
    "code": ";; WRONG: defstruct constructor does NOT accept keyword arguments\n(defstruct point (x y z) transparent: #t)\n;; (make-point x: 1 y: 2 z: 3)  ;; ERROR: arguments don't match object size\n\n;; CORRECT: use positional arguments in field order\n(make-point 1 2 3)  ;; => #<point x: 1 y: 2 z: 3>\n\n;; For structs with many fields, document the order:\n(defstruct config (host port timeout ssl debug) transparent: #t)\n;; Constructor: (make-config host port timeout ssl debug)\n(make-config \"localhost\" 8080 30 #f #t)\n\n;; If you need keyword args, use a wrapper:\n(def (make-config* host: (host \"localhost\")\n                   port: (port 80)\n                   timeout: (timeout 30)\n                   ssl: (ssl #f)\n                   debug: (debug #f))\n  (make-config host port timeout ssl debug))",
    "notes": "Gerbil's defstruct generates a make-NAME constructor that takes positional arguments in the same order as the field declaration. Keyword arguments are NOT supported. This often causes \"arguments don't match object size\" errors when trying to use keyword syntax. The wrapper pattern using def with keyword args provides a convenient alternative when needed.",
    "related": [
      "define-structs",
      "typed-struct-field-access"
    ]
  },
  {
    "id": "open-process-environment",
    "title": "Run subprocess with custom environment variables",
    "tags": [
      "open-process",
      "environment",
      "subprocess",
      "gxc",
      "GERBIL_LOADPATH",
      "spawn"
    ],
    "imports": [
      ":std/misc/ports"
    ],
    "code": ";; open-process with custom environment variables for subprocess\n(let* ((proc (open-process\n               (list path: \"gxc\"\n                     arguments: (list \"-S\" \"myfile.ss\")\n                     ;; Set environment for the subprocess\n                     environment: (list \"GERBIL_LOADPATH=/path/to/libs\"\n                                        \"HOME=/home/user\")\n                     stderr-redirection: #t\n                     stdout-redirection: #t)))\n       (output (read-all-as-string proc))\n       (status (process-status proc)))\n  (if (= status 0)\n    output\n    (error \"gxc failed\" output)))\n\n;; Common use: pass GERBIL_LOADPATH to gxc for project-local modules\n(def (run-gxc-with-loadpath file-path loadpaths)\n  (let* ((env (if (pair? loadpaths)\n                (list (string-append \"GERBIL_LOADPATH=\"\n                        (string-join loadpaths \":\")))\n                #f))\n         (proc (open-process\n                 (list path: \"gxc\"\n                       arguments: (list \"-S\" file-path)\n                       environment: env\n                       stderr-redirection: #t\n                       stdout-redirection: #t)))\n         (output (read-all-as-string proc))\n         (status (process-status proc)))\n    (values status output)))",
    "notes": "The environment: parameter takes a list of \"KEY=VALUE\" strings. If #f (default), the subprocess inherits the parent's environment. This is essential for running gxc with custom GERBIL_LOADPATH for project-local module resolution. Note: :std/misc/ports is needed for read-all-as-string.",
    "related": [
      "run-external-process",
      "gerbil-build-loadpath"
    ]
  },
  {
    "id": "atomic-json-file-cache",
    "title": "Atomic JSON file writes for caching",
    "tags": [
      "json",
      "cache",
      "atomic",
      "write",
      "persist",
      "file",
      "mtime"
    ],
    "imports": [
      ":std/text/json"
    ],
    "code": ";; Persist data to JSON file atomically (write to temp, then rename)\n(import :std/text/json)\n\n(def (save-json-atomically! file-path data)\n  (let ((temp-path (string-append file-path \".tmp\")))\n    ;; Write to temporary file\n    (call-with-output-file temp-path\n      (lambda (port)\n        (write-json data port)))\n    ;; Atomic rename\n    (rename-file temp-path file-path)))\n\n;; Load JSON with error handling\n(def (load-json-safely file-path default)\n  (if (file-exists? file-path)\n    (with-catch\n      (lambda (e) default)\n      (lambda ()\n        (call-with-input-file file-path read-json)))\n    default))\n\n;; Example: cache with modification time tracking\n(def (save-cache! cache-path items get-mtime-fn)\n  (let ((cache-data (make-hash-table)))\n    (hash-for-each\n      (lambda (key value)\n        (hash-put! cache-data key\n          (hash (\"mtime\" (get-mtime-fn key))\n                (\"data\" value))))\n      items)\n    (save-json-atomically! cache-path\n      (hash (\"version\" 1)\n            (\"items\" cache-data)))))",
    "notes": "Atomic writes prevent data corruption if the process crashes mid-write. The pattern is: write to temp file, then rename. rename-file is atomic on POSIX systems. For caches, storing modification timestamps allows detecting stale entries on reload.",
    "related": [
      "read-json-file",
      "hash-table-basics"
    ]
  },
  {
    "id": "current-second-time",
    "title": "Get current time in seconds",
    "tags": [
      "time",
      "seconds",
      "current-second",
      "current-time",
      "timestamp",
      "elapsed",
      "mtime"
    ],
    "imports": [],
    "code": ";; Get current time in seconds (floating point)\n\n;; Method 1: Gambit's current-second (simplest)\n(current-second)  ;; => 1738713852.1234567\n\n;; Method 2: Via time->seconds (more explicit)\n(time->seconds (current-time))  ;; => 1738713852.1234567\n\n;; Method 3: If SRFI-19 is imported, use ##current-time to get Gambit's version\n(import :std/srfi/19)\n(time->seconds (##current-time))  ;; => works (bypasses SRFI-19 shadow)\n\n;; WRONG: Without ##, SRFI-19 shadows current-time with incompatible type\n;; (time->seconds (current-time))  ;; ERROR after importing :std/srfi/19\n\n;; Get file modification time as seconds:\n(def (file-mtime path)\n  (time->seconds\n    (file-info-last-modification-time\n      (file-info path))))\n\n;; Measure elapsed time:\n(let ((start (current-second)))\n  (do-work)\n  (let ((elapsed (- (current-second) start)))\n    (displayln \"Took \" elapsed \" seconds\")))",
    "notes": "current-second is Gambit's built-in (no import needed). Note: it's current-second (singular), NOT current-seconds. If you import :std/srfi/19, it shadows current-time — use ##current-time to access the Gambit version. For file mtimes, use file-info + file-info-last-modification-time + time->seconds.",
    "related": [
      "srfi-19-current-time-shadows-gambit",
      "date-time-formatting-srfi-19"
    ]
  },
  {
    "id": "gambit-path-builtins",
    "title": "Gambit path manipulation builtins (path-directory, path-normalize, path-strip-directory, path-extension)",
    "tags": [
      "path",
      "directory",
      "normalize",
      "gambit",
      "builtin",
      "file",
      "basename",
      "dirname",
      "extension"
    ],
    "imports": [],
    "code": ";; Gambit provides path manipulation primitives — NO import needed.\n;; These are available in any Gerbil module automatically.\n\n;; path-directory — like dirname, returns directory portion with trailing /\n(path-directory \"/home/user/project/src/main.ss\")\n;; => \"/home/user/project/src/\"\n\n(path-directory \"src/main.ss\")\n;; => \"src/\"\n\n(path-directory \"main.ss\")\n;; => \"\"\n\n;; path-strip-directory — like basename, returns filename only\n(path-strip-directory \"/home/user/project/src/main.ss\")\n;; => \"main.ss\"\n\n;; path-strip-extension — remove file extension\n(path-strip-extension \"main.ss\")\n;; => \"main\"\n\n(path-strip-extension \"/path/to/module.ss\")\n;; => \"/path/to/module\"\n\n;; path-extension — get file extension (includes dot)\n(path-extension \"main.ss\")\n;; => \".ss\"\n\n;; path-normalize — resolve to absolute path, canonicalize . and ..\n(path-normalize \"src/../lib/module.ss\")\n;; => \"/home/user/project/lib/module.ss\"  (resolves relative to cwd)\n\n;; path-normalize with origin-directory (2nd arg)\n(path-normalize \"../other/file.ss\" \"/home/user/project/src/\")\n;; => \"/home/user/project/other/file.ss\"\n\n;; COMMON PATTERN: compute relative path between two files\n;; (useful for generating relative import paths in LSP/tooling)\n(def (compute-relative-path from-file to-file)\n  (let* ((from-dir (path-directory (path-normalize from-file)))\n         (to-norm (path-normalize to-file))\n         (to-no-ext (path-strip-extension to-norm)))\n    ;; Build relative path from from-dir to to-no-ext\n    ;; (simplified — real implementation needs directory traversal)\n    (string-append \"./\" (path-strip-directory to-no-ext))))",
    "notes": "These are Gambit primitives (##path-directory etc.) exposed as safe wrappers. No import is needed — they're always available. Key gotcha: path-directory returns trailing slash (e.g., \"src/\" not \"src\"). path-normalize resolves against cwd by default; pass a second argument to resolve against a different origin directory. These are NOT from :std/misc/path — that module provides different utilities like path-default-extension and path-force-extension.",
    "related": [
      "read-file-to-string",
      "read-file-lines"
    ]
  },
  {
    "id": "http-multipart-file-upload",
    "title": "HTTP multipart/form-data file upload",
    "tags": [
      "http",
      "multipart",
      "upload",
      "file",
      "form-data",
      "post",
      "binary",
      "attachment"
    ],
    "imports": [
      ":std/net/request",
      ":std/misc/ports",
      ":std/format"
    ],
    "code": "(import :std/net/request :std/misc/ports :std/format)\\n\\n;; Gerbil's http-post does NOT have built-in multipart support.\\n;; You must manually construct the multipart/form-data body.\\n\\n(def (http-upload-file url file-path\\n       headers: (extra-headers '())\\n       field-name: (field-name \\\"file\\\"))\\n  (let* ((boundary (format \\\"----GerbilBoundary~a\\\" (random-integer 999999999)))\\n         (filename (path-strip-directory file-path))\\n         (file-bytes (call-with-input-file file-path read-all-as-u8vector))\\n         ;; Build multipart body as string prefix + binary + string suffix\\n         (prefix (string-append\\n                   \\\"--\\\" boundary \\\"\\\\r\\\\n\\\"\\n                   (format \\\"Content-Disposition: form-data; name=\\\\\\\"~a\\\\\\\"; filename=\\\\\\\"~a\\\\\\\"\\\\r\\\\n\\\" field-name filename)\\n                   \\\"Content-Type: application/octet-stream\\\\r\\\\n\\\"\\n                   \\\"\\\\r\\\\n\\\"))\\n         (suffix (string-append \\\"\\\\r\\\\n--\\\" boundary \\\"--\\\\r\\\\n\\\"))\\n         ;; Combine into single u8vector\\n         (prefix-bytes (string->bytes prefix))\\n         (suffix-bytes (string->bytes suffix))\\n         (body (u8vector-append prefix-bytes file-bytes suffix-bytes))\\n         (content-type (format \\\"multipart/form-data; boundary=~a\\\" boundary))\\n         (all-headers (cons (cons \\\"Content-Type\\\" content-type) extra-headers)))\\n    (http-post url data: body headers: all-headers)))\\n\\n;; Example: Upload attachment to Jira\\n;; (def resp (http-upload-file\\n;;   \\\"https://your-jira.atlassian.net/rest/api/3/issue/PROJ-123/attachments\\\"\\n;;   \\\"/path/to/file.pdf\\\"\\n;;   headers: '((\\\"Authorization\\\" . \\\"Basic ...\\\") (\\\"X-Atlassian-Token\\\" . \\\"no-check\\\"))))\\n;; (request-status resp)  ;; => 200",
    "notes": "Gerbil's :std/net/request does NOT support multipart/form-data natively. You must manually construct the body with boundary delimiters, Content-Disposition headers, and binary content. The data: keyword accepts u8vector for binary data. Use u8vector-append to combine the text prefix, binary file content, and text suffix into a single body. For APIs requiring multipart upload (like Jira attachments), you may also need extra headers like X-Atlassian-Token: no-check. Alternative approach: use open-process to call curl for complex multipart needs.",
    "related": [
      "http-get",
      "http-post-json"
    ]
  },
  {
    "id": "csv-write-output",
    "title": "Write CSV output with :std/text/csv",
    "tags": [
      "csv",
      "write",
      "output",
      "table",
      "export",
      "file",
      "text"
    ],
    "imports": [
      ":std/text/csv"
    ],
    "code": "(import :std/text/csv)\\n\\n;; Write CSV to file\\n(write-csv-file \\\"output.csv\\\"\\n  '((\\\"Name\\\" \\\"Age\\\" \\\"City\\\")\\n    (\\\"Alice\\\" \\\"30\\\" \\\"NYC\\\")\\n    (\\\"Bob\\\" \\\"25\\\" \\\"LA\\\")))\\n\\n;; Write CSV to stdout\\n(write-csv-lines\\n  '((\\\"Key\\\" \\\"Summary\\\" \\\"Status\\\")\\n    (\\\"PROJ-1\\\" \\\"Fix bug\\\" \\\"Open\\\")\\n    (\\\"PROJ-2\\\" \\\"Add feature\\\" \\\"Done\\\"))\\n  (current-output-port))\\n\\n;; Write single line\\n(write-csv-line '(\\\"field1\\\" \\\"field2\\\" \\\"field3\\\") (current-output-port))\\n\\n;; All values must be strings, numbers, symbols, or #f (empty).\\n;; Fields with commas or quotes are automatically escaped.",
    "notes": "write-csv-file takes a path (or path+settings) and a list of rows. write-csv-lines and write-csv-line take a port. Default format is RFC 4180 (comma-separated, LF line endings). Fields containing commas, quotes, or newlines are automatically quoted and escaped. Non-string values should be converted with format or number->string before passing.",
    "related": [
      "read-json-file",
      "hash-table-basics"
    ]
  },
  {
    "id": "plain-text-aligned-table",
    "title": "Print aligned plain text table to stdout",
    "tags": [
      "table",
      "output",
      "align",
      "columns",
      "format",
      "display",
      "print",
      "cli"
    ],
    "imports": [
      ":std/iter",
      ":std/format",
      ":std/srfi/13"
    ],
    "code": "(import :std/iter :std/format :std/srfi/13)\\n\\n(def (print-table headers rows)\\n  \\\"Print aligned columns with header separator line.\\\"\\n  (let* ((all-rows (cons headers rows))\\n         ;; Calculate max width for each column\\n         (widths (map (lambda (col-idx)\\n                        (apply max\\n                          (map (lambda (row)\\n                                 (string-length\\n                                   (if (< col-idx (length row))\\n                                     (format \\\"~a\\\" (list-ref row col-idx))\\n                                     \\\"\\\")))\\n                               all-rows)))\\n                      (iota (length headers)))))\\n         ;; Format one row with padding\\n         (fmt-row (lambda (row)\\n                    (string-join\\n                      (map (lambda (val width)\\n                             (string-pad-right (format \\\"~a\\\" val) width))\\n                           row widths)\\n                      \\\"  \\\"))))\\n    ;; Print header\\n    (displayln (fmt-row headers))\\n    ;; Print separator\\n    (displayln (string-join (map (lambda (w) (make-string w #\\\\-)) widths) \\\"  \\\"))\\n    ;; Print rows\\n    (for (row rows)\\n      (displayln (fmt-row row)))))\\n\\n;; Example:\\n;; (print-table\\n;;   [\\\"Key\\\" \\\"Summary\\\" \\\"Status\\\"]\\n;;   [[\\\"PROJ-1\\\" \\\"Fix login bug\\\" \\\"Open\\\"]\\n;;    [\\\"PROJ-2\\\" \\\"Add search\\\" \\\"Done\\\"]])\\n;;\\n;; Output:\\n;; Key     Summary         Status\\n;; ------  --------------  ------\\n;; PROJ-1  Fix login bug   Open\\n;; PROJ-2  Add search      Done",
    "notes": "Uses string-pad-right from :std/srfi/13 for column alignment. iota from :std/srfi/1 can also be used but (iota n) works with :std/iter's for. All values are coerced to strings via (format \\\"~a\\\" val). For wide tables, consider adding a truncate-string helper: (def (trunc s n) (if (> (string-length s) n) (string-append (substring s 0 (- n 3)) \\\"...\\\") s)).",
    "related": [
      "csv-write-output"
    ]
  },
  {
    "id": "rest-api-client-pattern",
    "title": "REST API client with JSON, auth, error handling, and pagination",
    "tags": [
      "rest",
      "api",
      "client",
      "http",
      "json",
      "pagination",
      "auth",
      "basic-auth",
      "request"
    ],
    "imports": [
      ":std/net/request",
      ":std/net/uri",
      ":std/text/json",
      ":std/text/base64",
      ":std/format"
    ],
    "code": "(import :std/net/request :std/net/uri :std/text/json :std/text/base64 :std/format)\\n\\n;; Basic auth header\\n(def (make-basic-auth user password)\\n  (format \\\"Basic ~a\\\" (base64-encode (string->bytes (format \\\"~a:~a\\\" user password)))))\\n\\n;; Core request function - returns parsed JSON body, throws on error\\n(def (api-request method url\\n       auth: (auth #f)\\n       data: (data #f)\\n       headers: (extra-headers '()))\\n  (let* ((hdrs (append\\n                 `((\\\"Accept\\\" . \\\"application/json\\\")\\n                   (\\\"Content-Type\\\" . \\\"application/json\\\"))\\n                 (if auth `((\\\"Authorization\\\" . ,auth)) '())\\n                 extra-headers))\\n         (body (and data (if (string? data) data (json-object->string data))))\\n         (resp (case method\\n                 ((GET)    (http-get url headers: hdrs))\\n                 ((POST)   (http-post url headers: hdrs data: body))\\n                 ((PUT)    (http-put url headers: hdrs data: body))\\n                 ((DELETE) (http-delete url headers: hdrs)))))\\n    (let ((status (request-status resp)))\\n      (if (and (>= status 200) (< status 300))\\n        (if (= status 204) (void) (request-json resp))\\n        (error (format \\\"HTTP ~a: ~a\\\" status (request-text resp)))))))\\n\\n;; Auto-paginated GET - collects all pages into a single list\\n(def (api-get-all url auth\\n       results-key: (results-key 'values)\\n       max-per-page: (max-per-page 100))\\n  (let loop ((offset 0) (acc '()))\\n    (let* ((sep (if (string-contains url \\\"?\\\") \\\"&\\\" \\\"?\\\"))\\n           (page-url (format \\\"~a~astartAt=~a&maxResults=~a\\\" url sep offset max-per-page))\\n           (body (api-request 'GET page-url auth: auth))\\n           (items (if (hash-table? body) (hash-ref body results-key '()) body))\\n           (total (if (hash-table? body) (hash-ref body 'total 0) 0))\\n           (all (append acc (if (list? items) items '()))))\\n      (if (and (hash-table? body) (< (+ offset (length items)) total) (> (length items) 0))\\n        (loop (+ offset (length items)) all)\\n        all))))",
    "notes": "This pattern provides a complete REST API client foundation for CLI tools. Key details: (1) request-json parses the response body as JSON automatically. (2) HTTP 204 (No Content) returns void since there's no body. (3) The pagination helper handles Jira-style startAt/maxResults but the pattern works for any offset-based API. (4) data: can be a hash table (auto-serialized) or pre-serialized string. (5) Use uri-encode from :std/net/uri for query parameter values.",
    "related": [
      "http-get",
      "http-post-json",
      "http-multipart-file-upload"
    ]
  },
  {
    "id": "request-json-symbol-keys",
    "title": "Force request-json to return symbol keys for let-hash",
    "tags": [
      "request-json",
      "symbol",
      "keys",
      "let-hash",
      "parameterize",
      "read-json-key-as-symbol"
    ],
    "imports": [
      ":std/net/request",
      ":std/text/json",
      ":std/sugar"
    ],
    "code": "(import :std/net/request :std/text/json :std/sugar)\n\n;; PROBLEM: request-json returns hash tables with STRING keys by default.\n;; But let-hash (.field, .?field) expects SYMBOL keys.\n;;\n;; WRONG — keys are strings, let-hash accessors silently return #f:\n;; (let ((body (request-json resp)))\n;;   (let-hash body\n;;     .?name))        ;; => #f (looking for symbol 'name, but key is string \"name\")\n\n;; CORRECT — wrap in parameterize to get symbol keys:\n(def (check-response resp)\n  (let ((status (request-status resp)))\n    (if (and (>= status 200) (< status 300))\n      (let ((text (request-text resp)))\n        (if (and text (> (string-length text) 0))\n          (parameterize ((read-json-key-as-symbol? #t))\n            (with-input-from-string text read-json))\n          #t))\n      (error (format \"HTTP ~a: ~a\" status (request-text resp))))))\n\n;; Usage:\n(let* ((resp (http-get \"https://api.example.com/data\"\n               headers: '((\"Accept\" . \"application/json\"))))\n       (body (check-response resp)))\n  (let-hash body\n    (displayln .?name)     ;; works — symbol key\n    (displayln .?status))) ;; works — symbol key\n\n;; WHY: request-json calls read-json internally, which defaults to\n;; string keys. Using request-text + read-json with parameterize\n;; gives you control over the key type. This is essential when using\n;; let-hash to destructure API responses.",
    "notes": "request-json uses read-json internally which defaults to string keys. The parameterize approach uses request-text first to get the raw string, then parses it with read-json inside a parameterize block that sets read-json-key-as-symbol? to #t. This gives symbol keys that work with let-hash's .field and .?field syntax. Without this, let-hash silently returns #f for all lookups because it looks for symbol keys but finds string keys.",
    "related": [
      "http-get",
      "let-hash-destructure",
      "rest-api-client-json-auth-pagination"
    ]
  },
  {
    "id": "getopt-subcommand-handler-two-args",
    "title": "getopt subcommand handler receives (cmd opt), not (opt) with .command",
    "tags": [
      "getopt",
      "subcommand",
      "command",
      "handler",
      "call-with-getopt",
      "cli"
    ],
    "imports": [
      ":std/cli/getopt",
      ":std/sugar"
    ],
    "code": "(import :std/cli/getopt :std/sugar)\n\n;; CRITICAL: With subcommands, the handler takes TWO arguments: (cmd opt)\n;; NOT one argument with .command in the hash.\n\n;; Define commands\n(def list-cmd\n  (command 'list\n    help: \"List items\"\n    (option 'filter \"--filter\" \"-f\" default: #f help: \"Filter\")))\n\n(def create-cmd\n  (command 'create\n    help: \"Create an item\"\n    (argument 'name help: \"Item name\")))\n\n;; CORRECT — handler takes (cmd opt):\n(def (main . args)\n  (call-with-getopt\n    (lambda (cmd opt)\n      (case cmd\n        ((list)\n         (let-hash opt\n           (displayln \"listing with filter: \" .?filter)))\n        ((create)\n         (let-hash opt\n           (displayln \"creating: \" .name)))))\n    args\n    program: \"my-tool\"\n    help: \"My CLI tool\"\n    list-cmd create-cmd))\n\n;; WRONG — this crashes with \"Wrong number of arguments\":\n;; (lambda (opt)\n;;   (let-hash opt\n;;     (case .command ...)))  ;; ERROR: handler called with 2 args, not 1",
    "notes": "This contradicts the existing cookbook recipe which shows (lambda (opt) ... (case .command ...)). In Gerbil v0.19+, when using subcommands (command forms), call-with-getopt calls the handler with TWO arguments: the command symbol and the options hash. Without subcommands (just flags/options), the handler takes ONE argument (the options hash). The error message is: \"Wrong number of arguments passed to procedure (#<procedure> 'command-name #<HashTable>)\".",
    "related": [
      "cli-getopt-subcommands",
      "let-hash-destructure"
    ]
  },
  {
    "id": "string-subst-arg-order",
    "title": "string-subst takes (str old new), not (old new str)",
    "tags": [
      "string-subst",
      "string",
      "replace",
      "substitute",
      "misc/string",
      "argument-order"
    ],
    "imports": [
      ":std/misc/string"
    ],
    "code": "(import :std/misc/string)\n\n;; string-subst argument order: (string-subst str old new)\n;; The string to modify comes FIRST, then old, then new.\n\n(string-subst \"hello world\" \"world\" \"gerbil\")\n;; => \"hello gerbil\"\n\n(string-subst \"/pets/{petId}\" \"{\" \"\")\n;; => \"/pets/petId}\"\n\n;; Chaining substitutions with let*:\n(let* ((s \"/pets/{petId}/toys\")\n       (s (string-subst s \"{\" \"\"))\n       (s (string-subst s \"}\" \"\"))\n       (s (string-subst s \"/\" \"-\")))\n  s)\n;; => \"-pets-petId-toys\"\n\n;; Optional count: keyword limits replacements\n(string-subst \"aaa\" \"a\" \"b\" count: 2)\n;; => \"bba\"",
    "notes": "Easy to confuse with other languages where replace(old, new, str) is common. In Gerbil's :std/misc/string, it's (string-subst str old new). The optional count: keyword limits the number of replacements.",
    "related": [
      "string-trim-prefix"
    ]
  },
  {
    "id": "camelcase-to-kebab-case",
    "title": "Convert camelCase/PascalCase to kebab-case with pregexp",
    "tags": [
      "camelCase",
      "kebab-case",
      "convert",
      "pregexp",
      "naming",
      "identifier"
    ],
    "imports": [
      ":std/pregexp",
      ":std/srfi/13"
    ],
    "code": "(import :std/pregexp :std/srfi/13)\n\n;; Convert camelCase or PascalCase to kebab-case.\n;; Handles consecutive uppercase letters correctly:\n;;   \"getAPIKey\" -> \"get-api-key\" (not \"get-a-p-i-key\")\n;;   \"XMLParser\" -> \"xml-parser\"\n(def (camel-case->kebab-case s)\n  (let* (;; Step 1: Insert hyphen between consecutive uppercase run and next word\n         ;; \"getAPIKey\" -> \"getAPI-Key\"\n         (s1 (pregexp-replace* \"([A-Z]+)([A-Z][a-z])\" s \"\\\\1-\\\\2\"))\n         ;; Step 2: Insert hyphen between lowercase/digit and uppercase\n         ;; \"getAPI-Key\" -> \"get-API-Key\"\n         (s2 (pregexp-replace* \"([a-z0-9])([A-Z])\" s1 \"\\\\1-\\\\2\")))\n    (string-downcase s2)))\n\n(camel-case->kebab-case \"getUserById\")    ;; => \"get-user-by-id\"\n(camel-case->kebab-case \"listPets\")       ;; => \"list-pets\"\n(camel-case->kebab-case \"createHTTPServer\") ;; => \"create-http-server\"\n(camel-case->kebab-case \"getAPIKey\")      ;; => \"get-api-key\"\n(camel-case->kebab-case \"XMLParser\")      ;; => \"xml-parser\"\n(camel-case->kebab-case \"Pet\")            ;; => \"pet\"\n(camel-case->kebab-case \"simple\")         ;; => \"simple\"",
    "notes": "Two-pass regex approach handles the tricky case of consecutive uppercase letters (like HTTP, API, XML). The first pass handles \"APIKey\" -> \"API-Key\" and the second handles \"getAPI\" -> \"get-API\". Then string-downcase normalizes everything. string-downcase is from :std/srfi/13. pregexp-replace* replaces ALL matches (not just the first).",
    "related": [
      "regular-expressions"
    ]
  },
  {
    "id": "pretty-print-code-generation",
    "title": "Use pretty-print for Scheme code generation / emission",
    "tags": [
      "pretty-print",
      "code-generation",
      "emit",
      "s-expression",
      "codegen",
      "format"
    ],
    "imports": [],
    "code": ";; pretty-print is a Gambit builtin — no import needed.\n;; It formats s-expressions with proper indentation.\n\n;; Emit a single form as a string:\n(def (emit-form form)\n  (call-with-output-string\n    (lambda (p) (pretty-print form p))))\n\n(emit-form '(def (add x y) (+ x y)))\n;; => \"(def (add x y) (+ x y))\\n\"\n\n;; Emit multiple forms with blank lines between:\n(def (emit-forms forms)\n  (call-with-output-string\n    (lambda (p)\n      (for-each (lambda (form)\n                  (pretty-print form p)\n                  (newline p))\n                forms))))\n\n;; Use quasiquote to build forms with computed parts:\n(let ((fn-name 'my-function)\n      (body '(+ x y)))\n  (emit-form `(def (,fn-name x y) ,body)))\n;; => \"(def (my-function x y) (+ x y))\\n\"\n\n;; Useful for code generators that output .ss files:\n(def (generate-module exports definitions)\n  (string-append\n    (emit-form `(export ,@exports))\n    \"\\n\"\n    (emit-forms definitions)))",
    "notes": "pretty-print is from Gambit (no import needed). It handles long forms by breaking across lines with proper indentation. For code generation, combine with quasiquote (backtick) and unquote (comma) to build s-expressions with dynamic parts, then pretty-print to get properly formatted output. string-append multiple emit-form calls to build complete source files.",
    "related": [
      "regular-expressions"
    ]
  },
  {
    "id": "string-to-keyword-vs-symbol-for-codegen",
    "title": "Use string->keyword (not string->symbol) for keyword parameter code generation",
    "tags": [
      "keyword",
      "string->keyword",
      "string->symbol",
      "pretty-print",
      "code generation",
      "codegen"
    ],
    "imports": [],
    "code": ";; PROBLEM: When generating Gerbil code with pretty-print, keyword\n;; parameters must use actual keywords (created via string->keyword),\n;; NOT symbols with a colon suffix (created via string->symbol).\n;;\n;; WRONG — creates a regular symbol, pretty-prints as |body:| (escaped):\n(string->symbol \"body:\")     ;; => |body:|\n;; (keyword? (string->symbol \"body:\"))  ;; => #f\n;; pretty-print wraps it in vertical bars: |body:|\n;; The reader treats |body:| as a NON-keyword symbol\n;; This causes \"Bad syntax; invalid match target\" in def parameter lists\n\n;; CORRECT — creates an actual keyword, pretty-prints as body: (unescaped):\n(string->keyword \"body\")     ;; => body:\n;; (keyword? (string->keyword \"body\"))  ;; => #t\n;; pretty-print outputs it as: body:\n;; The reader treats body: as a keyword — works correctly in def\n\n;; Example in code generation context:\n(import :std/format)\n(let ((kw (string->keyword \"body\"))\n      (param-list `(def (my-fn ,kw (body #f)) body)))\n  (call-with-output-string (lambda (p) (pretty-print param-list p))))\n;; => \"(def (my-fn body: (body #f)) body)\\n\"\n\n;; Note: string->keyword takes the name WITHOUT the colon suffix.\n;; The colon is added automatically by the keyword representation.",
    "notes": "Key gotcha for code generation: string->symbol with a colon suffix creates a regular symbol that pretty-print escapes with vertical bars (|body:|). The reader treats |body:| differently from body: — it's NOT a keyword. Use string->keyword (without the colon) to create actual keywords that pretty-print correctly. Also applies to write and display.",
    "related": [
      "optional-keyword-arguments",
      "pretty-print-code-generation"
    ]
  },
  {
    "id": "void-is-truthy-use-hash-get-not-hash-ref",
    "title": "hash-ref returns #!void for missing keys (truthy!); use hash-get for conditional checks",
    "tags": [
      "void",
      "truthy",
      "hash-ref",
      "hash-get",
      "when",
      "conditional",
      "gotcha"
    ],
    "imports": [],
    "code": ";; GOTCHA: #!void is TRUTHY in Gerbil. Only #f is falsy.\n;;\n;; hash-ref without a default returns #!void for missing keys (not #f).\n;; This means conditional checks like (if value ...) will be wrong.\n\n(def ht (hash (\"a\" 1)))\n\n;; WRONG — hash-ref returns #!void for missing key, which is truthy:\n(let ((val (hash-ref ht \"missing\")))\n  (if val \"found\" \"not-found\"))\n;; => \"found\" — WRONG! #!void is truthy\n\n;; ALSO WRONG — (when ...) returns #!void when condition is false:\n(def (maybe-get key)\n  (when (hash-key? ht key)\n    (hash-ref ht key)))\n(if (maybe-get \"missing\") \"found\" \"not-found\")\n;; => \"found\" — WRONG! (when ...) returned #!void which is truthy\n\n;; CORRECT — use hash-get which returns #f for missing keys:\n(let ((val (hash-get ht \"missing\")))\n  (if val \"found\" \"not-found\"))\n;; => \"not-found\" — correct\n\n;; CORRECT — use if instead of when, with explicit #f:\n(def (maybe-get-v2 key)\n  (if (hash-key? ht key)\n    (hash-ref ht key)\n    #f))\n(if (maybe-get-v2 \"missing\") \"found\" \"not-found\")\n;; => \"not-found\" — correct",
    "notes": "This is a common source of bugs in Gerbil. The (when ...) form returns #!void when the condition is false, and #!void is truthy. So if you store the result of (when ...) and later test it, it will appear to be a valid value. Always use (if ... ... #f) when you need to return #f for the false case, or use hash-get instead of hash-ref for lookups that might miss.",
    "related": [
      "hash-table-operations"
    ]
  },
  {
    "id": "deduplicate-names-hash-counter",
    "title": "Deduplicate names with hash table counter",
    "tags": [
      "deduplicate",
      "unique",
      "names",
      "collision",
      "hash",
      "counter",
      "codegen"
    ],
    "imports": [],
    "code": ";; Pattern: Make names unique by appending numeric suffix on collision\n;; Useful for code generation when input may have duplicate identifiers\n\n(def (deduplicate-names items get-name set-name!)\n  (let ((seen (make-hash-table)))\n    (for-each\n     (lambda (item)\n       (let* ((base-name (get-name item))\n              (count (hash-ref seen base-name 0))\n              (unique-name (if (= count 0)\n                             base-name\n                             (string-append base-name \"-\" (number->string count)))))\n         (hash-put! seen base-name (+ count 1))\n         (set-name! item unique-name)))\n     items)\n    items))\n\n;; Example: deduplicate field names in a list of field hashes\n(def fields (list (hash (\"name\" \"id\") (\"type\" \"int\"))\n                  (hash (\"name\" \"id\") (\"type\" \"string\"))\n                  (hash (\"name\" \"name\") (\"type\" \"string\"))))\n\n(deduplicate-names fields\n  (lambda (f) (hash-ref f \"name\"))\n  (lambda (f new) (hash-put! f \"name\" new)))\n\n;; Verify: first \"id\" kept as-is, second becomes \"id-1\"\n(and (equal? (hash-ref (list-ref fields 0) \"name\") \"id\")\n     (equal? (hash-ref (list-ref fields 1) \"name\") \"id-1\")\n     (equal? (hash-ref (list-ref fields 2) \"name\") \"name\"))",
    "notes": "This pattern is essential for code generators that produce Scheme identifiers from external sources (like OpenAPI/Swagger specs) where name collisions can occur. The counter-based approach ensures stable, deterministic naming when applied to sorted input. Sort items first for reproducible output.",
    "related": [
      "hash-table-operations"
    ]
  },
  {
    "id": "defstruct-naming-avoid-accessor-collision",
    "title": "Avoid defstruct accessor name collisions with -t suffix",
    "tags": [
      "defstruct",
      "struct",
      "accessor",
      "collision",
      "naming",
      "codegen",
      "type"
    ],
    "imports": [],
    "code": ";; PROBLEM: defstruct creates accessors named struct-name-field-name.\n;; If you have:\n;;   (defstruct foo (bar) ...)        ;; creates accessor foo-bar\n;;   (defstruct foo-bar (x) ...)      ;; tries to create struct foo-bar\n;; This causes a \"rebind conflict\" because foo-bar is already the accessor.\n\n;; SOLUTION: Use a -t suffix for type/struct names to avoid collisions.\n;; This is a common convention in Scheme/Lisp for type names.\n\n;; Example defstructs after applying this convention:\n(defstruct dashboard-gadget-t (id title position) transparent: #t)\n(defstruct dashboard-gadget-position-t (row column) transparent: #t)\n\n;; Create instances to verify both structs work\n(def gadget (make-dashboard-gadget-t 1 \"My Gadget\" (make-dashboard-gadget-position-t 0 1)))\n\n;; Accessors are now distinct:\n(and (dashboard-gadget-t? gadget)\n     (= (dashboard-gadget-t-id gadget) 1)\n     (dashboard-gadget-position-t? (dashboard-gadget-t-position gadget))\n     (= (dashboard-gadget-position-t-column (dashboard-gadget-t-position gadget)) 1))",
    "notes": "This pattern is essential when generating structs from external schemas (OpenAPI, JSON Schema, etc.) where schema names like \"Foo\" and \"FooBar\" would create accessor collisions. The -t suffix is a Lisp/Scheme convention indicating a type name. Alternative suffixes like -type or -struct also work.",
    "related": [
      "define-structs"
    ]
  },
  {
    "id": "sanitize-string-to-scheme-identifier",
    "title": "Sanitize arbitrary strings to valid Scheme identifiers",
    "tags": [
      "sanitize",
      "identifier",
      "string",
      "scheme-id",
      "codegen",
      "pregexp"
    ],
    "imports": [
      ":std/pregexp",
      ":std/srfi/13"
    ],
    "code": "(import :std/pregexp :std/srfi/13)\n\n;; Convert any string to a valid Scheme identifier\n;; Handles: spaces, punctuation, unicode, empty strings\n(def (string->scheme-id s)\n  (let* ((s (pregexp-replace* \"[^a-zA-Z0-9]+\" s \"-\"))  ;; non-alphanum -> hyphen\n         (s (string-trim-prefix \"-\" s))                ;; trim leading hyphens\n         (s (string-trim-suffix \"-\" s)))               ;; trim trailing hyphens\n    (if (string=? s \"\") \"unnamed\" (string-downcase s))))\n\n;; Test cases\n(and (equal? (string->scheme-id \"getUserById\") \"getuserbyid\")\n     (equal? (string->scheme-id \"The column position.\") \"the-column-position\")\n     (equal? (string->scheme-id \"foo_bar_baz\") \"foo-bar-baz\")\n     (equal? (string->scheme-id \"  spaces  \") \"spaces\")\n     (equal? (string->scheme-id \"\") \"unnamed\")\n     (equal? (string->scheme-id \"!!!@@@###\") \"unnamed\"))",
    "notes": "Use string->scheme-id for arbitrary external strings (JSON property names, user input). For camelCase identifiers like \"getUserById\", a separate camel-case->kebab-case function that inserts hyphens at case boundaries gives better results (\"get-user-by-id\").",
    "related": [
      "pregexp-replace"
    ]
  },
  {
    "id": "gambit-ffi-pointer-types",
    "title": "Define FFI pointer types with automatic cleanup",
    "tags": [
      "ffi",
      "c-define-type",
      "pointer",
      "gambit",
      "cleanup",
      "gc",
      "foreign"
    ],
    "imports": [],
    "code": ";; In a .scm file (Gambit FFI), define pointer types with automatic GC cleanup.\n;; The pattern is: (c-define-type TypeName* (pointer CType (TagName) \"cleanup_function\"))\n;;\n;; The cleanup function is called when the Scheme object is garbage collected.\n\n;; Example from LevelDB FFI:\n(c-declare #<<END-C\n#include <leveldb/c.h>\n\n;; Cleanup function - called when GC collects the Scheme wrapper\n___SCMOBJ ffi_free_leveldb_options (void *ptr)\n{\n  leveldb_options_destroy ((leveldb_options_t*)ptr);\n  return ___FIX (___NO_ERR);\n}\nEND-C\n)\n\n;; Define the pointer type with automatic cleanup\n(c-define-type leveldb_options_t \"leveldb_options_t\")\n(c-define-type leveldb_options_t*\n  (pointer leveldb_options_t (leveldb_options_t*) \"ffi_free_leveldb_options\"))\n\n;; Now when you create a pointer:\n(define-c-lambda leveldb_options_create () leveldb_options_t*)\n\n;; The returned pointer is automatically wrapped in a Scheme object.\n;; When that object is garbage collected, ffi_free_leveldb_options is called.\n\n;; For pointers that should NOT be auto-freed (borrowed pointers):\n(c-define-type leveldb_snapshot_t \"leveldb_snapshot_t\")\n(c-define-type leveldb_snapshot_t*\n  (pointer leveldb_snapshot_t (leveldb_snapshot_t*)))  ;; no cleanup function\n\n;; For char* that needs free():\n(c-declare #<<END-C\n___SCMOBJ ffi_free (void *ptr)\n{\n  free (ptr);\n  return ___FIX (___NO_ERR);\n}\nEND-C\n)\n\n(c-define-type char*\n  (pointer char (char*) \"ffi_free\"))",
    "notes": "The three-element form (pointer CType (TagName) \"cleanup\") enables automatic memory management. The tag (e.g., leveldb_options_t*) is used for type checking. The cleanup function MUST return ___FIX(___NO_ERR). For types where Scheme doesn't own the memory (like iterator keys that point into LevelDB internal buffers), omit the cleanup function. Common pattern: define a base type for the C struct, then a pointer type with cleanup for the Scheme wrapper.",
    "related": [
      "gambit-ffi-c-lambda",
      "gambit-ffi-scheme-object"
    ]
  },
  {
    "id": "gambit-ffi-u8vector-to-c",
    "title": "Pass u8vector to C functions efficiently",
    "tags": [
      "ffi",
      "u8vector",
      "bytes",
      "c-lambda",
      "gambit",
      "string"
    ],
    "imports": [],
    "code": ";; Pass Scheme u8vectors (byte arrays) to C functions without copying.\n;; Use scheme-object as the parameter type, then access via macros.\n\n(c-declare #<<END-C\n;; Define macros to access u8vector data and length\n#ifndef ___HAVE_FFI_U8VECTOR\n#define ___HAVE_FFI_U8VECTOR\n#define U8_DATA(obj) ___CAST (___U8*, ___BODY_AS (obj, ___tSUBTYPED))\n#define U8_LEN(obj) ___HD_BYTES (___HEADER (obj))\n#endif\n\n;; Example: wrapper that takes key and value as u8vectors\nvoid ffi_leveldb_put(leveldb_t* db, leveldb_writeoptions_t* opts,\n                     ___SCMOBJ key, ___SCMOBJ val, char** errptr)\n{\n  leveldb_put(db, opts,\n    (char*)U8_DATA(key), U8_LEN(key),\n    (char*)U8_DATA(val), U8_LEN(val),\n    errptr);\n}\nEND-C\n)\n\n;; Bind the wrapper - note scheme-object for the u8vector parameters\n(define-c-lambda leveldb_put\n  (leveldb_t* leveldb_writeoptions_t* scheme-object scheme-object leveldb_errptr)\n  void\n  \"ffi_leveldb_put\")\n\n;; In Gerbil, convert strings to bytes before calling:\n;; (def (value-bytes v)\n;;   (if (string? v) (string->bytes v) v))\n;; (leveldb_put db opts (value-bytes key) (value-bytes val) errptr)",
    "notes": "The scheme-object type passes the raw Scheme object pointer to C. U8_DATA extracts the data pointer, U8_LEN gets the byte length. This avoids copying - the C code accesses the Scheme heap directly. IMPORTANT: Don't store the pointer beyond the C call - GC could move the object. For returned data, allocate with malloc and wrap in a Scheme object with cleanup. The ___CAST, ___BODY_AS, ___tSUBTYPED, ___HD_BYTES, ___HEADER macros are from Gambit's internal API.",
    "related": [
      "gambit-ffi-pointer-types",
      "string-to-bytes"
    ]
  },
  {
    "id": "gambit-ffi-c-define-limitation",
    "title": "c-define callback limitation - complex C-to-Scheme callbacks are fragile",
    "tags": [
      "ffi",
      "c-define",
      "callback",
      "gambit",
      "limitation",
      "workaround"
    ],
    "imports": [],
    "code": ";; LIMITATION: Gambit's c-define creates C functions that call Scheme,\n;; but using them as callbacks passed to C libraries is complex and fragile.\n;;\n;; c-define syntax:\n;; (c-define (scheme-name args...) (c-types...) return-type \"c_name\" \"\"\n;;   body...)\n;;\n;; This creates a C function \"c_name\" that invokes the Scheme body.\n;; The problem: you can't easily pass this as a function pointer to C APIs\n;; that expect callbacks (like leveldb_comparator_create).\n\n;; WHAT WORKS: Simple one-shot callbacks where you control the C wrapper\n(c-define (my_callback x)\n          (int) int\n          \"my_callback\" \"\"\n  (* x 2))\n\n;; Then in C you can call: my_callback(5) → 10\n\n;; WHAT'S FRAGILE: Callbacks stored by C libraries for later use\n;; Examples: comparators, iterators, custom allocators\n;;\n;; Issues:\n;; 1. The Scheme runtime must be initialized when callback fires\n;; 2. Callbacks during GC can cause crashes\n;; 3. Callbacks from C threads not created by Gambit fail\n;; 4. Type mismatches between extern declaration and c-define cause errors\n\n;; WORKAROUND: For complex callbacks, implement in pure C\n;; For comparators: use the default byte-ordering comparator\n;; For iterators: use Gerbil-level iteration, not C callbacks\n\n;; Example of what DOESN'T work reliably:\n;; Trying to pass Scheme function as LevelDB comparator callback\n;; The c-define callback can hang or crash when LevelDB invokes it",
    "notes": "The c-define mechanism works for callbacks that you invoke from Scheme-controlled C code. It's fragile for callbacks stored by C libraries and invoked at arbitrary times (comparators, event handlers, custom allocators). The safest approach is to implement callback-heavy functionality in pure C. For LevelDB specifically: use the default byte-ordering comparator (design keys to sort correctly), avoid writebatch_iterate (use normal iteration instead), and avoid custom filter policies (use bloom filters).",
    "related": [
      "gambit-ffi-pointer-types"
    ]
  },
  {
    "id": "gxpkg-install-destroys-cwd",
    "title": "DANGER: gxpkg install/uninstall can destroy working directory",
    "tags": [
      "gxpkg",
      "install",
      "uninstall",
      "package",
      "danger",
      "working-directory",
      "destroy"
    ],
    "imports": [],
    "code": ";; CRITICAL WARNING: Running `gerbil pkg install` or `gerbil pkg uninstall`\n;; from within a project directory that has its own `.gerbil/` subdirectory\n;; can DESTROY the entire project directory contents.\n;;\n;; The gxpkg tool treats the CWD's `.gerbil/` as a package context.\n;; During install/uninstall, the `clean` step may remove project files.\n;;\n;; SAFE PATTERN — always cd to HOME or another directory first:\n;;\n;;   cd ~ && gerbil pkg install github.com/user/package\n;;   cd ~ && gerbil pkg uninstall github.com/user/package\n;;\n;; DANGEROUS — DO NOT do this from your project directory:\n;;\n;;   cd /path/to/my-project  # has .gerbil/ subdir\n;;   gerbil pkg install github.com/user/package  # MAY WIPE PROJECT FILES\n;;\n;; When using MCP tools (gerbil_package_manage), ensure the CWD\n;; is not a project directory with .gerbil/, or use the `cwd` parameter\n;; to explicitly set a safe working directory.\n;;\n;; RECOVERY: If this happens, use `git checkout` or restore from backup.\n;; The .git directory may also be deleted, requiring re-cloning.",
    "notes": "This was discovered when running `gerbil pkg install github.com/ober/gerbil-leveldb` from within the kunabi project directory. The entire project was wiped including .git, all source files, and build artifacts. Only .claude/ survived because it was created after the wipe. The gxpkg clean step is the culprit — it removes files from the local .gerbil/ context which cascades to removing the project structure."
  },
  {
    "id": "leveldb-snapshot-consistent-reads",
    "title": "LevelDB snapshot for consistent reads across multiple queries",
    "tags": [
      "leveldb",
      "snapshot",
      "read-options",
      "consistent",
      "iterator",
      "clan/db/leveldb"
    ],
    "imports": [
      ":clan/db/leveldb"
    ],
    "code": "(import :clan/db/leveldb)\n\n;; Create a snapshot for point-in-time consistent reads.\n;; Requires the ober/gerbil-leveldb fork (github.com/ober/gerbil-leveldb).\n;; The mighty-gerbils fork does NOT have snapshot support.\n\n;; Step 1: Create snapshot from open db\n(def snap (leveldb-snapshot db))\n\n;; Step 2: Create read-options with snapshot\n(def snap-opts (leveldb-read-options snapshot: snap))\n\n;; Step 3: Use snap-opts as optional 2nd/3rd arg to leveldb-get / leveldb-iterator\n(def val (leveldb-get db \"mykey\" snap-opts))      ;; 3rd arg = read-options\n(def itor (leveldb-iterator db snap-opts))          ;; 2nd arg = read-options\n\n;; Step 4: ALWAYS release the snapshot when done\n(leveldb-snapshot-release db snap)\n\n;; --- Recommended pattern: defrule macro for safe cleanup ---\n;; (defrule (with-snapshot db (snap-var opts-var) body ...)\n;;   (let* ((snap-var (leveldb-snapshot db))\n;;          (opts-var (leveldb-read-options snapshot: snap-var)))\n;;     (try (begin body ...)\n;;       (finally (leveldb-snapshot-release db snap-var)))))\n;;\n;; Usage:\n;; (with-snapshot my-db (snap snap-opts)\n;;   (let ((itor (leveldb-iterator my-db snap-opts)))\n;;     (leveldb-iterator-seek itor \"prefix:\")\n;;     ;; ... iterate consistently even if writes happen concurrently ...\n;;     (leveldb-iterator-close itor))\n;;   (leveldb-get my-db \"other-key\" snap-opts))",
    "notes": "Key API details from ober/gerbil-leveldb source: (1) leveldb-snapshot takes 1 arg (db), returns an opaque pointer. (2) leveldb-snapshot-release takes 2 args (db, snapshot). (3) leveldb-read-options accepts keyword snapshot: with the snapshot pointer. (4) leveldb-get signature is (ldb key (opts default-read-options)) — the read-options is a positional optional arg, not keyword. (5) leveldb-iterator signature is (ldb (opts default-read-options)) — same pattern. (6) Snapshots are lightweight in LevelDB but MUST be released to avoid blocking compaction. Always use try/finally or a macro wrapper.",
    "related": [
      "gxpkg-install-destroys-cwd"
    ]
  },
  {
    "id": "leveldb-local-pkg-manifest-setup",
    "title": "Fix 'gerbil build' when local .gerbil/pkg/ is missing manifests",
    "tags": [
      "leveldb",
      "gerbil-build",
      "manifest",
      "pkg",
      "gerbil.pkg",
      "depend"
    ],
    "imports": [],
    "code": ";; PROBLEM: `gerbil build` fails with:\n;;   No such file or directory\n;;   (call-with-input-file \".gerbil/pkg/github.com/user/package.manifest\" ...)\n;;\n;; This happens when your gerbil.pkg has depend: entries but the local\n;; .gerbil/pkg/ directory is missing the manifest files (e.g., after\n;; a clean checkout or after .gerbil/ was wiped).\n;;\n;; The manifests exist globally in ~/.gerbil/pkg/ but gerbil build\n;; looks for them locally when gerbil.pkg has depend: declarations.\n;;\n;; FIX: Copy manifest files from global to local:\n;;\n;;   # For each dependency in gerbil.pkg depend: list:\n;;   mkdir -p .gerbil/pkg/github.com/user/\n;;   cp ~/.gerbil/pkg/github.com/user/package.manifest \\\n;;      .gerbil/pkg/github.com/user/\n;;\n;; Then also copy the TAGS file:\n;;   cp ~/.gerbil/pkg/TAGS .gerbil/pkg/\n;;\n;; Example for a project depending on gerbil-leveldb and gerbil-libyaml:\n;;   mkdir -p .gerbil/pkg/github.com/ober\n;;   mkdir -p .gerbil/pkg/github.com/mighty-gerbils\n;;   cp ~/.gerbil/pkg/github.com/ober/gerbil-leveldb.manifest \\\n;;      .gerbil/pkg/github.com/ober/\n;;   cp ~/.gerbil/pkg/github.com/mighty-gerbils/gerbil-libyaml.manifest \\\n;;      .gerbil/pkg/github.com/mighty-gerbils/\n;;   cp ~/.gerbil/pkg/TAGS .gerbil/pkg/\n;;\n;; After this, run with GERBIL_LOADPATH:\n;;   GERBIL_LOADPATH=~/.gerbil/lib gerbil build",
    "notes": "This commonly happens after .gerbil/ is wiped (see gxpkg-install-destroys-cwd recipe) or on a fresh git clone. The gerbil build process reads manifests from the local .gerbil/pkg/ when gerbil.pkg declares dependencies via depend:. Even though the actual compiled modules are in ~/.gerbil/lib/, the manifest metadata must exist locally. An alternative is to run the full `gerbil pkg install` for each dependency, but that's slower and riskier (see the gxpkg destruction bug).",
    "related": [
      "gxpkg-install-destroys-cwd",
      "gerbil-build-loadpath"
    ]
  },
  {
    "id": "leveldb-iterator-close-not-destroy",
    "title": "LevelDB iterator cleanup: use leveldb-iterator-close, NOT leveldb-iterator-destroy",
    "tags": [
      "leveldb",
      "iterator",
      "close",
      "destroy",
      "cleanup",
      "unbound identifier"
    ],
    "imports": [
      ":clan/db/leveldb"
    ],
    "code": "(import :clan/db/leveldb)\n\n;; GOTCHA: The C LevelDB API uses leveldb_iter_destroy() to clean up iterators,\n;; but the Gerbil wrapper names it leveldb-iterator-close (NOT leveldb-iterator-destroy).\n;; Using leveldb-iterator-destroy causes: \"Reference to unbound identifier\"\n\n;; WRONG — unbound identifier:\n;; (leveldb-iterator-destroy iter)\n\n;; CORRECT:\n(def db (leveldb-open \"/tmp/testdb\"))\n(def iter (leveldb-iterator db))\n(leveldb-iterator-seek-first iter)\n(let loop ()\n  (when (leveldb-iterator-valid? iter)\n    (let ((key (leveldb-iterator-key iter))\n          (val (leveldb-iterator-value iter)))\n      (displayln \"key=\" key \" val=\" val))\n    (leveldb-iterator-next iter)\n    (loop)))\n(leveldb-iterator-close iter)  ;; <-- correct function name\n(leveldb-close db)\n\n;; Full iterator API (all exported from :clan/db/leveldb):\n;;   leveldb-iterator          — create iterator (optionally with read-options)\n;;   leveldb-iterator-close    — destroy/cleanup iterator\n;;   leveldb-iterator-valid?   — check if current position is valid\n;;   leveldb-iterator-seek-first — move to first key\n;;   leveldb-iterator-seek-last  — move to last key\n;;   leveldb-iterator-seek     — seek to specific key\n;;   leveldb-iterator-next     — advance to next entry\n;;   leveldb-iterator-prev     — move to previous entry\n;;   leveldb-iterator-key      — get current key (u8vector)\n;;   leveldb-iterator-value    — get current value (u8vector)\n;;   leveldb-iterator-error    — check for iterator errors\n;;\n;; Also: in-leveldb, in-leveldb-keys — for :std/iter protocol integration",
    "notes": "The naming mismatch comes from the C API (leveldb_iter_destroy) vs the Gerbil wrapper (leveldb-iterator-close). Iterators also have automatic finalization via Gambit's \"will\" mechanism, so they're cleaned up on GC even without explicit close — but explicit cleanup is good practice to release resources promptly. Note: key and value are returned as u8vectors; use (bytes->string key) to convert to strings.",
    "related": [
      "leveldb-snapshot"
    ]
  },
  {
    "id": "for-destructuring-compile-workaround",
    "title": "for loop destructuring fails with gxc compiler — use let or with instead",
    "tags": [
      "for",
      "destructuring",
      "in-hash",
      "in-indexed",
      "compile",
      "gxc",
      "unbound",
      "workaround"
    ],
    "imports": [
      ":std/iter"
    ],
    "code": ";; PROBLEM: Destructuring bindings in (for ...) work in the REPL (gxi)\n;; but cause \"Reference to unbound identifier\" errors when compiled with gxc.\n;;\n;; WRONG — works in REPL, fails with gxc:\n;; (for ((k v) (in-hash ht))        ;; v is unbound at compile time\n;;   (displayln k \": \" v))\n;;\n;; (for ((item i) (in-indexed lst))  ;; i is unbound at compile time\n;;   (displayln i \": \" item))        ;; also: in-indexed not exported from :std/iter\n\n;; CORRECT — iterate hash with single binding + let destructure:\n(import :std/iter)\n(def ht (hash (\"name\" \"Alice\") (\"age\" 30)))\n(for (kv (in-hash ht))\n  (let ((k (car kv)) (v (cdr kv)))\n    (displayln k \": \" v)))\n;; name: Alice\n;; age: 30\n\n;; CORRECT — indexed iteration with named let loop:\n(def items '(\"apple\" \"banana\" \"cherry\"))\n(let loop ((rest items) (i 0))\n  (unless (null? rest)\n    (displayln i \": \" (car rest))\n    (loop (cdr rest) (+ i 1))))\n;; 0: apple\n;; 1: banana\n;; 2: cherry\n\n;; CORRECT — use (with ...) for destructuring inside for body:\n(for (kv (in-hash ht))\n  (with ([k . v] kv)\n    (displayln k \" => \" v)))\n;; name => Alice\n;; age => 30",
    "notes": "This is a critical REPL-vs-compiler divergence. The for macro's destructuring pattern ((k v) (in-hash ...)) expands correctly in gxi (interpreter) but the gxc compiler does not bind the destructured variables, causing \"Reference to unbound identifier\" errors. Similarly, in-indexed is NOT exported from :std/iter (only 33 symbols are exported, in-indexed is not among them) — it only works in the REPL because it resolves dynamically. Always use single-variable for bindings and destructure in the body when writing code that will be compiled. The (with ...) pattern from match is the most concise alternative for destructuring pairs.",
    "related": [
      "iterate-hash",
      "for-collect",
      "for-fold"
    ]
  },
  {
    "id": "display-human-readable-hash",
    "title": "Display hash tables and lists in human-readable YAML-like format",
    "tags": [
      "display",
      "human",
      "readable",
      "hash",
      "nested",
      "yaml",
      "cli",
      "output",
      "pretty"
    ],
    "imports": [
      ":std/iter",
      ":std/format",
      ":std/srfi/13"
    ],
    "code": "(import :std/iter :std/format :std/srfi/13)\n\n;; Recursively display hash tables and lists in a human-readable format.\n;; Nested hashes indent, lists of hashes get numbered separators,\n;; flat lists join with commas.\n;; NOTE: Uses compiler-safe for patterns (no destructuring in for bindings).\n\n(def (display-human data (indent 0))\n  (let ((prefix (make-string indent #\\space)))\n    (cond\n     ((hash-table? data)\n      (for (kv (in-hash data))\n        (let ((k (car kv)) (v (cdr kv)))\n          (cond\n           ((or (hash-table? v)\n                (and (list? v) (not (null? v)) (hash-table? (car v))))\n            (displayln prefix k \":\")\n            (display-human v (+ indent 2)))\n           ((list? v)\n            (displayln prefix k \": \"\n                       (string-join (map (lambda (x) (format \"~a\" x)) v) \", \")))\n           (else\n            (displayln prefix k \": \" v))))))\n     ((list? data)\n      (if (and (not (null? data)) (hash-table? (car data)))\n        (let loop ((rest data) (i 1))\n          (unless (null? rest)\n            (when (> i 1) (displayln))\n            (displayln prefix \"--- [\" i \"] ---\")\n            (display-human (car rest) indent)\n            (loop (cdr rest) (+ i 1))))\n        (for (item data)\n          (displayln prefix item))))\n     (else\n      (displayln prefix data)))))\n\n;; Example:\n(display-human\n  (hash (\"key\" \"PROJ-123\")\n        (\"summary\" \"Fix bug\")\n        (\"status\" (hash (\"name\" \"In Progress\")))\n        (\"labels\" '(\"bug\" \"urgent\"))))\n;; Output:\n;; key: PROJ-123\n;; summary: Fix bug\n;; status:\n;;   name: In Progress\n;; labels: bug, urgent\n\n;; List of objects:\n(display-human\n  (list (hash (\"key\" \"PROJ-1\") (\"summary\" \"First\"))\n        (hash (\"key\" \"PROJ-2\") (\"summary\" \"Second\"))))\n;; Output:\n;; --- [1] ---\n;; key: PROJ-1\n;; summary: First\n;;\n;; --- [2] ---\n;; key: PROJ-2\n;; summary: Second",
    "notes": "This is a compiler-safe pattern (uses (for (kv (in-hash ...))) with manual car/cdr, not destructuring). Designed for CLI tools that need human-readable default output with a --json flag for machine-readable. Pair with a display-result dispatcher: (def (display-result data) (if (current-json-output) (display-json data) (display-human data))). The indent parameter enables recursive nesting for sub-hashes.",
    "related": [
      "for-destructuring-compile-workaround",
      "iterate-hash",
      "print-table"
    ]
  },
  {
    "id": "let-star-nested-hash-invalid-match-target",
    "title": "let* with deeply nested hash literals causes \"Bad syntax; invalid match target\"",
    "tags": [
      "let*",
      "hash",
      "bad syntax",
      "invalid match target",
      "nested",
      "destructure",
      "test"
    ],
    "imports": [],
    "code": ";; PROBLEM: In Gerbil, let* supports pattern-matching destructure on\n;; its bindings. When a deeply nested (hash ...) literal appears as\n;; the init-expr of the FIRST binding in let*, the compiler may\n;; misparse it as a destructuring pattern, causing:\n;;   \"Bad syntax; invalid match target\"\n;;\n;; WRONG — let* with deeply nested hash as first binding init-expr:\n;; (let* ((spec (hash (\"components\"\n;;                     (hash (\"schemas\"\n;;                            (hash (\"Container\"\n;;                                   (hash (\"type\" \"object\")\n;;                                         (\"properties\"\n;;                                          (hash (\"items\" (hash (\"type\" \"array\")\n;;                                                               (\"items\" (hash (\"$ref\" \"...\")))))\n;;                                                (\"owner\" (hash (\"$ref\" \"...\"))))))))))))\n;;        (resolved (process spec)))\n;;   (use resolved))\n;; => Syntax Error: Bad syntax; invalid match target\n\n;; FIX 1: Use plain (let ...) for the deeply nested hash binding,\n;; then let* for the rest:\n(let ((spec (hash (\"components\"\n                   (hash (\"schemas\"\n                          (hash (\"Container\"\n                                 (hash (\"type\" \"object\")\n                                       (\"properties\"\n                                        (hash (\"items\" (hash (\"type\" \"array\")\n                                                             (\"items\" (hash (\"$ref\" \"...\")))))\n                                              (\"owner\" (hash (\"type\" \"object\")))))))))))))\n  (let* ((resolved (process spec))\n         (result (transform resolved)))\n    (use result)))\n\n;; FIX 2: Build the hash in a separate def before the let*:\n(def test-spec\n  (hash (\"components\"\n         (hash (\"schemas\"\n                (hash (\"Container\"\n                       (hash (\"type\" \"object\")\n                             (\"properties\"\n                              (hash (\"items\" (hash (\"type\" \"array\"))))))))))))\n(let* ((resolved (process test-spec))\n       (result (transform resolved)))\n  (use result))",
    "notes": "This commonly bites in test code where you construct complex hash-table fixtures inline. The issue is that Gerbil's let* uses syntax-case matching on binding forms, and deeply nested hash literals with string keys can confuse the pattern matcher. Shallow hashes in let* work fine — it's specifically when there are 3+ levels of nesting that the problem appears. The workaround is to use plain (let ...) for the problematic binding and nest a let* inside for the sequential bindings, or to extract the hash construction into a separate (def ...).",
    "related": [
      "hash-table-operations",
      "dotted-pair-syntax-in-brackets"
    ]
  },
  {
    "id": "resolve-all-refs-preserve-ref-name",
    "title": "Preserve $ref names after JSON $ref resolution",
    "tags": [
      "json",
      "ref",
      "resolve",
      "openapi",
      "swagger",
      "schema",
      "reference"
    ],
    "imports": [],
    "code": ";; PROBLEM: When resolving JSON $ref pointers (e.g. for OpenAPI specs),\n;; you replace {\"$ref\": \"#/components/schemas/Pet\"} with the actual Pet\n;; schema object. But downstream code needs the original ref name to know\n;; WHICH schema was referenced (e.g. for display formatters, type dispatch).\n;;\n;; After resolution, the $ref string is gone — replaced by the target hash.\n;;\n;; SOLUTION: Store the original $ref path as \"$resolved-ref\" on the resolved hash.\n\n(def (resolve-all-refs node root (seen '()))\n  (cond\n   ((hash-table? node)\n    (let ((ref (hash-get node \"$ref\")))\n      (if (and ref (string? ref))\n        ;; $ref node — resolve it\n        (if (member ref seen)\n          (hash (\"$circular-ref\" ref))  ;; cycle detection\n          (let* ((resolved (resolve-json-pointer root ref))\n                 (result (resolve-all-refs resolved root (cons ref seen))))\n            ;; KEY: preserve original $ref path on the resolved hash\n            (when (hash-table? result)\n              (hash-put! result \"$resolved-ref\" ref))\n            result))\n        ;; Regular object — resolve all values recursively\n        (let ((result (make-hash-table)))\n          (hash-for-each\n           (lambda (k v)\n             (hash-put! result k (resolve-all-refs v root seen)))\n           node)\n          result))))\n   ((list? node)\n    (map (lambda (item) (resolve-all-refs item root seen)) node))\n   (else node)))\n\n;; Then downstream code checks both:\n(def (get-schema-ref schema)\n  (or (hash-get schema \"$ref\")           ;; unresolved\n      (hash-get schema \"$resolved-ref\"))) ;; resolved — still has the name",
    "notes": "After resolve-all-refs runs, (hash-get resolved-schema \"$resolved-ref\") returns e.g. \"#/components/schemas/Pet\". You can extract the name with (extract-ref-name ref) which takes the last path segment. This is critical for code generators that need to know schema names for type dispatch, formatter selection, or struct name generation.",
    "related": [
      "hash-table-operations"
    ]
  },
  {
    "id": "quasiquote-splice-empty-list-when-body",
    "title": "Quasiquote splicing empty list into when/begin produces invalid syntax",
    "tags": [
      "quasiquote",
      "splice",
      "when",
      "empty",
      "codegen",
      "generate",
      "syntax"
    ],
    "imports": [],
    "code": ";; PROBLEM: When generating Gerbil code with quasiquote + unquote-splicing,\n;; if the spliced list is empty, forms like (when ...) and (begin ...) end up\n;; with no body — which is a syntax error.\n;;\n;; This commonly happens in code generators that build per-schema formatters\n;; where some schemas have no displayable properties.\n\n;; WRONG — empty field-entries produces (when (hash-table? data)) with no body:\n;; (def field-entries '())  ;; e.g. schema with no properties\n;; `(def (display-foo data)\n;;    (when (hash-table? data)\n;;      ,@(map (lambda (e) `(display-field ,(car e) ,(cadr e)))\n;;             field-entries)))\n;; => (def (display-foo data) (when (hash-table? data)))\n;; => Syntax Error: Bad syntax; invalid match target\n\n;; CORRECT — guard against empty splice:\n(def (generate-object-formatter name field-entries)\n  (if (null? field-entries)\n    ;; No fields: generate a simple fallback\n    `(def (,(string->symbol (string-append \"display-\" name)) data)\n       (display-human data))\n    ;; Has fields: generate when + field displays\n    `(def (,(string->symbol (string-append \"display-\" name)) data)\n       (when (hash-table? data)\n         ,@(map (lambda (e) `(display-field ,(car e) ,(cadr e)))\n                field-entries)))))\n\n;; GENERAL RULE: Before splicing into forms that require a body\n;; (when, unless, begin, lambda, let, etc.), always check if the\n;; list is empty and provide an alternative form.",
    "notes": "This is a code generation gotcha. Forms like (when test body ...), (unless test body ...), and (begin body ...) require at least one body expression. When using ,@(map ...) to generate the body, an empty input list produces zero body forms, which is a syntax error. Always guard with (if (null? items) fallback-form normal-form) before constructing the quasiquote. The error message \"Bad syntax; invalid match target\" is misleading — the real issue is empty body.",
    "related": [
      "let-star-nested-hash-invalid-match-target",
      "pretty-print-code-generation"
    ]
  },
  {
    "id": "write-xml-generate-sxml",
    "title": "Generate XML/SVG output from SXML using write-xml",
    "tags": [
      "write-xml",
      "sxml",
      "svg",
      "xml",
      "generate",
      "output",
      "serialize"
    ],
    "imports": [
      ":std/xml"
    ],
    "code": "(import :std/xml)\n\n;; write-xml serializes an SXML tree to XML text.\n;; SXML format: (tag (@ (attr \"val\") ...) children...)\n;; All attribute values MUST be strings.\n\n;; Write to a port (default: current-output-port)\n(write-xml '(svg (@ (xmlns \"http://www.w3.org/2000/svg\")\n                    (width \"200\") (height \"200\"))\n                 (rect (@ (x \"10\") (y \"10\")\n                          (width \"180\") (height \"180\")\n                          (fill \"steelblue\")))\n                 (circle (@ (cx \"100\") (cy \"100\") (r \"50\")\n                            (fill \"white\")))\n                 (text (@ (x \"100\") (y \"108\")\n                          (text-anchor \"middle\")\n                          (font-size \"16\") (fill \"steelblue\"))\n                       \"Hello\"))\n           (current-output-port))\n;; Output: <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"200\">\n;;           <rect x=\"10\" y=\"10\" width=\"180\" height=\"180\" fill=\"steelblue\"></rect>\n;;           <circle cx=\"100\" cy=\"100\" r=\"50\" fill=\"white\"></circle>\n;;           <text x=\"100\" y=\"108\" text-anchor=\"middle\" ...>Hello</text>\n;;         </svg>\n\n;; Capture XML as a string\n(def xml-string\n  (call-with-output-string\n    (lambda (p)\n      (write-xml '(root (@ (id \"1\")) (item \"hello\") (item \"world\")) p))))\n;; => \"<root id=\\\"1\\\"><item>hello</item><item>world</item></root>\"\n\n;; Write to a file\n(call-with-output-file \"/tmp/output.svg\"\n  (lambda (p)\n    (write-xml '(svg (@ (xmlns \"http://www.w3.org/2000/svg\")\n                        (width \"100\") (height \"100\"))\n                     (rect (@ (width \"100\") (height \"100\") (fill \"red\"))))\n               p)))\n\n;; GOTCHAS:\n;; 1. write-xml does NOT add <?xml?> declaration — add manually if needed\n;; 2. Self-closing tags like <rect/> are written as <rect></rect> (valid XML)\n;; 3. All attribute values must be strings — use number->string for numbers\n;; 4. For SVG: the xmlns attribute is REQUIRED for browsers to render it\n;; 5. print-sxml->xml is an alternative that also accepts a port argument",
    "notes": "write-xml takes (sxml [port]). Without a port arg, it writes to current-output-port. The output is NOT pretty-printed (no indentation). Self-closing tags become open+close pairs which is valid XML/SVG. The xmlns attribute on the root SVG element is critical for browser rendering. print-sxml->xml is equivalent. For reading XML back, use read-xml which returns SXML wrapped in (*TOP* ...).",
    "related": [
      "parse-xml-to-sxml",
      "sxml-skip-pi-nodes"
    ]
  },
  {
    "id": "build-ffi-module-with-pkg-config",
    "title": "Build FFI module with pkg-config cc-options and ld-options",
    "tags": [
      "build",
      "ffi",
      "pkg-config",
      "cc-options",
      "ld-options",
      "defbuild-script",
      "gxc",
      "compile"
    ],
    "imports": [
      ":std/build-script",
      ":std/make"
    ],
    "code": "#!/usr/bin/env gxi\n;; build.ss — building an FFI module that links to a C library\n;; Uses :std/make helpers for pkg-config integration.\n(import :std/build-script\n        :std/make)\n\n;; defbuild-script with gxc: directive for FFI modules.\n;; gxc: passes -cc-options and -ld-options to the Gambit C compiler/linker.\n;; Plain strings are regular Gerbil modules (no special compile flags).\n(defbuild-script\n  `(;; FFI module — needs C compiler and linker flags\n    (gxc: \"libmylib\"\n          \"-cc-options\" ,(cppflags \"mylib\" \"\")\n          \"-ld-options\" ,(ldflags \"mylib\" \"-lmylib\"))\n    ;; High-level Gerbil wrapper — no special flags needed\n    \"mylib\"))\n\n;; --- How the :std/make helpers work ---\n;;\n;; (cppflags \"pkg-name\" \"fallback\")\n;;   Runs: pkg-config --cflags pkg-name\n;;   Falls back to \"fallback\" string if pkg-config fails\n;;   Returns: \"-I/path/to/include ...\" string\n;;\n;; (ldflags \"pkg-name\" \"fallback\")\n;;   Runs: pkg-config --libs pkg-name\n;;   Falls back to \"fallback\" string if pkg-config fails\n;;   Returns: \"-L/path/to/lib -lname\" string\n;;\n;; (append-options str1 str2 ...)\n;;   Joins non-empty strings with spaces\n;;   Useful for combining multiple flag sources\n\n;; --- Example: Cairo library with SVG+PNG support ---\n;; (defbuild-script\n;;   `((gxc: \"libcairo\"\n;;           \"-cc-options\" ,(cppflags \"cairo\" \"\")\n;;           \"-ld-options\" ,(append-options\n;;                            (ldflags \"cairo\" \"-lcairo\")\n;;                            (ldflags \"cairo-png\" \"-lpng16\")))\n;;     \"cairo\"))\n\n;; --- Example: OpenSSL with warning suppression ---\n;; (gxc: \"crypto/libcrypto\"\n;;       \"-cc-options\" ,(append-options\n;;                        (cppflags \"libcrypto\" \"\")\n;;                        \"-Wno-deprecated-declarations\")\n;;       \"-ld-options\" ,(ldflags \"libcrypto\" \"-lcrypto\")\n;;       ,@(include-gambit-sharp))",
    "notes": "The gxc: directive in defbuild-script tells the build system this module needs special compiler/linker flags (unlike plain string module names). The :std/make module provides cppflags, ldflags, append-options, pkg-config-cflags, pkg-config-libs helpers. Build order in the list matters — FFI modules must come before modules that import them. The (include-gambit-sharp) call adds Gambit's internal headers for advanced FFI (##vector-ref etc). Fallback strings in cppflags/ldflags are used when pkg-config is not available (e.g., manual installs). Use backtick (quasiquote) for the build spec since the ,() calls need evaluation.",
    "related": [
      "gambit-ffi-pointer-types",
      "static-exe-with-deps",
      "gerbil-build-loadpath"
    ]
  },
  {
    "id": "ffi-c-struct-field-accessors",
    "title": "Access C struct fields via wrapper functions in FFI",
    "tags": [
      "ffi",
      "struct",
      "accessor",
      "wrapper",
      "c-lambda",
      "text-extents",
      "cairo"
    ],
    "imports": [
      ":std/foreign"
    ],
    "code": "(import :std/foreign)\n\n;; PROBLEM: C functions that fill a struct by pointer (like cairo_text_extents)\n;; are awkward to bind directly — Gambit FFI doesn't easily expose struct fields.\n;;\n;; SOLUTION: Write thin C wrapper functions that call the C API and return\n;; individual fields. Each wrapper calls the original function and extracts\n;; one field from the result struct.\n\n(begin-ffi (text_width text_height)\n\n  (declare (not safe))\n\n  (c-declare #<<END-C\n#include <cairo/cairo.h>\n\n/* Wrapper: call cairo_text_extents, return just the width field */\nstatic double ffi_text_width(cairo_t *cr, const char *text)\n{\n  cairo_text_extents_t extents;\n  cairo_text_extents(cr, text, &extents);\n  return extents.width;\n}\n\n/* Wrapper: call cairo_text_extents, return just the height field */\nstatic double ffi_text_height(cairo_t *cr, const char *text)\n{\n  cairo_text_extents_t extents;\n  cairo_text_extents(cr, text, &extents);\n  return extents.height;\n}\nEND-C\n  )\n\n  ;; Bind the wrapper functions — note the C name string at the end\n  (define-c-lambda text_width (cairo_t* char-string) double \"ffi_text_width\")\n  (define-c-lambda text_height (cairo_t* char-string) double \"ffi_text_height\")\n)\n\n;; PATTERN SUMMARY:\n;; 1. C function fills struct by pointer: void some_fn(ctx*, result_struct*)\n;; 2. Write C wrappers that call fn and return one field each\n;; 3. Bind wrappers with define-c-lambda pointing to the C wrapper name\n;;\n;; This is cleaner than trying to define the struct in Gambit FFI\n;; and works for any C struct you need to read individual fields from.\n;; The trade-off is one C call per field — acceptable for non-hot-path code.",
    "notes": "This pattern is used in Gerbil's own libcrypto.ss for OpenSSL struct access. The alternative — defining the struct layout with c-define-type and field accessors — is more complex and fragile (struct layout must match exactly). For structs with many fields you need, consider a single C wrapper that returns values via multiple output parameters or packs them into a Scheme vector. The overhead of calling the C function multiple times (once per field) is negligible for non-hot-path code like text measurement.",
    "related": [
      "gambit-ffi-pointer-types",
      "gambit-ffi-scheme-object"
    ]
  },
  {
    "id": "sxml-optional-attrs-from-keywords",
    "title": "Build SXML attribute list from keyword args, filtering #f values",
    "tags": [
      "sxml",
      "attributes",
      "keyword",
      "optional",
      "filter",
      "xml",
      "svg"
    ],
    "imports": [
      ":std/srfi/13"
    ],
    "code": ";; Pattern for building SXML (@ ...) attribute lists from keyword arguments,\\n;; filtering out #f (unset) values. Useful for SVG/XML element constructors.\\n\\n(def (n->s v)\\n  (if (string? v) v (number->string v)))\\n\\n;; Convert keyword args to SXML attribute pairs, skipping #f values.\\n;; keyword->string strips the trailing colon automatically.\\n(def (opt-attrs . kvs)\\n  (let loop ((kvs kvs) (acc '()))\\n    (if (null? kvs)\\n      (reverse acc)\\n      (let ((k (car kvs))\\n            (v (cadr kvs)))\\n        (if v\\n          (loop (cddr kvs)\\n                (cons (list (string->symbol (keyword->string k)) (n->s v)) acc))\\n          (loop (cddr kvs) acc))))))\\n\\n;; Usage in an SVG element constructor:\\n(def (svg-rect x y width height\\n               fill: (fill #f)\\n               stroke: (stroke #f)\\n               rx: (rx #f))\\n  `(rect (@ (x ,(n->s x)) (y ,(n->s y))\\n            (width ,(n->s width)) (height ,(n->s height))\\n            ,@(opt-attrs fill: fill stroke: stroke rx: rx))))\\n\\n;; Examples:\\n(svg-rect 10 20 100 50)\\n;; => (rect (@ (x \\\"10\\\") (y \\\"20\\\") (width \\\"100\\\") (height \\\"50\\\")))\\n\\n(svg-rect 10 20 100 50 fill: \\\"red\\\" stroke: \\\"black\\\")\\n;; => (rect (@ (x \\\"10\\\") (y \\\"20\\\") (width \\\"100\\\") (height \\\"50\\\")\\n;;            (fill \\\"red\\\") (stroke \\\"black\\\")))",
    "notes": "keyword->string automatically strips the trailing colon: (keyword->string 'fill:) => \"fill\". All attribute values must be strings in SXML, hence n->s conversion. The ,@(opt-attrs ...) splice inserts only non-#f attributes. This pattern is the foundation of the gerbil-svg library's element constructors.",
    "related": [
      "generate-xml-svg-output",
      "defstruct-positional-args"
    ]
  },
  {
    "id": "defstruct-internal-constructor-pattern",
    "title": "Use internal helper to avoid defstruct make-NAME rebind conflict",
    "tags": [
      "defstruct",
      "constructor",
      "rebind",
      "conflict",
      "make",
      "pattern"
    ],
    "imports": [],
    "code": ";; PROBLEM: defstruct generates make-NAME. If you also define (def (make-NAME ...)),\\n;; you get \\\"Bad binding; rebind conflict\\\".\\n;;\\n;; This happens when you want a zero-arg convenience constructor but\\n;; defstruct's auto-generated one requires all fields.\\n\\n;; WRONG — rebind conflict:\\n;; (defstruct path-builder (commands) transparent: #t)\\n;; (def (make-path-builder (commands []))   ;; ERROR: rebinds make-path-builder\\n;;   (##structure path-builder::t commands))\\n\\n;; CORRECT — use an internal helper name:\\n(defstruct path-builder (commands) transparent: #t)\\n\\n(def (new-pb commands)\\n  (##structure path-builder::t commands))\\n\\n;; Use new-pb inside module functions:\\n(def (path-move-to pb x y)\\n  (new-pb (cons (string-append \\\"M\\\" (number->string x) \\\" \\\" (number->string y))\\n                (path-builder-commands pb))))\\n\\n;; Export make-path-builder (from defstruct) for external callers:\\n;; (make-path-builder [])  ;; create empty builder\\n;; (make-path-builder '(\\\"M0 0\\\"))  ;; create with initial commands",
    "notes": "defstruct creates make-NAME, NAME?, and NAME-field accessors. You CANNOT redefine make-NAME with def — it causes a compile-time rebind conflict. The workaround is to use an internal helper (e.g., new-pb) for constructing instances inside the module, and let callers use the defstruct-generated make-NAME directly. Use ##structure to construct directly when you know the type descriptor.",
    "related": [
      "defstruct-positional-args",
      "defstruct-accessor-collision"
    ]
  },
  {
    "id": "write-xml-arity-one-parameterize",
    "title": "write-xml is arity 1 — use parameterize for port redirection",
    "tags": [
      "write-xml",
      "xml",
      "port",
      "parameterize",
      "arity",
      "output"
    ],
    "imports": [
      ":std/xml"
    ],
    "code": "(import :std/xml)\\n\\n;; write-xml reports as arity:1 — it takes ONLY the SXML tree.\\n;; It writes to current-output-port.\\n;;\\n;; To redirect output to a specific port, use parameterize:\\n\\n;; Capture as string:\\n(def (sxml->string sxml)\\n  (call-with-output-string\\n    (lambda (p)\\n      (parameterize ((current-output-port p))\\n        (write-xml sxml)))))\\n\\n(sxml->string '(root (@ (id \\\"1\\\")) (item \\\"hello\\\")))\\n;; => \\\"<root id=\\\\\\\"1\\\\\\\"><item>hello</item></root>\\\"\\n\\n;; Write to file:\\n(def (sxml->file sxml filename)\\n  (call-with-output-file filename\\n    (lambda (p)\\n      (parameterize ((current-output-port p))\\n        (write-xml sxml)))))\\n\\n;; NOTE: Some cookbook entries show (write-xml sxml port) with 2 args.\\n;; The function signature tool reports arity:1. In practice, the\\n;; parameterize approach always works reliably.",
    "notes": "Despite some documentation suggesting write-xml accepts an optional port argument, gerbil_function_signature reports arity:1. The parameterize approach is the safe, verified way to redirect write-xml output. print-sxml->xml is an alternative that does accept a port argument, but its output is pretty-printed with newlines which may not be desired.",
    "related": [
      "generate-xml-svg-output"
    ]
  },
  {
    "id": "make-temporary-file-name",
    "title": "Create a temporary file name with prefix",
    "tags": [
      "temporary",
      "file",
      "temp",
      "tmp",
      "tmpfile",
      "temporaries"
    ],
    "imports": [
      ":std/os/temporaries"
    ],
    "code": "(import :std/os/temporaries)\n\n;; make-temporary-file-name takes exactly 1 argument: a prefix string\n;; Returns a unique path in /tmp like: /tmp/myprefix.eghagFpE.1770327980.9162219\n(def tmpfile (make-temporary-file-name \"myprefix\"))\n;; => \"/tmp/myprefix.eghagFpE.1770327980.9162219\"\n\n;; Common pattern: append an extension\n(def png-file (string-append (make-temporary-file-name \"cairo\") \".png\"))\n;; => \"/tmp/cairo.xxxxx.yyyy.zzzz.png\"",
    "notes": "Arity is 1 — requires a prefix string argument. Calling with no arguments causes \"Wrong number of arguments\" error. The prefix is used as the first component of the generated filename."
  },
  {
    "id": "ffi-type-predicate",
    "title": "Define FFI type predicate for foreign pointer types",
    "tags": [
      "ffi",
      "foreign",
      "type",
      "predicate",
      "pointer",
      "check",
      "define-c-type-predicate"
    ],
    "imports": [
      ":std/foreign"
    ],
    "code": ";; Inside a (begin-ffi (...) ...) block, define type predicates\n;; for foreign pointer types. This lets you check at runtime whether\n;; a Scheme object wraps a specific C pointer type.\n\n;; First, define the macro (must be inside begin-ffi):\n(define-macro (define-c-type-predicate pred tag)\n  `(define (,pred x)\n     (and (##foreign? x)\n          (##memq ',tag (foreign-tags x)))))\n\n;; Then use it with the tag from your c-define-type pointer declaration:\n;; Given:  (c-define-type cairo_t* (pointer cairo_t (cairo_t*) \\\"ffi_cairo_destroy\\\"))\n;;                                                   ^^^^^^^^^ this is the tag\n\n(define-c-type-predicate cairo_t? cairo_t*)\n(define-c-type-predicate cairo_surface_t? cairo_surface_t*)\n\n;; Usage in Gerbil code:\n;; (cairo_t? my-context)       ;; => #t if it's a cairo context pointer\n;; (cairo_surface_t? surface)  ;; => #t if it's a cairo surface pointer\n;; (cairo_t? 42)               ;; => #f (not a foreign object)",
    "notes": "The tag in define-c-type-predicate must match the tag in the c-define-type pointer declaration (the symbol in the tag list). ##foreign? and foreign-tags are Gambit internals — this must be inside a (declare (not safe)) block. This pattern is used in Gerbil's own libcrypto.ss. The macro must be defined inside begin-ffi, not at the module level.",
    "related": [
      "gambit-ffi-pointer-types"
    ]
  },
  {
    "id": "gxi-e-import-suppresses-output",
    "title": "gxi -e with import suppresses output — use script files instead",
    "tags": [
      "gxi",
      "import",
      "output",
      "suppress",
      "script",
      "eval",
      "displayln"
    ],
    "imports": [],
    "code": ";; PROBLEM: When using `gxi -e` with an import statement followed by\n;; other expressions, output from displayln/display is suppressed:\n;;\n;;   $ gxi -e '(import :my-module) (displayln \"hello\")'\n;;   (no output!)\n;;\n;; But without the import, output works fine:\n;;   $ gxi -e '(displayln \"hello\")'\n;;   hello\n;;\n;; SOLUTION: Write a script file and run it with gxi instead.\n\n;; smoke-test.ss:\n;; (import :my-project/my-module)\n;; (def (main . args)\n;;   (do-something)\n;;   (displayln \"Done!\"))\n\n;; Run with:\n;;   GERBIL_LOADPATH=.gerbil/lib gxi smoke-test.ss\n;;\n;; This reliably produces output and handles imports correctly.",
    "notes": "This appears to be a Gambit/Gerbil quirk where `gxi -e` with an import expression suppresses subsequent expression output. The workaround is trivial — use a script file. For quick one-liners that don't need imports, `gxi -e` works fine."
  },
  {
    "id": "interface-method-dispatch",
    "title": "Define and use Gerbil interfaces for polymorphic method dispatch",
    "tags": [
      "interface",
      "defmethod",
      "polymorphism",
      "method",
      "dispatch",
      "canvas",
      "abstraction"
    ],
    "imports": [],
    "code": ";; Define an interface with method signatures\n(interface Drawable\n  (draw! canvas)\n  (bounds))\n\n;; Implement on a class using defmethod\n(defclass circle-shape (cx cy radius color)\n  constructor: :init!)\n\n(defmethod {:init! circle-shape}\n  (lambda (self cx cy radius color)\n    (set! self.cx cx)\n    (set! self.cy cy)\n    (set! self.radius radius)\n    (set! self.color color)))\n\n;; NOTE: self.field dot syntax ONLY works inside defmethod lambda bodies\n;; It does NOT work in standalone def functions\n(defmethod {draw! circle-shape}\n  (lambda (self canvas)\n    (displayln \"Drawing circle at \" self.cx \",\" self.cy)))\n\n(defmethod {bounds circle-shape}\n  (lambda (self)\n    (list (- self.cx self.radius) (- self.cy self.radius)\n          (* 2 self.radius) (* 2 self.radius))))\n\n;; The interface exports: Drawable, is-Drawable?, make-Drawable, try-Drawable\n;; Method dispatch uses {obj.method args} syntax\n(let ((c (make-circle-shape 100 200 50 \"red\")))\n  {c.draw! \"my-canvas\"}   ;; dispatches to circle-shape's draw!\n  {c.bounds})              ;; => (50 150 100 100)\n\n;; IMPORTANT: interface does NOT generate standalone canvas-width etc.\n;; It generates Drawable-draw!, &Drawable-draw! (checked/unchecked)\n;; For {obj.method} dispatch, just define defmethod on each class",
    "notes": "Gerbil interfaces define a protocol but method dispatch via {obj.method args} works through defmethod on the class, not through the interface directly. The interface adds type predicates (is-Drawable?, Drawable?) and cast constructors (make-Drawable). The self.field dot syntax only works in defmethod lambda bodies, NOT in standalone def functions. Export only the interface name and predicates, not method names.",
    "related": [
      "defstruct-positional-args",
      "typed-struct-field-access"
    ]
  },
  {
    "id": "defclass-constructor-init-factory",
    "title": "defclass with constructor: :init! — auto-generated make-NAME forwards args to :init!",
    "tags": [
      "defclass",
      "constructor",
      "init",
      "make",
      "factory",
      "rebind"
    ],
    "imports": [],
    "code": ";; defclass with constructor: :init! generates make-NAME that forwards args to :init!\n(defclass my-widget (name value items)\n  constructor: :init!)\n\n(defmethod {:init! my-widget}\n  (lambda (self name (value 0))\n    (set! self.name name)\n    (set! self.value value)\n    (set! self.items [])))\n\n;; make-my-widget is auto-generated — DO NOT redefine with def!\n;; (def (make-my-widget name) ...)  ;; BAD: rebind conflict!\n\n;; The auto-generated make-my-widget forwards all args to :init!\n(make-my-widget \"foo\")        ;; calls :init! with self, \"foo\"\n(make-my-widget \"foo\" 42)     ;; calls :init! with self, \"foo\", 42\n\n;; If you need a convenience factory with a DIFFERENT name:\n(def (create-widget name)\n  (make-my-widget name 0))",
    "notes": "When using `constructor: :init!`, defclass generates a `make-NAME` function that allocates the object and calls its `:init!` method with all provided arguments. Do NOT define a function with the same `make-NAME` name — this causes a compile-time rebind conflict. If you need a convenience constructor, use a different name.",
    "related": [
      "use-internal-helper-rebind-conflict",
      "defstruct-positional-args"
    ]
  },
  {
    "id": "indexed-iteration-without-in-indexed",
    "title": "Iterate with index using named let (in-indexed does not exist)",
    "tags": [
      "iterate",
      "index",
      "loop",
      "in-indexed",
      "for",
      "counter",
      "enumerate"
    ],
    "imports": [],
    "code": ";; in-indexed does NOT exist in :std/iter\n;; Use a named let loop for indexed iteration:\n\n(def (process-items items)\n  (let loop ((rest items) (i 0))\n    (when (pair? rest)\n      (let ((item (car rest)))\n        (displayln i \": \" item)\n        (loop (cdr rest) (+ i 1))))))\n\n;; Example: draw indexed series in a chart legend\n(def (draw-legend series-list)\n  (let loop ((rest series-list) (i 0))\n    (when (pair? rest)\n      (let ((s (car rest))\n            (y (* i 18)))\n        (displayln \"Series \" i \" at y=\" y \": \" s)\n        (loop (cdr rest) (+ i 1))))))",
    "notes": "The function `in-indexed` referenced in some Gerbil documentation does NOT exist in `:std/iter`. For indexed iteration, use a named let loop with a counter variable. This is the standard Scheme pattern and always works."
  },
  {
    "id": "gerbil-pkg-depend-local-deps",
    "title": "Use GERBIL_LOADPATH for local project dependencies (not gerbil.pkg depend:)",
    "tags": [
      "gerbil.pkg",
      "depend",
      "GERBIL_LOADPATH",
      "local",
      "dependency",
      "contract",
      "string-split"
    ],
    "imports": [],
    "code": ";; PROBLEM: gerbil.pkg depend: expects installable package strings\n;; (like GitHub URLs), NOT bare symbols or local project names.\n;;\n;; WRONG — causes string-split contract violation at build time:\n;; ;; gerbil.pkg\n;; (package: my-charts)\n;; (depend: (gerbil-svg gerbil-cairo))\n;;\n;; Error: \"contract violation; expected: string given: gerbil-svg\"\n;; This happens because depend: entries are processed with string-split\n;; to extract package URLs for resolution.\n;;\n;; WRONG — local paths don't work either:\n;; (depend: (\"../gerbil-svg\" \"../gerbil-cairo\"))\n;;\n;; depend: is for installable packages like:\n;; (depend: (\"github.com/user/gerbil-svg\" \"github.com/user/gerbil-cairo\"))\n\n;; CORRECT — for LOCAL (non-published) dependencies, use GERBIL_LOADPATH:\n;;\n;; gerbil.pkg — keep it simple, no depend:\n;; (package: my-charts)\n;;\n;; Makefile — set GERBIL_LOADPATH to point at local dependency builds:\n;; GERBIL_SVG_LIB ?= $(HOME)/mine/gerbil-svg/.gerbil/lib\n;; GERBIL_CAIRO_LIB ?= $(HOME)/mine/gerbil-cairo/.gerbil/lib\n;; export GERBIL_LOADPATH := $(GERBIL_SVG_LIB):$(GERBIL_CAIRO_LIB)\n;;\n;; build:\n;; \tgerbil build\n;;\n;; test:\n;; \tgerbil test ./...\n\n;; SUMMARY:\n;; - depend: is for published packages installable via `gerbil pkg install`\n;; - GERBIL_LOADPATH is for local project dependencies built from source\n;; - Each entry in GERBIL_LOADPATH points to the dep's .gerbil/lib/ dir\n;; - Build deps first: cd ~/mine/gerbil-svg && gerbil build",
    "notes": "The contract violation error \"expected: string given: gerbil-svg\" is misleading — it comes from internal string processing of depend: entries, not from a type check on user code. The real issue is that depend: only accepts package URL strings that can be resolved by the package manager. For local development dependencies, GERBIL_LOADPATH is the correct mechanism. Set it in a Makefile to keep the workflow simple.",
    "related": [
      "gerbil-build-loadpath",
      "gxpkg-install-destroys-cwd"
    ]
  },
  {
    "id": "ffi-callback-dispatch-table",
    "title": "FFI callback dispatch table — map multiple Scheme closures through a single C trampoline",
    "tags": [
      "ffi",
      "callback",
      "c-define",
      "trampoline",
      "dispatch",
      "user-data",
      "void-pointer",
      "closure"
    ],
    "imports": [
      ":std/foreign"
    ],
    "code": ";; PATTERN: When a C library accepts callbacks with a void* user_data parameter,\n;; you can route multiple distinct Scheme closures through a SINGLE c-define\n;; trampoline by encoding a callback ID in the void* arg.\n;;\n;; This solves the problem that c-define creates one fixed C function,\n;; but you need many different callbacks (one per button, event, etc.).\n\n;; Inside begin-ffi:\n\n;; 1. Global dispatch table (Scheme side)\n(define *handlers* (make-hash-table))\n(define *next-id* 0)\n\n(define (register-handler! proc)\n  (let ((id *next-id*))\n    (set! *next-id* (+ id 1))\n    (hash-put! *handlers* id proc)\n    id))\n\n(define (unregister-handler! id)\n  (hash-remove! *handlers* id))\n\n;; 2. c-define trampoline — single C function that dispatches to Scheme\n(c-define (ffi_dispatch_callback callback-id arg1 arg2)\n          (long char-string char-string) void\n          \"ffi_dispatch_callback\" \"\"\n  (let ((handler (hash-ref *handlers* callback-id #f)))\n    (when handler (handler arg1 arg2))))\n\n;; 3. C wrapper that passes the callback ID as void* user_data\n(c-declare #<<END-C\n/* Example: C library has api_register(name, callback, user_data) */\n/* We wrap it to pass the integer ID as the void* arg */\n\nstatic void trampoline(const char *a1, const char *a2, void *arg) {\n    long callback_id = (long)arg;\n    ffi_dispatch_callback(callback_id, a1, a2);\n}\n\nstatic int ffi_register(void *handle, const char *name, long callback_id) {\n    return api_register(handle, name, trampoline, (void*)callback_id);\n}\nEND-C\n)\n\n;; 4. Bind the wrapper (NOT the original C function)\n(define-c-lambda raw_register ((pointer void) char-string long) int \"ffi_register\")\n\n;; === Usage from Gerbil ===\n;; (def id (register-handler! (lambda (a1 a2) (displayln \"got: \" a1 \" \" a2))))\n;; (raw_register handle \"my-event\" id)\n;; ;; When C library fires the callback, it calls trampoline → ffi_dispatch_callback\n;; ;; → looks up handler by ID → calls the Scheme closure\n;;\n;; (unregister-handler! id)  ;; cleanup when done",
    "notes": "This pattern works when: (1) the C API passes a void* user_data through to the callback, (2) callbacks fire on a thread where the Gambit runtime is active (e.g., the same thread that called the C function, or the event loop thread). It does NOT work for callbacks invoked from arbitrary C threads not created by Gambit. Closures stored in the hash table are safe from GC. For one-shot callbacks (like dispatch/schedule), remove the handler after it fires to avoid leaking entries. For persistent callbacks (like event handlers), remove on unbind/cleanup. The long↔void* cast is safe on both 32-bit and 64-bit platforms for small integer IDs.",
    "related": [
      "c-define-callback-limitation",
      "gambit-ffi-pointer-types"
    ]
  },
  {
    "id": "vendor-cpp-shared-library",
    "title": "Vendor and build a C++ library as shared .so for Gerbil FFI linking",
    "tags": [
      "ffi",
      "vendor",
      "shared-library",
      "c++",
      "build",
      "makefile",
      "ld-options",
      "rpath"
    ],
    "imports": [
      ":std/build-script",
      ":std/make"
    ],
    "code": "#!/usr/bin/env gxi\n;; build.ss — link FFI module against a vendored shared library\n;;\n;; When a C library is C++ internally but provides a C API (extern \"C\"),\n;; you can't compile it inline with Gambit's c-declare (which compiles as C).\n;; Instead: build the C++ source into a .so, then link the FFI module against it.\n\n(import :std/build-script)\n\n(defbuild-script\n  `((gxc: \"libmylib\"\n          \"-cc-options\" \"-I./vendor\"\n          \"-ld-options\" \"-L./vendor -lmylib -Wl,-rpath,$ORIGIN/vendor\")\n    \"mylib\"))\n\n;; === Makefile to build the vendored .so ===\n;;\n;; # Makefile\n;; CFLAGS := $(shell pkg-config --cflags dependency-lib)\n;; LIBS   := $(shell pkg-config --libs dependency-lib)\n;;\n;; vendor/libmylib.so: vendor/mylib.h\n;; \tg++ -shared -fPIC -o $@ -DMYLIB_BUILD_SHARED \\\n;; \t    -x c++ vendor/mylib.h $(CFLAGS) $(LIBS)\n;;\n;; build: vendor/libmylib.so\n;; \tgerbil build\n;;\n;; clean:\n;; \tgerbil clean\n;; \trm -f vendor/libmylib.so\n\n;; === Key details ===\n;;\n;; -Wl,-rpath,$ORIGIN/vendor\n;;   Embeds a relative rpath so the compiled Gerbil module finds\n;;   libmylib.so at runtime without setting LD_LIBRARY_PATH.\n;;   $ORIGIN expands to the directory containing the .so/.o file.\n;;\n;; -x c++\n;;   Tells g++ to compile the input as C++ even if the extension\n;;   is .h (needed for amalgamated single-header libraries).\n;;\n;; -DMYLIB_BUILD_SHARED\n;;   Many C/C++ libraries use a preprocessor flag to toggle between\n;;   static and shared library builds (controls dllexport/visibility).\n;;\n;; The Gerbil FFI module (.ss) only sees the C API (extern \"C\" functions).\n;; It uses define-c-lambda as normal — the C++ implementation is hidden\n;; behind the shared library boundary.",
    "notes": "This pattern is needed when: (1) the library source is C++ but provides a stable C API, (2) the library is not commonly available as a system package, (3) you want reproducible builds by vendoring a specific version. The amalgamated header approach (single .h file) is ideal for vendoring — just one file to manage. For libraries available via pkg-config, prefer linking directly with cppflags/ldflags instead. The rpath trick ($ORIGIN) avoids LD_LIBRARY_PATH but may need adjustment for installed packages vs development builds. On macOS, use -Wl,-rpath,@loader_path/vendor instead of $ORIGIN.",
    "related": [
      "build-ffi-pkg-config",
      "gambit-ffi-pointer-types"
    ]
  },
  {
    "id": "ffi-foreign-release-prevent-double-free",
    "title": "Use foreign-release! to prevent double-free with FFI pointer finalizers",
    "tags": [
      "ffi",
      "foreign-release",
      "finalizer",
      "double-free",
      "destroy",
      "gc",
      "pointer"
    ],
    "imports": [],
    "code": ";; PROBLEM: When a c-define-type pointer has a finalizer, calling the\n;; C destroy function explicitly AND letting GC collect the object\n;; causes a double-free (segfault).\n;;\n;; Example setup:\n;; (c-define-type mytype_t* (pointer mytype_t (mytype_t*) \"ffi_mytype_destroy\"))\n;; (define-c-lambda mytype_destroy (mytype_t*) int \"mytype_destroy\")\n;;\n;; WRONG — double free:\n;; (def (my-destroy! obj)\n;;   (mytype_destroy obj))  ;; calls C destroy\n;; ;; Later, GC collects obj → finalizer calls mytype_destroy AGAIN → crash\n;;\n;; CORRECT — use foreign-release! which triggers the finalizer and marks\n;; the object as released so GC won't finalize it again:\n;; (def (my-destroy! obj)\n;;   (foreign-release! obj))\n;;\n;; You can also check if already released:\n;; (foreign-released? obj)  ;; => #t if already released\n\n;; Full pattern for a safe destroy function:\n(def (my-destroy! obj)\n  (unless (foreign-released? obj)\n    (foreign-release! obj)))",
    "notes": "foreign-release! and foreign-released? are Gambit builtins (no import needed). foreign-release! calls the finalizer registered in c-define-type and marks the object so GC won't finalize it again. Always use this instead of calling the raw C destroy function directly. This is critical for any FFI wrapper that offers explicit resource cleanup alongside GC-based cleanup.",
    "related": [
      "gambit-ffi-pointer-types",
      "c-define-callback-limitation"
    ]
  },
  {
    "id": "c-define-char-string-const-mismatch",
    "title": "Gambit c-define char-string generates char* not const char* — fix forward declarations",
    "tags": [
      "ffi",
      "c-define",
      "char-string",
      "const",
      "type-mismatch",
      "forward-declaration",
      "trampoline"
    ],
    "imports": [
      ":std/foreign"
    ],
    "code": ";; PROBLEM: When using c-define with char-string parameters, Gambit generates\n;; C functions with (char *) parameters, NOT (const char *).\n;; If your C forward declaration uses const char*, you get:\n;;   \"conflicting types for 'ffi_my_handler'\"\n;;\n;; WRONG — forward declaration uses const:\n;; void ffi_my_handler(long id, const char *name, const char *data);\n;;\n;; But c-define generates: void ffi_my_handler(long id, char *name, char *data);\n;; => COMPILATION ERROR: conflicting types\n\n;; FIX: Use char* (no const) in the forward declaration, and cast\n;; in the trampoline that calls it:\n\n;; In c-declare:\n(c-declare #<<END-C\n/* Forward declaration matches c-define's generated signature */\nvoid ffi_my_handler(long id, char *name, char *data);\n\n/* Trampoline receives const char* from C library, casts for c-define */\nstatic void my_trampoline(const char *name, const char *data, void *arg) {\n    long id = (long)arg;\n    ffi_my_handler(id, (char*)name, (char*)data);\n}\nEND-C\n)\n\n;; The c-define with char-string generates char* parameters:\n(c-define (ffi_my_handler id name data)\n          (long char-string char-string) void\n          \"ffi_my_handler\" \"\"\n  (displayln \"got: \" id \" \" name \" \" data))",
    "notes": "This is a common gotcha when writing FFI callback trampolines. The C library's callback signature typically uses const char*, but Gambit's c-define for char-string generates char*. The (char*) cast in the trampoline is safe because the c-define function only reads the string (Gambit copies it into a Scheme string). Without the cast, you get -Wdiscarded-qualifiers warnings; without matching the forward declaration, you get a hard compilation error.",
    "related": [
      "ffi-callback-dispatch-table",
      "c-define-callback-limitation"
    ]
  },
  {
    "id": "build-ss-absolute-path-cc-options",
    "title": "Use absolute paths in build.ss cc-options — relative paths break because gxc compiles in .gerbil/lib/",
    "tags": [
      "build",
      "build.ss",
      "cc-options",
      "absolute-path",
      "relative-path",
      "gxc",
      "include",
      "vendor"
    ],
    "imports": [
      ":std/build-script",
      ":std/make"
    ],
    "code": "#!/usr/bin/env gxi\n;; build.ss — MUST use absolute paths for -I and -L flags\n;;\n;; PROBLEM: gxc compiles .ss files into .gerbil/lib/pkg/module~0.c,\n;; then runs gcc from that directory. Relative paths like -I./vendor\n;; resolve relative to .gerbil/lib/pkg/, NOT the project root.\n;;\n;; WRONG — relative path breaks:\n;; (gxc: \"libfoo\" \"-cc-options\" \"-I./vendor\" ...)\n;; => fatal error: foo.h: No such file or directory\n\n;; CORRECT — compute absolute path from build.ss location:\n(import :std/build-script\n        :std/make)\n\n(def here (path-directory (this-source-file)))\n(def vendor-dir (path-expand \"vendor\" here))\n\n(defbuild-script\n  `((gxc: \"libfoo\"\n          \"-cc-options\" ,(string-append\n                          \"-I\" vendor-dir \" \"\n                          (cppflags \"some-lib\" \"\"))\n          \"-ld-options\" ,(string-append\n                          \"-L\" vendor-dir \" -lfoo \"\n                          \"-Wl,-rpath,\" vendor-dir \" \"\n                          (ldflags \"some-lib\" \"-lsome-lib\")))\n    \"foo\"))",
    "notes": "this-source-file returns the path to the currently executing file (build.ss). path-directory extracts the directory. path-expand joins path components. This pattern is essential when vendoring C libraries — the -I and -L flags must be absolute because gxc's working directory during compilation is NOT the project root. The -Wl,-rpath flag should also use the absolute path (or $ORIGIN for installed packages).",
    "related": [
      "build-ffi-pkg-config",
      "vendor-shared-library"
    ]
  },
  {
    "id": "write-json-arity-one-parameterize",
    "title": "write-json is arity 1 — uses current-output-port, must parameterize for string output",
    "tags": [
      "json",
      "write-json",
      "serialize",
      "arity",
      "current-output-port",
      "parameterize",
      "string"
    ],
    "imports": [
      ":std/text/json"
    ],
    "code": "(import :std/text/json)\n\n;; write-json takes ONLY the value — it writes to current-output-port.\n;; It does NOT accept a port argument (arity 1, not 2).\n\n;; WRONG — trying to pass port as second arg:\n;; (write-json data port)  ;; ERROR: wrong number of arguments\n\n;; CORRECT — parameterize current-output-port:\n(def (json-serialize value)\n  (call-with-output-string\n   (lambda (p)\n     (parameterize ((current-output-port p))\n       (write-json value)))))\n\n(json-serialize (hash (\"name\" \"alice\") (\"age\" 30)))\n;; => \"{\\\"name\\\":\\\"alice\\\",\\\"age\\\":30}\"\n\n(json-serialize [1 2 3])\n;; => \"[1,2,3]\"\n\n;; Similarly, read-json takes NO arguments — reads from current-input-port:\n(def (json-parse str)\n  (call-with-input-string str read-json))\n\n(json-parse \"[1, \\\"hello\\\", true, null]\")\n;; => (1 \"hello\" #t #!void)\n\n;; Alternative: json-object->string for quick hash->string:\n(json-object->string (hash (\"key\" \"value\")))\n;; => \"{\\\"key\\\":\\\"value\\\"}\"",
    "notes": "This differs from many Scheme JSON libraries that accept an optional port argument. In Gerbil's :std/text/json, both write-json and read-json use current-output-port/current-input-port respectively. json-object->string is a convenience wrapper but only works for hash tables (not lists/primitives). For general serialization, use the parameterize pattern shown above. JSON null maps to #!void in Gerbil.",
    "related": [
      "json-parse",
      "json-generate"
    ]
  },
  {
    "id": "define-c-type-predicate-returns-list-not-bool",
    "title": "FFI type predicate (##memq) returns sublist not #t — use as truthy, not equal? #t",
    "tags": [
      "ffi",
      "type-predicate",
      "memq",
      "foreign",
      "truthy",
      "test",
      "check"
    ],
    "imports": [],
    "code": ";; The standard FFI type predicate pattern uses ##memq:\n;;\n;; (define-macro (define-c-type-predicate pred tag)\n;;   `(define (,pred x)\n;;      (and (##foreign? x)\n;;           (##memq ',tag (foreign-tags x)))))\n;;\n;; ##memq returns the SUBLIST starting at the match, NOT #t.\n;; So (my-type? obj) returns something like (my-type*), which is truthy but not #t.\n\n;; WRONG in tests:\n;; (check (my-type? obj) => #t)  ;; FAILS: actual value is (my-type*)\n\n;; CORRECT — use predicate check:\n;; (check (my-type? obj) ? values)  ;; passes: (my-type*) is truthy\n\n;; Or wrap the predicate to return a proper boolean:\n(define-macro (define-c-type-predicate pred tag)\n  `(define (,pred x)\n     (and (##foreign? x)\n          (##memq ',tag (foreign-tags x))\n          #t)))",
    "notes": "This bites you in test suites where (check expr => #t) does exact comparison. The ##memq-based predicate returns the sublist (tag ...) which is truthy but not equal? to #t. Either use (check expr ? values) in tests, or add an explicit #t at the end of the predicate definition to coerce to boolean. The standard gerbil-cairo pattern does NOT include the #t coercion.",
    "related": [
      "gambit-ffi-pointer-types",
      "ffi-type-predicate"
    ]
  },
  {
    "id": "ffi-utf8-string-unicode-support",
    "title": "Use UTF-8-string instead of char-string for Unicode FFI bindings",
    "tags": [
      "ffi",
      "UTF-8-string",
      "char-string",
      "unicode",
      "gambit",
      "c-define-type",
      "encoding"
    ],
    "imports": [
      ":std/foreign"
    ],
    "code": ";; PROBLEM: Gambit's char-string FFI type only handles Latin-1 (ISO 8859-1).\n;; Passing strings with non-Latin-1 characters (e.g., em-dash U+2014, CJK, emoji)\n;; causes: \"Can't convert to C char-string\"\n;;\n;; SOLUTION: Use UTF-8-string instead of char-string in all FFI bindings.\n;; UTF-8-string properly encodes/decodes Unicode strings as UTF-8 C strings.\n\n(begin-ffi (my_set_title my_get_title)\n  (c-declare \"#include \\\"mylib.h\\\"\")\n\n  ;; WRONG — breaks on Unicode:\n  ;; (define-c-lambda my_set_title (void* char-string) int \"set_title\")\n\n  ;; CORRECT — handles all Unicode:\n  (define-c-lambda my_set_title (void* UTF-8-string) int \"set_title\")\n\n  ;; Works for return types too:\n  (define-c-lambda my_get_title (void*) UTF-8-string \"get_title\")\n\n  ;; Also works in c-define callbacks (Scheme functions callable from C):\n  ;; The C forward declaration still uses char* — Gambit generates char*\n  ;; for both char-string and UTF-8-string in c-define signatures.\n  (c-declare \"void my_callback(char *text);\")\n\n  (c-define (my_callback text)\n            (UTF-8-string) void   ;; <-- UTF-8-string here too\n            \"my_callback\" \"\"\n    (displayln \"received: \" text))\n)\n\n;; SUMMARY:\n;; - char-string   → Latin-1 only (ISO 8859-1, first 256 Unicode code points)\n;; - UTF-8-string  → Full Unicode via UTF-8 encoding\n;; - nonnull-UTF-8-string → Same but rejects #f (NULL)\n;; - Always prefer UTF-8-string unless you specifically need Latin-1",
    "notes": "This is a common gotcha when binding modern C libraries that accept UTF-8 strings (which is most of them). The error \"Can't convert to C char-string\" at runtime means the string contains characters outside Latin-1. The fix is a simple find-and-replace of char-string → UTF-8-string in your FFI bindings. Both types generate char* in the C code, so no C-side changes are needed. The c-define forward declarations use char* for both types.",
    "related": [
      "c-define-char-string-const-mismatch",
      "gambit-ffi-pointer-types"
    ]
  },
  {
    "id": "gerbil-pkg-install-with-depend",
    "title": "Install dependencies declared in gerbil.pkg depend: via gerbil pkg install",
    "tags": [
      "gerbil",
      "pkg",
      "install",
      "depend",
      "dependency",
      "gxpkg",
      "package"
    ],
    "imports": [],
    "code": ";; To properly install a dependency declared in gerbil.pkg:\n;;\n;; 1. Declare the dependency in gerbil.pkg:\n;;    (package: my-project)\n;;    (depend: (\"github.com/ober/gerbil-svg\"))\n;;\n;; 2. Run `gerbil pkg install` FROM the project directory:\n;;    cd /path/to/my-project\n;;    gerbil pkg install github.com/ober/gerbil-svg\n;;\n;; This installs into the LOCAL project context:\n;;    .gerbil/pkg/github.com/ober/gerbil-svg/   (source, cloned from git)\n;;    .gerbil/lib/gerbil-svg/                    (compiled modules)\n;;\n;; The local context is CORRECT — gerbil build automatically finds\n;; packages in .gerbil/pkg/ when gerbil.pkg has depend: entries.\n;; No GERBIL_LOADPATH needed for build.\n;;\n;; 3. For gxi scripts/demos that import project + dependency modules,\n;;    include the local .gerbil/lib in GERBIL_LOADPATH:\n;;    GERBIL_LOADPATH=.gerbil/lib gxi demo/my-demo.ss\n;;\n;; KEY POINTS:\n;; - `gerbil pkg install` from a project dir → installs to LOCAL .gerbil/\n;; - `gerbil pkg install` from $HOME → installs to GLOBAL ~/.gerbil/\n;; - With depend: declared, local install is preferred (self-contained project)\n;; - `gerbil build` auto-resolves local .gerbil/pkg/ deps (no LOADPATH needed)\n;; - gxi scripts need GERBIL_LOADPATH=.gerbil/lib to find local deps",
    "notes": "The local vs global install context confused many sessions. When you run `gerbil pkg install` from inside a project (directory with gerbil.pkg), it installs to the project's .gerbil/ directory. This is intentional — it makes the project self-contained. The compiled modules land in .gerbil/lib/ which `gerbil build` searches automatically. For global installs, cd to $HOME first or use the gerbil_package_manage MCP tool with global_env: true.",
    "related": [
      "gxpkg-install-destroys-cwd",
      "gerbil-build-loadpath"
    ]
  },
  {
    "id": "build-ss-setenv-pkg-config-path",
    "title": "Set PKG_CONFIG_PATH inside build.ss for standalone gerbil pkg install",
    "tags": [
      "setenv",
      "PKG_CONFIG_PATH",
      "build.ss",
      "pkg-config",
      "gerbil pkg install",
      "linuxbrew",
      "environment"
    ],
    "imports": [
      ":std/build-script",
      ":std/make",
      ":std/misc/process"
    ],
    "code": "#!/usr/bin/env gxi\n;; build.ss — self-contained build script that works when invoked by\n;; `gerbil pkg install` (which does NOT inherit Makefile exports).\n;;\n;; PROBLEM: `gerbil pkg install github.com/user/my-ffi-pkg` clones\n;; the repo and runs build.ss directly. If the system uses linuxbrew's\n;; pkg-config (or any non-standard pkg-config), the default search path\n;; won't include system .pc files like gtk+-3.0.pc or libssl.pc.\n;;\n;; The Makefile workaround:\n;;   export PKG_CONFIG_PATH := /usr/lib/x86_64-linux-gnu/pkgconfig:$(PKG_CONFIG_PATH)\n;; does NOT help because `gerbil pkg install` doesn't use the Makefile.\n;;\n;; FIX: Set PKG_CONFIG_PATH inside build.ss using Gambit's setenv:\n\n(import :std/build-script\n        :std/make\n        :std/misc/process)\n\n;; Ensure pkg-config finds system packages\n;; (linuxbrew's pkg-config only searches its own paths)\n(let ((current (getenv \"PKG_CONFIG_PATH\" \"\"))\n      (sysdir \"/usr/lib/x86_64-linux-gnu/pkgconfig\"))\n  (when (and (file-exists? sysdir)\n             (not (string-contains current sysdir)))\n    (setenv \"PKG_CONFIG_PATH\"\n            (if (string-empty? current) sysdir\n                (string-append sysdir \":\" current)))))\n\n;; Now cppflags/ldflags will find system packages\n(def here (path-directory (this-source-file)))\n(def vendor-dir (path-expand \"vendor\" here))\n\n(defbuild-script\n  `((gxc: \"libfoo\"\n          \"-cc-options\" ,(string-append \"-I\" vendor-dir \" \" (cppflags \"gtk+-3.0\" \"\"))\n          \"-ld-options\" ,(string-append \"-L\" vendor-dir \" -lfoo \" (ldflags \"gtk+-3.0\" \"-lgtk-3\")))\n    \"foo\"))",
    "notes": "This is essential for FFI packages that use pkg-config and will be installed via `gerbil pkg install`. Without this, `cppflags`/`ldflags` from :std/make silently fall back to their default values (often empty strings), causing g++ compilation to fail with missing headers. The `file-exists?` guard makes it safe on non-Debian systems. `setenv` and `getenv` are Gambit builtins — no import needed. `string-contains` and `string-empty?` are also Gambit builtins. The path `/usr/lib/x86_64-linux-gnu/pkgconfig` is the Debian/Ubuntu multiarch location — on RHEL/Fedora it would be `/usr/lib64/pkgconfig`.",
    "related": [
      "build-ss-absolute-path-cc-options",
      "build-ffi-pkg-config",
      "vendor-shared-library"
    ]
  },
  {
    "id": "char-literal-parens-brackets",
    "title": "Avoid #\\\\( #\\\\) #\\\\[ #\\\\] character literals in code",
    "tags": [
      "character",
      "literal",
      "paren",
      "bracket",
      "reader",
      "workaround",
      "char->integer"
    ],
    "imports": [],
    "code": ";; Problem: #\\( #\\) #\\[ #\\] character literals confuse the Gerbil reader\n;; when used inside list expressions. The reader sees [ as list syntax\n;; and ) as a closer, causing \"Datum or EOF expected\" errors.\n;;\n;; WRONG — causes reader errors:\n;; (or (char=? ch #\\()\n;;     (char=? ch #\\))\n;;     (char=? ch #\\[)\n;;     (char=? ch #\\]))\n;;\n;; CORRECT — use integer comparison:\n(def (is-bracket-char? ch)\n  (let ((c (char->integer ch)))\n    (or (= c 40)    ;; (\n        (= c 41)    ;; )\n        (= c 91)    ;; [\n        (= c 93)    ;; ]\n        (= c 123)   ;; {\n        (= c 125))));; }\n\n;; Test:\n;; (is-bracket-char? (string-ref \"(\" 0))  ;; => #t\n;; (is-bracket-char? (string-ref \"a\" 0))  ;; => #f",
    "notes": "ASCII codes: ( = 40, ) = 41, [ = 91, ] = 93, { = 123, } = 125. The #\\{ and #\\} may also cause issues since { } is method dispatch syntax. Always use char->integer comparison for delimiter characters. #\\/ #\\\\ #\\. etc. are fine.",
    "related": [
      "dotted-pair-in-brackets"
    ]
  },
  {
    "id": "defrules-macro-ambiguity-fix",
    "title": "Fix defrules macro ambiguity with optional pattern argument",
    "tags": [
      "defrules",
      "macro",
      "ambiguity",
      "pattern",
      "optional",
      "ellipsis"
    ],
    "imports": [],
    "code": ";; Problem: When a defrules macro has two clauses — one with a pattern\n;; argument and one without — calls with a single expression always\n;; match the first clause, treating the expression as the pattern.\n;;\n;; WRONG — (my-macro (some-expr)) matches first clause,\n;; pattern = (some-expr), body ... = () (empty), producing (lambda () )\n;;\n;; (defrules my-macro ()\n;;   ((_ pattern body ...)\n;;    (do-with-pattern pattern (lambda () body ...)))\n;;   ((_ body ...)\n;;    (do-without-pattern (lambda () body ...))))\n;;\n;; CORRECT — require at least one body form when pattern is present:\n(defrules my-macro ()\n  ((_ pattern body0 body ...)\n   (do-with-pattern pattern (lambda () body0 body ...)))\n  ((_ body ...)\n   (do-without-pattern (lambda () body ...))))\n\n;; Now:\n;; (my-macro (expr))         => matches second clause (no pattern)\n;; (my-macro \"/path\" (expr)) => matches first clause (with pattern)",
    "notes": "The key insight is that body ... (with ellipsis) matches ZERO or more items. So ((_ pattern body ...) always matches any call with 1+ args, even when body ... is empty. Using body0 body ... requires at least one body form, forcing single-arg calls to fall through to the patternless clause."
  },
  {
    "id": "path-normalize-missing-dir",
    "title": "path-normalize throws on non-existent directories",
    "tags": [
      "path-normalize",
      "file",
      "directory",
      "error",
      "with-catch",
      "exists"
    ],
    "imports": [],
    "code": ";; Problem: (path-normalize \"./some/path\") throws an error if the\n;; directory doesn't exist, instead of returning a normalized string.\n;;\n;; WRONG — crashes if ./public doesn't exist:\n;; (path-normalize \"./public/./file.txt\")\n;; => \"No such file or directory\" error\n;;\n;; CORRECT — wrap in with-catch:\n(def (safe-path-normalize path)\n  (with-catch\n    (lambda (e) #f)\n    (lambda () (path-normalize path))))\n\n;; Or when used in a function that should return #f on failure:\n(def (try-resolve-file base-dir rel-path)\n  (with-catch\n    (lambda (e) #f)\n    (lambda ()\n      (let* ((full (path-expand rel-path base-dir))\n             (normalized (path-normalize full)))\n        (and (file-exists? normalized) normalized)))))",
    "notes": "This commonly bites in web frameworks when checking for static files in a public/ directory that may not exist. Always guard path-normalize with with-catch when the directory is user-configurable or optional."
  },
  {
    "id": "http-request-method-returns-symbol",
    "title": "http-request-method returns a symbol, not a string",
    "tags": [
      "httpd",
      "http-request-method",
      "symbol",
      "string",
      "net",
      "server",
      "request"
    ],
    "imports": [
      ":std/net/httpd"
    ],
    "code": "(import :std/net/httpd)\n\n;; http-request-method returns a SYMBOL like 'GET, 'POST, etc.\n;; NOT a string like \"GET\".\n\n;; WRONG — crashes or always returns \"GET\":\n;; (def method (string->symbol (http-request-method req)))\n;; This calls string->symbol on a symbol, which errors.\n\n;; CORRECT — guard against both types:\n(def (get-method req)\n  (let ((m (http-request-method req)))\n    (if (symbol? m) m (string->symbol m))))\n\n;; Or just use it directly as a symbol:\n(def (handle-request req res)\n  (case (http-request-method req)\n    ((GET)  (handle-get req res))\n    ((POST) (handle-post req res))\n    (else   (method-not-allowed res))))",
    "notes": "This is a common gotcha when wrapping httpd requests. The method is already a symbol, so you can compare with eq? or use in case forms directly. If you need a string, use (symbol->string (http-request-method req))."
  },
  {
    "id": "makefile-local-install-rsync",
    "title": "Makefile for installing a local Gerbil library globally with gerbil pkg",
    "tags": [
      "makefile",
      "install",
      "gerbil",
      "pkg",
      "link",
      "build",
      "global",
      "library"
    ],
    "imports": [],
    "code": ";; Standard Makefile for a Gerbil library with build/test/install/uninstall.\n;; Uses `gerbil pkg link -g` + `gerbil pkg build -g` for proper global install.\n;;\n;; CRITICAL: gerbil pkg commands MUST run from OUTSIDE the project directory\n;; (e.g. `cd /tmp &&`) to avoid the local .gerbil/ context interfering.\n;; Running from within the project dir silently fails or worse.\n;;\n;; ---- Makefile ----\n;; export GERBIL_LOADPATH := $(HOME)/.gerbil/lib\n;;\n;; .PHONY: build test clean install uninstall\n;;\n;; build:\n;; \tgerbil build\n;;\n;; test: build\n;; \tgerbil test ./...\n;;\n;; clean:\n;; \tgerbil clean\n;;\n;; install: build\n;; \tcd /tmp && gerbil pkg link -g mypackage $(CURDIR)\n;; \tcd /tmp && gerbil pkg build -g mypackage\n;;\n;; uninstall:\n;; \tcd /tmp && gerbil pkg unlink -g mypackage\n;; ---- end ----\n;;\n;; The package name (\"mypackage\") must match (package: mypackage) in gerbil.pkg.\n;;\n;; How it works:\n;; - `gerbil pkg link -g NAME PATH` creates a symlink at ~/.gerbil/pkg/NAME -> PATH\n;; - `gerbil pkg build -g NAME` compiles and installs artifacts to ~/.gerbil/lib/NAME/\n;; - `gerbil pkg unlink -g NAME` removes the symlink and cleans installed artifacts\n;;\n;; After `make install`, import with:\n;;   (import :mypackage/module-name)",
    "notes": "The `cd /tmp &&` prefix is essential — without it, gxpkg sees the local .gerbil/ directory and operates in local package context instead of global, causing the link to silently fail. The -g flag alone is NOT sufficient when CWD has a .gerbil/ subdirectory. This replaces the previous rsync-based recipe which bypassed Gerbil's package manager.",
    "related": [
      "gxpkg-install-destroys-cwd",
      "gerbil-build-loadpath"
    ]
  },
  {
    "id": "websocket-binary-send-receive",
    "title": "Send and receive binary WebSocket messages",
    "tags": [
      "websocket",
      "binary",
      "send",
      "receive",
      "message",
      "u8vector",
      "network"
    ],
    "imports": [
      ":std/net/websocket"
    ],
    "code": "(import :std/net/websocket)\n\n;; Connect to a WebSocket endpoint\n(def ws (websocket-connect \"wss://example.com/ws\"))\n\n;; IMPORTANT: make-message is a STRUCT constructor — positional args only!\n;; Field order: (data type partial?)\n;; - data: u8vector for binary, string for text\n;; - type: 'binary or 'text\n;; - partial?: #f for complete messages\n\n;; Send a binary message\n(def payload #u8(1 2 3 4 5))\n(WebSocket-send ws (make-message payload 'binary #f))\n\n;; Send a text message\n(WebSocket-send ws (make-message \"{\\\"action\\\":\\\"hello\\\"}\" 'text #f))\n\n;; Receive a message (blocks until available)\n(let ((msg (WebSocket-recv ws)))\n  (displayln \"Type: \" (message-type msg))      ;; 'binary or 'text\n  (displayln \"Data: \" (message-data msg))      ;; u8vector or string\n  (displayln \"Partial: \" (message-partial? msg)))\n\n;; Close the connection\n(WebSocket-close ws)",
    "notes": "CRITICAL: make-message uses POSITIONAL arguments (it's a defstruct). Do NOT use keyword args like (make-message type: 'binary data: payload) — this will fail with \"arguments don't match object size\". The field order is (data type partial?). WebSocket-send and WebSocket-recv are the methods (capital W). message-data, message-type, message-partial? are the accessors (lowercase m).",
    "related": [
      "defstruct-positional-args"
    ]
  },
  {
    "id": "os-pipe-create-fd-pair",
    "title": "Create OS pipe fd pair with :std/os/pipe",
    "tags": [
      "pipe",
      "fd",
      "file descriptor",
      "os",
      "pipeline",
      "ipc",
      "values"
    ],
    "imports": [
      ":std/os/pipe",
      ":std/os/fd",
      ":std/os/fdio"
    ],
    "code": ";; Create an OS-level pipe using :std/os/pipe\n;; pipe returns VALUES (not a vector!) with a direction parameter.\n;; Signature: (pipe (direction 'inout) (closeonexec #t))\n;; direction controls which ends become Gambit ports vs raw fds:\n;;   'inout (default) — both ends are Gambit ports (read-port, write-port)\n;;   'in    — read end is Gambit port, write end is raw fd\n;;   'out   — read end is raw fd, write end is Gambit port\n;;   'none  — both ends are raw fd integers\n(import :std/os/pipe :std/os/fd :std/os/fdio)\n\n;; Default ('inout) — both ends are Gambit ports:\n(receive (read-port write-port) (pipe)\n  (display \"hello from pipe\\n\" write-port)\n  (force-output write-port)\n  (close-port write-port)\n  (let ((line (read-line read-port)))\n    (close-port read-port)\n    line))\n;; => \"hello from pipe\"\n\n;; Raw fds ('none) — for passing to open-process or fdwrite:\n(receive (read-fd write-fd) (pipe 'none)\n  (fdwrite write-fd (string->bytes \"raw pipe data\\n\"))\n  (close write-fd)\n  (let* ((read-port (fdopen read-fd 'in))\n         (line (read-line read-port)))\n    (close-port read-port)\n    line))\n;; => \"raw pipe data\"\n\n;; Mixed ('in) — read port + raw write fd (useful for shell pipelines):\n;; Launch cmd1 with stdout -> write-fd, read cmd1 output from read-port\n(receive (read-port write-fd) (pipe 'in)\n  ;; write-fd is a raw integer for passing to open-process\n  ;; read-port is a Gambit port for read-line etc.\n  (close write-fd)    ;; close raw fd with close from :std/os/fdio\n  (close-port read-port))\n\n;; PIPELINE PATTERN for cmd1 | cmd2:\n;;   (receive (read-port write-fd) (pipe 'in)\n;;     ;; Launch cmd1 with stdout -> write-fd\n;;     ;; Launch cmd2 with stdin -> read-port\n;;     ;; Close write-fd and read-port in parent\n;;     ;; Wait for both processes)",
    "notes": "CORRECTED: pipe returns VALUES (via (values ...)), NOT a vector. Use receive or call-with-values to destructure. The direction parameter controls which ends are Gambit ports vs raw fd integers. Default 'inout gives both as ports. Use 'none for raw fds, 'in for read-port+write-fd, 'out for read-fd+write-port. The closeonexec parameter defaults to #t (sets O_CLOEXEC). Use close from :std/os/fdio for raw fds, close-port for Gambit ports.",
    "related": [
      "open-process-stdin-write-read",
      "run-external-process"
    ]
  },
  {
    "id": "u8vector-big-endian-encoding",
    "title": "Big-endian binary encoding/decoding with u8vectors",
    "tags": [
      "u8vector",
      "binary",
      "big-endian",
      "encode",
      "decode",
      "uint32",
      "uint64",
      "network",
      "protocol"
    ],
    "imports": [],
    "code": ";; Big-endian uint32 encode/decode\n(def (encode-uint32 n)\n  (u8vector (bitwise-and (arithmetic-shift n -24) #xff)\n            (bitwise-and (arithmetic-shift n -16) #xff)\n            (bitwise-and (arithmetic-shift n -8) #xff)\n            (bitwise-and n #xff)))\n\n(def (decode-uint32 buf offset)\n  (+ (arithmetic-shift (u8vector-ref buf offset) 24)\n     (arithmetic-shift (u8vector-ref buf (+ offset 1)) 16)\n     (arithmetic-shift (u8vector-ref buf (+ offset 2)) 8)\n     (u8vector-ref buf (+ offset 3))))\n\n;; Big-endian uint64 encode/decode\n(def (encode-uint64 n)\n  (u8vector (bitwise-and (arithmetic-shift n -56) #xff)\n            (bitwise-and (arithmetic-shift n -48) #xff)\n            (bitwise-and (arithmetic-shift n -40) #xff)\n            (bitwise-and (arithmetic-shift n -32) #xff)\n            (bitwise-and (arithmetic-shift n -24) #xff)\n            (bitwise-and (arithmetic-shift n -16) #xff)\n            (bitwise-and (arithmetic-shift n -8) #xff)\n            (bitwise-and n #xff)))\n\n(def (decode-uint64 buf offset)\n  (+ (arithmetic-shift (u8vector-ref buf offset) 56)\n     (arithmetic-shift (u8vector-ref buf (+ offset 1)) 48)\n     (arithmetic-shift (u8vector-ref buf (+ offset 2)) 40)\n     (arithmetic-shift (u8vector-ref buf (+ offset 3)) 32)\n     (arithmetic-shift (u8vector-ref buf (+ offset 4)) 24)\n     (arithmetic-shift (u8vector-ref buf (+ offset 5)) 16)\n     (arithmetic-shift (u8vector-ref buf (+ offset 6)) 8)\n     (u8vector-ref buf (+ offset 7))))\n\n;; u8vector helpers for building binary protocols\n(def (u8v-copy! dest dest-off src src-off len)\n  (let loop ((i 0))\n    (when (< i len)\n      (u8vector-set! dest (+ dest-off i) (u8vector-ref src (+ src-off i)))\n      (loop (+ i 1)))))\n\n(def (u8v-append . vecs)\n  (let* ((total (apply + (map u8vector-length vecs)))\n         (result (make-u8vector total 0)))\n    (let loop ((vecs vecs) (off 0))\n      (unless (null? vecs)\n        (let ((v (car vecs)))\n          (u8v-copy! result off v 0 (u8vector-length v))\n          (loop (cdr vecs) (+ off (u8vector-length v))))))\n    result))\n\n(def (u8v-slice buf start end)\n  (let* ((len (- end start))\n         (result (make-u8vector len)))\n    (u8v-copy! result 0 buf start len)\n    result))\n\n;; Example: build a 12-byte header\n;; [4 bytes: msg-type] [4 bytes: length] [4 bytes: seq-num]\n(def header (u8v-append (encode-uint32 1)     ;; msg-type = 1\n                        (encode-uint32 256)   ;; length = 256\n                        (encode-uint32 42)))  ;; seq-num = 42\n;; => #u8(0 0 0 1 0 0 1 0 0 0 0 42)",
    "notes": "Gerbil's arithmetic-shift and bitwise-and work on arbitrary precision integers, so uint64 encoding works without overflow issues. For signed int64, use two's complement: if the high bit is set after decode-uint64, subtract (expt 2 64). u8v-append is not in the stdlib — you need to define it yourself for building binary protocol messages."
  },
  {
    "id": "signal-handler-add-remove",
    "title": "Register and remove signal handlers with :std/os/signal-handler",
    "tags": [
      "signal",
      "handler",
      "SIGINT",
      "SIGCHLD",
      "SIGTERM",
      "trap",
      "os"
    ],
    "imports": [
      ":std/os/signal",
      ":std/os/signal-handler"
    ],
    "code": ";; Register signal handlers using :std/os/signal-handler\n;; Signal constants are in :std/os/signal\n(import :std/os/signal :std/os/signal-handler)\n\n;; Available signal constants (partial list):\n;; SIGINT SIGTERM SIGHUP SIGQUIT SIGCHLD SIGPIPE\n;; SIGTSTP SIGCONT SIGSTOP SIGUSR1 SIGUSR2 SIGWINCH\n;; SIGALRM SIGURG SIGPROF SIGVTALRM\n\n;; Register a handler — returns a handler-id for later removal\n(def handler-id\n  (add-signal-handler! SIGINT\n    (lambda (sig)\n      (displayln \"\\nCaught SIGINT (Ctrl+C)\")\n      ;; Handle the signal — e.g., set a flag, cleanup, etc.\n      )))\n\n;; Remove the handler when done\n(remove-signal-handler! handler-id)\n\n;; Multiple handlers can be registered for the same signal:\n(def h1 (add-signal-handler! SIGTERM\n          (lambda (sig) (displayln \"Handler 1: cleanup\"))))\n(def h2 (add-signal-handler! SIGTERM\n          (lambda (sig) (displayln \"Handler 2: save state\"))))\n\n;; Remove individually:\n(remove-signal-handler! h1)\n(remove-signal-handler! h2)\n\n;; Send signals to processes using kill:\n(import :std/os/signal)\n(kill pid SIGTERM)    ;; send SIGTERM to process\n(kill pid SIGINT)     ;; send SIGINT\n(kill pid SIGCONT)    ;; resume a stopped process\n(kill pid SIGSTOP)    ;; stop (pause) a process\n\n;; Block/unblock signals with sigprocmask:\n(let ((mask (make_sigset)))\n  (sigemptyset mask)\n  (sigaddset mask SIGCHLD)\n  (sigprocmask SIG_BLOCK mask #f))  ;; block SIGCHLD",
    "notes": "add-signal-handler! returns a handler ID (not void) — save it for removal with remove-signal-handler!. The handler receives the signal number as its argument. Multiple handlers can be registered for the same signal; they all fire. kill from :std/os/signal sends signals to processes by PID. For signal masking, use sigprocmask with make_sigset, sigemptyset, sigaddset, sigfillset, sigdelset, and sigismember. Constants SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK control the masking operation.",
    "related": [
      "run-external-process",
      "os-pipe-create-fd-pair"
    ]
  },
  {
    "id": "terminal-raw-mode-stty",
    "title": "Set terminal to raw mode and restore on exit",
    "tags": [
      "terminal",
      "raw",
      "stty",
      "tty",
      "interactive",
      "console",
      "unbuffered"
    ],
    "imports": [
      ":std/misc/ports",
      ":std/misc/process"
    ],
    "code": "(import :std/misc/ports :std/misc/process)\n\n;; Save current terminal settings\n(def (get-terminal-settings)\n  (with-input-from-process\n    (list path: \"stty\" arguments: [\"-g\"] stdin-redirection: #f)\n    read-all-as-string))\n\n;; Set raw mode (unbuffered, no echo, pass signals)\n(def (set-terminal-raw!)\n  (run-process [\"stty\" \"raw\" \"-echo\" \"icrnl\"]\n    stdin-redirection: #f))\n\n;; Restore saved settings\n(def (restore-terminal! saved-settings)\n  (run-process [\"stty\" (string-trim-right saved-settings)]\n    stdin-redirection: #f))\n\n;; Get terminal size as (columns . rows)\n(def (get-terminal-size)\n  (let ((output (with-input-from-process\n                  (list path: \"stty\" arguments: [\"size\"]\n                        stdin-redirection: #f)\n                  read-all-as-string)))\n    (let ((parts (string-split output #\\space)))\n      (if (>= (length parts) 2)\n        (cons (string->number (list-ref parts 1))   ;; columns\n              (string->number (list-ref parts 0)))   ;; rows\n        (cons 80 24)))))  ;; fallback\n\n;; Example: interactive session with raw terminal\n(def saved-settings (get-terminal-settings))\n(dynamic-wind\n  (lambda () (set-terminal-raw!))\n  (lambda ()\n    ;; Raw terminal active — read single keystrokes\n    (let loop ()\n      (let ((byte (read-u8 (current-input-port))))\n        (unless (or (eof-object? byte) (= byte 3))  ;; Ctrl-C = 3\n          ;; Process the byte...\n          (displayln \"Got: \" byte)\n          (force-output)\n          (loop)))))\n  (lambda () (restore-terminal! saved-settings)))",
    "notes": "CRITICAL: stty must access the actual terminal, so use stdin-redirection: #f to prevent Gambit from redirecting stdin. Without this, stty will error with \"stdin isn't a terminal\". string-trim-right is needed because stty -g output may include a trailing newline. For interactive binary protocols (like SSM sessions), use read-u8 to read single bytes from stdin in raw mode, not read-char or read-line. Use unwind-protect or dynamic-wind to always restore terminal settings, even on error.",
    "related": [
      "run-external-process-capture-output"
    ]
  },
  {
    "id": "open-process-stdin-write-read",
    "title": "Write to subprocess stdin and read stdout via open-process",
    "tags": [
      "process",
      "stdin",
      "write",
      "pipe",
      "subprocess",
      "bidirectional"
    ],
    "imports": [],
    "code": ";; open-process with bidirectional I/O — write to stdin, read from stdout\n;; No imports needed — open-process is a Gambit builtin\n\n;; The port returned by open-process is bidirectional (input+output):\n;; - display/write/fprintf writes to the child's stdin\n;; - read-line/read-char reads from the child's stdout\n\n(let* ((proc (open-process\n               (list path: \"/bin/cat\"\n                     arguments: '()\n                     stdout-redirection: #t\n                     stdin-redirection: #t)))\n       ;; Write to child's stdin\n       (_ (display \"hello from parent\\n\" proc))\n       (_ (force-output proc))\n       ;; Close the write direction so child sees EOF on stdin\n       (_ (close-output-port proc))\n       ;; Read from child's stdout\n       (line (read-line proc))\n       ;; Get exit status (blocks until process exits)\n       (status (process-status proc)))\n  (list line status))\n;; => (\"hello from parent\" 0)\n\n;; IMPORTANT GOTCHAS:\n;; 1. Call (force-output proc) after writing — output is buffered\n;; 2. Call (close-output-port proc) when done writing, or child\n;;    may block forever waiting for more input\n;; 3. process-status blocks until the child exits\n;; 4. Read ALL output BEFORE calling process-status, or you may\n;;    deadlock (child blocks on write, parent blocks on wait)\n\n;; Pattern for interactive command (write, read response, repeat):\n(let ((proc (open-process\n              (list path: \"/usr/bin/bc\"\n                    arguments: '(\"-l\")\n                    stdout-redirection: #t\n                    stdin-redirection: #t))))\n  (display \"2 + 3\\n\" proc)\n  (force-output proc)\n  (let ((result (read-line proc)))\n    (display \"quit\\n\" proc)\n    (force-output proc)\n    (close-output-port proc)\n    (process-status proc)\n    result))\n;; => \"5\"\n\n;; Pattern for filter (write all input, then read all output):\n(let ((proc (open-process\n              (list path: \"/usr/bin/sort\"\n                    arguments: '()\n                    stdout-redirection: #t\n                    stdin-redirection: #t))))\n  (for-each (lambda (line) (display line proc) (newline proc))\n            '(\"cherry\" \"apple\" \"banana\"))\n  (force-output proc)\n  (close-output-port proc)\n  (let loop ((lines '()))\n    (let ((line (read-line proc)))\n      (if (eof-object? line)\n        (begin (process-status proc) (reverse lines))\n        (loop (cons line lines))))))",
    "notes": "The port from open-process is bidirectional when both stdin-redirection: and stdout-redirection: are #t. The MOST COMMON mistake is forgetting force-output (writes are buffered) or forgetting close-output-port (child never sees EOF). Deadlock warning: if the child produces output while you're still writing, and the pipe buffer fills, both processes block. For large data, use threads: one thread writes stdin, another reads stdout. The process-status call blocks — always drain stdout first.",
    "related": [
      "run-external-process",
      "os-pipe-create-fd-pair",
      "run-subprocess-custom-env"
    ]
  },
  {
    "id": "binary-io-device-ports",
    "title": "Binary I/O on device ports (stdin/stdout) with write-subu8vector and read-u8",
    "tags": [
      "binary",
      "io",
      "stdin",
      "stdout",
      "write-subu8vector",
      "read-u8",
      "u8vector",
      "port"
    ],
    "imports": [],
    "code": ";; Writing binary data to stdout (or any output port)\n;; write-u8vector requires explicit port argument\n(def (write-binary-to-port data port)\n  (write-subu8vector data 0 (u8vector-length data) port)\n  (force-output port))\n\n;; Example: write binary payload to stdout\n(write-subu8vector #u8(72 101 108 108 111) 0 5 (current-output-port))\n(force-output (current-output-port))\n\n;; Reading single bytes from stdin (e.g., raw terminal input)\n;; read-u8 returns a fixnum (0-255) or eof-object\n(let loop ()\n  (let ((byte (read-u8 (current-input-port))))\n    (cond\n      ((eof-object? byte) (displayln \"EOF\"))\n      (else\n        (displayln \"Read byte: \" byte)\n        (loop)))))\n\n;; Reading a fixed number of bytes\n;; read-subu8vector returns the number of bytes actually read\n(def (read-exactly port n)\n  (let ((buf (make-u8vector n)))\n    (let loop ((offset 0))\n      (if (>= offset n) buf\n        (let ((got (read-subu8vector buf offset n port)))\n          (if (= got 0) #f  ;; EOF before filling\n            (loop (+ offset got))))))))\n\n;; Example: read 4-byte header then variable-length payload\n(let* ((header (read-exactly (current-input-port) 4))\n       (payload-len (decode-uint32 header 0))\n       (payload (read-exactly (current-input-port) payload-len)))\n  (displayln \"Payload: \" payload))",
    "notes": "GOTCHA: write-u8vector has arity issues on some ports — use write-subu8vector instead, which takes (buf start end port) and always works. read-u8vector takes a COUNT argument (not a buffer), returning a new u8vector — but for interactive byte-at-a-time reading, use read-u8 instead. read-subu8vector returns the number of bytes read (may be less than requested), so loop until you have enough. Always call (force-output port) after writing binary data to ensure it's flushed.",
    "related": [
      "u8vector-big-endian-encoding",
      "terminal-raw-mode-stty"
    ]
  },
  {
    "id": "directory-files-list-entries",
    "title": "List directory entries with directory-files and file-info",
    "tags": [
      "directory",
      "files",
      "list",
      "stat",
      "file-info",
      "ls",
      "filesystem"
    ],
    "imports": [],
    "code": ";; directory-files and file-info are Gambit builtins — no imports needed\n\n;; Basic: list files in a directory\n(directory-files \".\")\n;; => (\".\" \"..\" \".git\" \"README.md\" \"src\" ...)\n\n;; With options via settings list:\n(directory-files (list path: \".\" ignore-hidden: 'dot-and-dot-dot))\n;; => (\".git\" \"README.md\" \"src\" ...)\n;; ignore-hidden: 'dot-and-dot-dot excludes \".\" and \"..\" only\n\n;; Get file metadata with file-info (like stat):\n(let ((info (file-info \"README.md\")))\n  (list\n    (file-info-type info)                  ;; 'regular, 'directory, 'symbolic-link, etc.\n    (file-info-mode info)                  ;; permission bits as integer (e.g., 493 = #o755)\n    (file-info-size info)                  ;; size in bytes\n    (file-info-owner info)                 ;; uid (integer)\n    (file-info-group info)                 ;; gid (integer)\n    (file-info-last-modification-time info) ;; Gambit time object\n    (file-info-number-of-links info)))     ;; hard link count\n\n;; Check file type:\n(eq? (file-info-type (file-info \"src\")) 'directory)  ;; => #t\n\n;; file-info-type returns one of:\n;;   'regular  'directory  'symbolic-link  'character-special\n;;   'block-special  'fifo  'socket\n\n;; Pattern: list only regular files in a directory\n(let ((dir \".\"))\n  (filter (lambda (name)\n            (let ((path (string-append dir \"/\" name)))\n              (eq? (file-info-type (file-info path)) 'regular)))\n          (directory-files (list path: dir ignore-hidden: 'dot-and-dot-dot))))\n\n;; Pattern: recursive directory walk\n(def (walk-directory dir proc)\n  \"Call (proc full-path) for every file under dir recursively.\"\n  (for-each\n    (lambda (name)\n      (unless (member name '(\".\" \"..\"))\n        (let ((full (string-append dir \"/\" name)))\n          (if (eq? (file-info-type (file-info full)) 'directory)\n            (walk-directory full proc)\n            (proc full)))))\n    (directory-files dir)))",
    "notes": "directory-files accepts either a string path or a settings list with path: and ignore-hidden: keywords. The ignore-hidden: option values are: #f (show all), 'dot-and-dot-dot (hide . and ..), or #t (hide all dotfiles). file-info follows symlinks by default; use (file-info path #f) to not follow symlinks (lstat behavior). file-info-mode returns an integer — use bitwise operations to check permissions (e.g., (bitwise-and mode #o100) for owner-execute). These are all Gambit builtins, no imports needed.",
    "related": [
      "gambit-path-builtins",
      "read-file-to-string"
    ]
  },
  {
    "id": "user-info-environment-introspection",
    "title": "Get user info, hostname, pid, and environment variables (Gambit builtins)",
    "tags": [
      "user",
      "hostname",
      "pid",
      "environment",
      "getenv",
      "setenv",
      "introspection"
    ],
    "imports": [
      ":std/os/hostname",
      ":std/os/pid"
    ],
    "code": ";; Most of these are Gambit builtins (no import needed)\n;; hostname and getpid need :std/os/hostname and :std/os/pid\n\n(import :std/os/hostname :std/os/pid)\n\n;; --- Environment variables ---\n(getenv \"HOME\" #f)               ;; => \"/home/user\" or #f if unset\n(getenv \"PATH\" \"\")               ;; second arg is default\n(setenv \"MY_VAR\" \"my_value\")     ;; set env var\n(get-environment-variables)      ;; => alist of ALL env vars: ((\"HOME\" . \"/home/user\") ...)\n\n;; --- User info ---\n(user-name)                      ;; => \"jafourni\" (current user)\n(let ((ui (user-info (user-name))))\n  (list\n    (user-info-name ui)          ;; => \"jafourni\"\n    (user-info-uid ui)           ;; => 1000\n    (user-info-gid ui)           ;; => 1000\n    (user-info-home ui)          ;; => \"/home/jafourni\"\n    (user-info-shell ui)))       ;; => \"/bin/bash\"\n\n;; user-info also accepts a uid integer:\n(user-info 0)                    ;; => root's user-info\n\n;; --- System info ---\n(hostname)                       ;; => \"myhost\" (needs :std/os/hostname)\n(getpid)                         ;; => 12345 (needs :std/os/pid)\n(getppid)                        ;; => 12344 (parent pid, needs :std/os/pid)\n\n;; --- Working directory ---\n(current-directory)              ;; => \"/home/user/project/\"\n(current-directory \"/tmp\")       ;; change directory (set!)\n\n;; --- TTY detection ---\n(tty? (current-input-port))      ;; => #t if interactive, #f if piped/redirected",
    "notes": "getenv, setenv, user-name, user-info, current-directory, and tty? are Gambit builtins — no import needed. hostname needs :std/os/hostname, getpid/getppid need :std/os/pid. getenv with 2 args returns the default (not an error) if the variable is unset. user-info accepts either a username string or a uid integer. current-directory with one argument changes the cwd (like cd). tty? returns #t only for actual terminal ports (not when stdin is piped or redirected).",
    "related": [
      "gambit-path-builtins",
      "run-subprocess-custom-env"
    ]
  },
  {
    "id": "process-status-decode-waitpid",
    "title": "Decode raw waitpid status from process-status",
    "tags": [
      "process",
      "status",
      "waitpid",
      "exit",
      "signal",
      "decode",
      "WEXITSTATUS",
      "WTERMSIG"
    ],
    "imports": [],
    "code": ";; process-status returns the RAW waitpid(2) status integer, NOT the exit code.\n;; No imports needed — open-process and process-status are Gambit builtins.\n;;\n;; Encoding (same as POSIX waitpid):\n;;   Normal exit:  status = exit_code << 8    (exit 0 → 0, exit 1 → 256, exit 42 → 10752)\n;;   Killed by signal: status = signal_number (kill -9 → 9, kill -15 → 15)\n;;   Stopped:      status = (signal << 8) | 0x7f  (but Gambit's SIGCHLD handler ignores these)\n\n;; Decoding helpers (matching POSIX W* macros):\n(def (WIFEXITED status)    (= (bitwise-and status #x7f) 0))\n(def (WEXITSTATUS status)  (arithmetic-shift (bitwise-and status #xff00) -8))\n(def (WIFSIGNALED status)  (and (not (= (bitwise-and status #x7f) 0))\n                                (not (= (bitwise-and status #x7f) #x7f))))\n(def (WTERMSIG status)     (bitwise-and status #x7f))\n(def (WIFSTOPPED status)   (= (bitwise-and status #xff) #x7f))\n(def (WSTOPSIG status)     (arithmetic-shift (bitwise-and status #xff00) -8))\n\n;; Get a clean exit code (0-255) from raw status:\n(def (exit-status->code raw-status)\n  (cond\n    ((WIFEXITED raw-status) (WEXITSTATUS raw-status))\n    ((WIFSIGNALED raw-status) (+ 128 (WTERMSIG raw-status)))  ;; shell convention\n    (else 255)))  ;; unknown\n\n;; Examples:\n(let* ((proc (open-process (list path: \"/bin/sh\" arguments: '(\"-c\" \"exit 42\"))))\n       (status (process-status proc)))\n  (list 'raw: status 'exit-code: (exit-status->code status)))\n;; => (raw: 10752 exit-code: 42)\n\n(let* ((proc (open-process (list path: \"/bin/sh\" arguments: '(\"-c\" \"exit 0\"))))\n       (status (process-status proc)))\n  (list 'raw: status 'exit-code: (exit-status->code status)))\n;; => (raw: 0 exit-code: 0)\n\n;; Killed by signal (128 + signal_number is shell convention):\n;; exit-status->code for kill -9 → 137 (128 + 9)",
    "notes": "CRITICAL for shell implementation: process-status does NOT return the exit code directly. exit 1 returns 256, exit 42 returns 10752, kill -9 returns 9. You MUST use bitwise decoding (WEXITSTATUS, WTERMSIG) to get the actual exit code. The shell convention is to report 128+signal for signal-killed processes. Gambit's internal SIGCHLD handler only handles WIFEXITED and WIFSIGNALED — it ignores WIFSTOPPED, so stopped processes (Ctrl+Z) won't be detected without FFI waitpid with WUNTRACED.",
    "related": [
      "open-process-stdin-write-read",
      "os-pipe-create-fd-pair"
    ]
  },
  {
    "id": "tty-mode-set-raw-cooked",
    "title": "Set terminal raw/cooked mode with tty-mode-set! (no stty needed)",
    "tags": [
      "tty",
      "terminal",
      "raw",
      "cooked",
      "mode",
      "tty-mode-set!",
      "line-editor",
      "termios"
    ],
    "imports": [],
    "code": ";; tty-mode-set! is a Gambit builtin — no imports needed.\n;; It controls terminal I/O mode without shelling out to stty.\n;;\n;; Signature: (tty-mode-set! port input-allow-special input-echo output-raw input-raw)\n;;   input-allow-special: #t = handle Ctrl-C/Z etc. (ISIG); #f = pass through as bytes\n;;   input-echo: #t = echo typed chars; #f = no echo\n;;   output-raw: #t = no output processing; #f = normal (e.g. LF→CRLF)\n;;   input-raw:  #t = raw byte-at-a-time (no line editing, VMIN=1); #f = canonical (line mode)\n\n;; Save current mode (returns: input-allow-special input-echo output-raw input-raw)\n;; There's no built-in to query mode, so save before changing.\n\n;; Set raw mode for a line editor (most common for shell):\n;; - No echo (we draw the line ourselves)\n;; - No canonical mode (read byte-by-byte)\n;; - Allow special signals (Ctrl-C sends SIGINT)\n;; - Normal output processing (LF→CRLF)\n(tty-mode-set! (current-input-port)\n  #t   ;; input-allow-special = #t (let Ctrl-C work)\n  #f   ;; input-echo = #f (we handle display)\n  #f   ;; output-raw = #f (normal output)\n  #t)  ;; input-raw = #t (byte-at-a-time)\n\n;; Fully raw mode (for things like ssh/screen passthrough):\n(tty-mode-set! (current-input-port)\n  #f   ;; no signal processing\n  #f   ;; no echo\n  #t   ;; raw output\n  #t)  ;; raw input\n\n;; Restore cooked/canonical mode:\n(tty-mode-set! (current-input-port)\n  #t   ;; allow specials\n  #t   ;; echo on\n  #f   ;; normal output\n  #f)  ;; canonical input (line-buffered)\n\n;; Safe pattern with cleanup:\n(def (with-raw-terminal thunk)\n  (let ((port (current-input-port)))\n    (dynamic-wind\n      (lambda () (tty-mode-set! port #t #f #f #t))  ;; enter raw\n      thunk\n      (lambda () (tty-mode-set! port #t #t #f #f))))) ;; restore cooked\n\n;; Read single keystrokes in raw mode:\n(with-raw-terminal\n  (lambda ()\n    (let loop ()\n      (let ((ch (read-char)))\n        (unless (eqv? ch #\\x3)  ;; Ctrl-C\n          (display (format \"key: ~a (~a)\\n\" ch (char->integer ch)))\n          (force-output)\n          (loop))))))",
    "notes": "tty-mode-set! is a native Gambit function that does termios manipulation in C (sets ICANON, ECHO, ISIG, VMIN=1, VTIME=0 etc). It is MORE RELIABLE than shelling out to stty because it doesn't require a subprocess. Internally it calls tcgetattr/tcsetattr. For a shell's line editor, the typical mode is: allow-special=#t, echo=#f, output-raw=#f, input-raw=#t. This gives byte-at-a-time input without echo, while still allowing Ctrl-C to generate SIGINT. Gambit also provides tty-type-set! for setting TERM type and tty-history/tty-history-set! for Gambit's built-in line editor history.",
    "related": [
      "process-status-decode-waitpid",
      "os-pipe-create-fd-pair"
    ]
  },
  {
    "id": "patchelf-openssl-rpath",
    "title": "Fix OpenSSL version mismatch in compiled Gerbil executables with patchelf",
    "tags": [
      "patchelf",
      "openssl",
      "rpath",
      "linker",
      "executable",
      "build",
      "libcrypto",
      "ssl",
      "makefile"
    ],
    "imports": [],
    "code": ";; PROBLEM: Compiled Gerbil executable fails at runtime with:\n;;   gerbil-aws: /lib/x86_64-linux-gnu/libcrypto.so.3: version `OPENSSL_3.4.0' not found\n;;\n;; ROOT CAUSE: The executable was compiled against Gerbil's bundled OpenSSL\n;; (e.g. from Homebrew/Linuxbrew) but at runtime finds the system's older\n;; libcrypto.so.3 which lacks the required version symbols.\n;;\n;; FIX: Use patchelf to set the RPATH to point to the correct OpenSSL:\n;;\n;;   # Find where Gerbil's OpenSSL lives (commonly Linuxbrew):\n;;   OPENSSL_RPATH=/home/linuxbrew/.linuxbrew/opt/openssl@3/lib\n;;\n;;   # Patch the compiled binary after gerbil build:\n;;   patchelf --set-rpath $OPENSSL_RPATH .gerbil/bin/my-app\n;;\n;; MAKEFILE PATTERN (recommended):\n;;\n;; OPENSSL_RPATH = /home/linuxbrew/.linuxbrew/opt/openssl@3/lib\n;; BINARY = .gerbil/bin/my-app\n;;\n;; build:\n;; \tgerbil build\n;; \tpatchelf --set-rpath $(OPENSSL_RPATH) $(BINARY)\n;;\n;; install: build\n;; \tsudo cp $(BINARY) /usr/local/bin\n;;\n;; IMPORTANT: The install target must depend on build so the patchelf\n;; step runs before copying. Running `gerbil build` alone (e.g. via\n;; gerbil_build_and_report) does NOT patch the binary — always use\n;; `make build` or `make install` for the complete workflow.\n;;\n;; DIAGNOSIS: Check what RPATH the binary has:\n;;   patchelf --print-rpath .gerbil/bin/my-app\n;;   ldd .gerbil/bin/my-app | grep ssl\n;;\n;; On macOS, use install_name_tool instead of patchelf.",
    "notes": "This issue affects any Gerbil project that compiles executables using modules with OpenSSL dependencies (e.g. :std/net/request, :std/crypto, :std/net/ssl, :std/net/websocket). The system OpenSSL and Gerbil's build-time OpenSSL must match, or the RPATH must be patched. Install patchelf via: apt install patchelf (Debian/Ubuntu) or brew install patchelf.",
    "related": [
      "static-exe-with-deps",
      "stale-global-static-segfault"
    ]
  },
  {
    "id": "atom-atomic-reference",
    "title": "Clojure-style atomic reference with swap, CAS, and watches",
    "tags": [
      "atom",
      "atomic",
      "concurrency",
      "swap",
      "cas",
      "compare-and-set",
      "watch",
      "thread-safe",
      "mutable",
      "state"
    ],
    "imports": [
      ":std/misc/atom"
    ],
    "code": "(import :std/misc/atom)\n\n;; Create an atom with optional validator\n(def counter (atom 0))\n(def positive-counter (atom 1 validator: (lambda (x) (and (fixnum? x) (fx>= x 0)))))\n\n;; Read the current value\n(atom-deref counter)  ;; => 0\n\n;; Reset to a new value (like assignment)\n(atom-reset! counter 42)\n\n;; Swap: apply a function to the current value atomically\n(atom-swap! counter 1+)          ;; => 43\n(atom-swap! counter + 10)        ;; => 53 (extra args passed to fn)\n\n;; Compare-and-set (CAS): only update if current value matches expected\n(atom-compare-and-set! counter 53 100)  ;; => #t (was 53, now 100)\n(atom-compare-and-set! counter 53 200)  ;; => #f (not 53 anymore)\n\n;; Get both old and new values from a swap\n(defvalues (old new) (atom-swap-values! counter 1+))\n\n;; Convenience: atomic increment\n(atom-increment! counter)     ;; +1\n(atom-increment! counter 5)   ;; +5\n\n;; Atomic counter factory (returns a closure)\n(def next-id (atomic-counter))\n(next-id)  ;; => 0\n(next-id)  ;; => 1\n(next-id)  ;; => 2\n\n;; Add a watch function: called on every change\n;; watch-fn receives (key atom old-value new-value)\n(atom-add-watch! counter 'logger\n  (lambda (key a old new)\n    (displayln \"counter changed: \" old \" -> \" new)))\n(atom-swap! counter 1+)  ;; prints: counter changed: 106 -> 107\n\n;; Remove watch\n(atom-remove-watch! counter 'logger)",
    "notes": "Atoms are thread-safe mutable references. Validators run inside the lock — if a validator raises an exception, the swap is aborted. The swap function may be called multiple times if there's contention (like Clojure atoms). Use atom-compare-and-set! for explicit CAS patterns. atomic-counter returns a zero-allocation incrementing closure, ideal for generating unique IDs.",
    "related": [
      "channel-based-communication",
      "spawn-thread"
    ]
  },
  {
    "id": "list-builder-efficient-append",
    "title": "Efficient O(1) list building with with-list-builder",
    "tags": [
      "list",
      "builder",
      "accumulate",
      "append",
      "efficient",
      "performance",
      "collect",
      "push"
    ],
    "imports": [
      ":std/misc/list-builder"
    ],
    "code": "(import :std/misc/list-builder)\n\n;; with-list-builder provides O(1) append to a growing list\n;; Avoids O(n^2) from repeated (append lst (list new-item))\n(with-list-builder (push! peek)\n  (push! 'a)\n  (push! 'b)\n  (push! 'c)\n  (peek))  ;; => (a b c)\n\n;; Functional form:\n(call-with-list-builder\n  (lambda (push! peek)\n    (for (x (in-range 5))\n      (when (odd? x)\n        (push! x)))\n    (peek)))  ;; => (1 3)\n\n;; Common pattern: conditional collection\n(def (find-matching items pred)\n  (with-list-builder (collect)\n    (for-each (lambda (item)\n                (when (pred item)\n                  (collect item)))\n              items)))\n\n;; Nested collection with intermediate results\n(with-list-builder (push! peek)\n  (push! 'start)\n  (for (x '(1 2 3))\n    (push! (* x 10)))\n  (push! 'end)\n  (peek))  ;; => (start 10 20 30 end)",
    "notes": "with-list-builder uses cons cell mutation internally: a sentinel cons cell [#f] is created, and push! mutates the cdr to append in O(1). This prevents the O(n^2) quadratic append pattern. Always prefer this over (set! result (append result (list item))). The peek function returns the current list without consuming it. push! always appends to the end (maintains insertion order).",
    "related": [
      "collect-results-with-for-collect"
    ]
  },
  {
    "id": "lru-cache-bounded",
    "title": "LRU cache with bounded size and automatic eviction",
    "tags": [
      "lru",
      "cache",
      "bounded",
      "eviction",
      "memoize",
      "capacity",
      "hash",
      "performance"
    ],
    "imports": [
      ":std/misc/lru"
    ],
    "code": "(import :std/misc/lru)\n\n;; Create a bounded LRU cache\n(def cache (make-lru-cache 100))  ;; capacity 100\n\n;; Put and get values\n(lru-cache-put! cache \"key1\" \"value1\")\n(lru-cache-put! cache \"key2\" \"value2\")\n\n(lru-cache-ref cache \"key1\")          ;; => \"value1\" (marks as recently used)\n(lru-cache-get cache \"key1\")          ;; => \"value1\" (same, alias)\n(lru-cache-get cache \"missing\")       ;; => #f (not found)\n(lru-cache-ref cache \"missing\" 'default) ;; => default\n\n;; Check membership\n(lru-cache-key? cache \"key1\")         ;; => #t\n\n;; Remove\n(lru-cache-remove! cache \"key1\")\n\n;; Iterate (newest to oldest)\n(lru-cache-for-each\n  (lambda (k v) (displayln k \": \" v))\n  cache)\n\n;; Fold (oldest to newest)\n(lru-cache-fold\n  (lambda (k v acc) (cons (cons k v) acc))\n  '() cache)\n\n;; Fold right (newest to oldest)\n(lru-cache-foldr\n  (lambda (k v acc) (cons (cons k v) acc))\n  '() cache)\n\n;; Flush all entries\n(lru-cache-flush! cache)\n\n;; LRU caches are iterable with for\n(import :std/iter)\n(for ((k v) (in-lru-cache cache))\n  (displayln k \" => \" v))\n\n;; Memoization pattern with LRU\n(def expensive-cache (make-lru-cache 1000))\n(def (cached-compute key)\n  (or (lru-cache-get expensive-cache key)\n      (let (result (expensive-operation key))\n        (lru-cache-put! expensive-cache key result)\n        result)))",
    "notes": "LRU cache uses a hash table + doubly-linked list internally. Access (ref/get) promotes the entry to most-recently-used. When capacity is exceeded on put!, the least-recently-used entry is evicted. O(1) for all operations. The cache is NOT thread-safe — wrap with a mutex for concurrent access. Iteration via in-lru-cache yields (key . value) pairs from most-recent to least-recent.",
    "related": [
      "hash-table-basics"
    ]
  },
  {
    "id": "rbtree-sorted-map",
    "title": "Red-black tree for sorted key-value storage",
    "tags": [
      "rbtree",
      "red-black",
      "tree",
      "sorted",
      "map",
      "ordered",
      "comparator",
      "balanced"
    ],
    "imports": [
      ":std/misc/rbtree"
    ],
    "code": "(import :std/misc/rbtree)\n\n;; Create with a comparator function (must return <0, 0, or >0)\n(def t (rbtree string-cmp))       ;; string keys\n(def t2 (rbtree symbol-cmp))      ;; symbol keys\n\n;; Insert / update\n(rbtree-put! t \"banana\" 2)\n(rbtree-put! t \"apple\" 5)\n(rbtree-put! t \"cherry\" 1)\n\n;; Lookup\n(rbtree-ref t \"apple\")             ;; => 5 (error if missing)\n(rbtree-ref t \"missing\" 'default)  ;; => default\n(rbtree-get t \"apple\")             ;; => 5 (#f if missing)\n(rbtree-key? t \"apple\")            ;; => #t\n\n;; Remove\n(rbtree-remove! t \"banana\")\n\n;; In-order traversal (sorted by key)\n(rbtree-for-each\n  (lambda (k v) (displayln k \": \" v))\n  t)\n;; prints: apple: 5, cherry: 1 (alphabetical order)\n\n;; Fold\n(rbtree-fold\n  (lambda (k v acc) (+ acc v))\n  0 t)  ;; => 6\n\n;; Convert to/from alist\n(rbtree->list t)                   ;; => ((\"apple\" . 5) (\"cherry\" . 1))\n(def t3 (list->rbtree string-cmp '((\"x\" . 1) (\"y\" . 2))))\n\n;; Iterate with for\n(import :std/iter)\n(for ((k v) (in-rbtree t))\n  (displayln k \" => \" v))\n(for (k (in-rbtree-keys t))\n  (displayln k))\n(for (v (in-rbtree-values t))\n  (displayln v))\n\n;; Custom comparator for numeric keys\n(def num-tree (rbtree (lambda (a b) (- a b))))\n(rbtree-put! num-tree 42 \"answer\")\n(rbtree-put! num-tree 1 \"first\")",
    "notes": "Red-black trees maintain sorted order by key. All operations are O(log n). The comparator function must return a negative number if a < b, zero if a = b, and positive if a > b. Pre-built comparators: string-cmp, symbol-cmp, symbol-hash-cmp. For numeric keys, use (lambda (a b) (- a b)). Trees are iterable via in-rbtree, in-rbtree-keys, in-rbtree-values.",
    "related": [
      "hash-table-basics"
    ]
  },
  {
    "id": "priority-queue-heap",
    "title": "Priority queue (min/max heap) for ordered processing",
    "tags": [
      "priority",
      "queue",
      "heap",
      "pqueue",
      "min-heap",
      "max-heap",
      "scheduling",
      "sorted"
    ],
    "imports": [
      ":std/misc/pqueue"
    ],
    "code": "(import :std/misc/pqueue)\n\n;; Create a min-heap (lowest priority value comes out first)\n(def pq (make-pqueue car <))  ;; priority extracted by car, compared with <\n\n;; Push items (each item has a priority component)\n(pqueue-push! pq '(3 \"low-priority\"))\n(pqueue-push! pq '(1 \"high-priority\"))\n(pqueue-push! pq '(2 \"medium-priority\"))\n\n;; Pop returns the highest-priority item (lowest number for <)\n(pqueue-pop! pq)    ;; => (1 \"high-priority\")\n(pqueue-pop! pq)    ;; => (2 \"medium-priority\")\n(pqueue-pop! pq)    ;; => (3 \"low-priority\")\n(pqueue-pop! pq 'empty)  ;; => empty (default when empty)\n\n;; Peek without removing\n(pqueue-push! pq '(5 \"item\"))\n(pqueue-peek pq)    ;; => (5 \"item\")\n\n;; Check size and emptiness\n(pqueue-empty? pq)  ;; => #f\n(pqueue-size pq)    ;; => 1\n\n;; Get all contents (unordered)\n(pqueue-contents pq)\n\n;; Max-heap example (highest number first)\n(def max-pq (make-pqueue identity >))\n(pqueue-push! max-pq 10)\n(pqueue-push! max-pq 30)\n(pqueue-push! max-pq 20)\n(pqueue-pop! max-pq)   ;; => 30\n\n;; Task scheduling pattern\n(defstruct task (priority name) transparent: #t)\n(def scheduler (make-pqueue task-priority <))\n(pqueue-push! scheduler (make-task 1 \"critical\"))\n(pqueue-push! scheduler (make-task 5 \"background\"))\n(pqueue-push! scheduler (make-task 2 \"important\"))\n(task-name (pqueue-pop! scheduler))  ;; => \"critical\"",
    "notes": "make-pqueue takes a priority-extraction function and a comparator. The extraction function maps items to their priority values, and the comparator determines ordering (< for min-heap, > for max-heap). Uses a binary heap internally with 1-based vector indexing. Auto-resizes when full. O(log n) push and pop. pqueue-contents returns items in no particular order.",
    "related": [
      "rbtree-sorted-map"
    ]
  },
  {
    "id": "workgroup-thread-pool",
    "title": "Workgroup (thread pool) for parallel task execution",
    "tags": [
      "workgroup",
      "wg",
      "thread-pool",
      "parallel",
      "concurrent",
      "spawn",
      "worker",
      "fan-out"
    ],
    "imports": [
      ":std/misc/wg"
    ],
    "code": "(import :std/misc/wg)\n\n;; Create a workgroup with N worker threads\n(def wg (make-wg 4))  ;; 4 workers\n\n;; Add tasks (thunks) to the workgroup\n(for (i (in-range 10))\n  (wg-add! wg (lambda ()\n    (thread-sleep! 0.1)  ;; simulate work\n    (displayln \"task \" i \" done\"))))\n\n;; Wait for ALL tasks to complete\n;; Rethrows any exception from worker threads\n(wg-wait! wg)\n(displayln \"all done\")\n\n;; Pattern: parallel map with shared result collection\n(import :std/misc/atom)\n(def results (atom []))\n(def wg2 (make-wg 8))\n(for (item '(\"a\" \"b\" \"c\" \"d\" \"e\"))\n  (wg-add! wg2 (lambda ()\n    (let (result (string-append item \"-processed\"))\n      (atom-swap! results (lambda (lst) (cons result lst)))))))\n(wg-wait! wg2)\n(displayln (atom-deref results))\n\n;; Error handling: wg-wait! propagates first error\n(def wg3 (make-wg 2))\n(wg-add! wg3 (lambda () (error \"task failed!\")))\n(wg-add! wg3 (lambda () (displayln \"ok\")))\n(with-catch\n  (lambda (e) (displayln \"caught: \" (error-message e)))\n  (lambda () (wg-wait! wg3)))",
    "notes": "Workgroups create N worker threads that pull tasks from an internal channel. Workers run until the channel is closed. wg-wait! closes the channel and joins all workers, rethrowing any exception that occurred. Tasks are thunks (zero-argument procedures). For collecting results, use atoms or a shared channel since tasks run in parallel threads. The workgroup is single-use — after wg-wait!, create a new one for more work.",
    "related": [
      "atom-atomic-reference",
      "channel-based-communication"
    ]
  },
  {
    "id": "barrier-synchronization",
    "title": "Barrier synchronization for N threads to reach a checkpoint",
    "tags": [
      "barrier",
      "synchronization",
      "threads",
      "checkpoint",
      "wait",
      "concurrency",
      "rendezvous"
    ],
    "imports": [
      ":std/misc/barrier"
    ],
    "code": "(import :std/misc/barrier)\n\n;; Create a barrier for N threads\n(def b (make-barrier 3))\n\n;; Each thread signals when it reaches the checkpoint\n(for (i (in-range 3))\n  (spawn (lambda ()\n    (thread-sleep! (* i 0.1))  ;; simulate varying work\n    (displayln \"thread \" i \" reached barrier\")\n    (barrier-post! b)           ;; signal \"I'm done\"\n    (displayln \"thread \" i \" past barrier\"))))\n\n;; Main thread waits for all 3 to post\n(barrier-wait! b)\n(displayln \"all threads reached the barrier\")\n\n;; Error propagation: if any thread fails, all waiters get the error\n(def b2 (make-barrier 2))\n(spawn (lambda ()\n  (with-barrier-error b2\n    (error \"worker failed!\"))))\n;; barrier-wait! will re-raise the error\n(with-catch\n  (lambda (e) (displayln \"barrier error: \" (error-message e)))\n  (lambda () (barrier-wait! b2)))",
    "notes": "Barriers use a mutex + condition variable internally. barrier-post! increments a counter and broadcasts when it reaches the limit. barrier-wait! blocks until all expected threads have posted. with-barrier-error catches exceptions in the body and propagates them to all waiters via barrier-error!. Once a barrier fires (or errors), it cannot be reused — create a new one.",
    "related": [
      "workgroup-thread-pool",
      "completion-async-value"
    ]
  },
  {
    "id": "completion-async-value",
    "title": "Completion: one-shot async value/error container",
    "tags": [
      "completion",
      "async",
      "future",
      "promise",
      "one-shot",
      "concurrency",
      "wait",
      "result"
    ],
    "imports": [
      ":std/misc/completion"
    ],
    "code": "(import :std/misc/completion)\n\n;; Create a completion (like a one-shot promise/future)\n(def c (make-completion))\n\n;; Producer thread posts a value or error\n(spawn (lambda ()\n  (thread-sleep! 0.5)  ;; simulate async work\n  (completion-post! c 42)))\n\n;; Consumer blocks until value is available\n(def result (completion-wait! c))  ;; => 42\n\n;; Error propagation\n(def c2 (make-completion))\n(spawn (lambda ()\n  (completion-error! c2 (make-error \"async failure\"))))\n;; completion-wait! will raise the posted error\n(with-catch\n  (lambda (e) (displayln \"got error: \" (error-message e)))\n  (lambda () (completion-wait! c2)))\n\n;; with-completion-error: catch body errors and propagate to completion\n(def c3 (make-completion))\n(spawn (lambda ()\n  (with-completion-error c3\n    (let (result (risky-computation))\n      (completion-post! c3 result)))))\n;; If risky-computation throws, the error is posted to c3\n\n;; Pattern: async operation with timeout\n(def c4 (make-completion))\n(spawn (lambda ()\n  (let (data (fetch-remote-data))\n    (completion-post! c4 data))))\n;; Poll with timeout (using mutex-unlock! internally)\n(completion-wait! c4)  ;; blocks until ready",
    "notes": "Completions are one-shot: once a value or error is posted, it cannot be changed. Attempting to post twice raises an error. Multiple threads can wait on the same completion — all will be woken when the value is posted. completion-wait! returns the posted value or re-raises the posted error. This is simpler than channels for single-result async operations.",
    "related": [
      "barrier-synchronization",
      "channel-based-communication"
    ]
  },
  {
    "id": "rwlock-readers-writer",
    "title": "Read-write lock for multiple readers / single writer",
    "tags": [
      "rwlock",
      "read-write",
      "lock",
      "readers",
      "writer",
      "concurrent",
      "shared",
      "exclusive",
      "mutex"
    ],
    "imports": [
      ":std/misc/rwlock"
    ],
    "code": "(import :std/misc/rwlock)\n\n;; Create a read-write lock\n(def rw (make-rwlock))\n\n;; Multiple readers can hold the lock simultaneously\n(def shared-data (make-hash-table))\n\n;; Reader pattern (shared access)\n(def (read-data key)\n  (with-read-lock rw\n    (lambda () (hash-get shared-data key))))\n\n;; Writer pattern (exclusive access)\n(def (write-data key value)\n  (with-write-lock rw\n    (lambda () (hash-put! shared-data key value))))\n\n;; Manual lock/unlock (use with-read-lock/with-write-lock instead)\n;; (rwlock-read-lock! rw)\n;; (rwlock-read-unlock! rw)\n;; (rwlock-write-lock! rw)\n;; (rwlock-write-unlock! rw)\n\n;; Concurrent usage\n(for (i (in-range 10))\n  (spawn (lambda ()\n    (if (zero? (modulo i 3))\n      ;; Writer (every 3rd thread)\n      (write-data (string-append \"key\" (number->string i)) i)\n      ;; Reader\n      (let (v (read-data \"key0\"))\n        (displayln \"reader \" i \" got: \" v))))))",
    "notes": "Read-write locks allow multiple concurrent readers OR a single exclusive writer. with-read-lock and with-write-lock take a thunk (zero-argument lambda) and handle lock/unlock automatically, even on exceptions. Writers queue with a writers-waiting counter. When all readers release, waiting writers are woken. This is NOT a fair lock — readers can starve writers under heavy read load.",
    "related": [
      "atom-atomic-reference"
    ]
  },
  {
    "id": "chain-advanced-pipeline",
    "title": "Advanced chain pipeline with destructuring and named bindings",
    "tags": [
      "chain",
      "pipeline",
      "compose",
      "sugar",
      "transform",
      "destructure",
      "threading",
      "diamond"
    ],
    "imports": [
      ":std/sugar",
      ":std/iter"
    ],
    "code": "(import :std/sugar :std/iter)\n\n;; Basic chain: <> is the slot for the piped value\n(chain [1 2 3 4 5]\n  (filter odd? <>)\n  (map (cut * <> 10) <>)\n  (apply + <>))\n;; => 90 (1+3+5 = 9, *10 = 90)\n\n;; Unary functions don't need <>\n(chain \"Hello World\"\n  string-downcase\n  (string-split <> \" \")\n  car)\n;; => \"hello\"\n\n;; Destructuring in pipeline stages\n(chain [1 2 3 4 5]\n  ([head . tail] tail)           ;; destructure, keep tail\n  (map (cut + <> 10) <>))\n;; => (12 13 14 15)\n\n;; Named bindings for intermediate values\n(chain [1 2 3]\n  (xs (map number->string xs))   ;; bind as 'xs', use in expression\n  (string-join <> \", \"))\n;; => \"1, 2, 3\"\n\n;; Starting with <> creates a lambda (point-free style)\n(def add-and-sum\n  (chain <>\n    (map (cut + <> 1) <>)\n    (apply + <>)))\n(add-and-sum [1 2 3])  ;; => 9\n\n;; Mixing destructuring + named bindings\n(chain (iota 5)\n  ([_ . rest] rest)              ;; drop first element\n  (xs (map (cut * <> 2) xs))     ;; double remaining\n  (string-join (map number->string <>) \"-\"))\n;; => \"2-4-6-8\"",
    "notes": "chain from :std/sugar is a powerful pipeline macro. Three stage forms: (1) (expr <>): <> is replaced by the pipe value, (2) (name expr): binds pipe value to name for use in expr, (3) ([pat ...] expr): destructures the pipe value. When a stage is just a symbol (like string-downcase), it's treated as a unary function applied to the pipe value. Starting with <> creates a lambda for point-free style.",
    "related": [
      "collect-results-with-for-collect"
    ]
  },
  {
    "id": "is-predicate-factory",
    "title": "Smart predicate factory with 'is' macro",
    "tags": [
      "is",
      "predicate",
      "filter",
      "find",
      "sugar",
      "accessor",
      "compare",
      "lambda"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": "(import :std/sugar)\n\n;; (is accessor value) creates a predicate: (lambda (x) (equal? (accessor x) value))\n;; Auto-selects comparator based on value type:\n;;   numbers -> =, characters -> eqv?, strings -> string=?, else -> equal?\n\n;; Find by accessor + value\n(find (is car 'target) '((a . 1) (target . 2) (c . 3)))\n;; => (target . 2)\n\n;; Filter by accessor + predicate\n(filter (is cdr positive?) '((a . -1) (b . 5) (c . -2) (d . 3)))\n;; => ((b . 5) (d . 3))\n\n;; Compose accessor + comparison\n(filter (is string-length 3) '(\"hi\" \"foo\" \"x\" \"bar\" \"ab\"))\n;; => (\"foo\" \"bar\")\n\n;; With numeric comparison (uses =)\n(filter (is car 42) '((42 . a) (1 . b) (42 . c)))\n;; => ((42 . a) (42 . c))\n\n;; Accessor + predicate (tests result of accessor)\n(filter (is car symbol?) '((a . 1) (\"b\" . 2) (c . 3)))\n;; => ((a . 1) (c . 3))\n\n;; Identity accessor (is identity value) or just (is value)\n(filter (is identity even?) '(1 2 3 4 5 6))\n;; => (2 4 6)\n\n;; Custom test: keyword\n(find (is car 'x test: eq?) '((a 1) (x 2) (b 3)))\n;; => (x 2)",
    "notes": "The 'is' macro from :std/sugar generates compact predicate closures. When the second argument is a procedure, it's treated as a predicate applied to the accessor result: (is accessor pred?) => (lambda (x) (pred? (accessor x))). When it's a value, it's compared using auto-detected equality. This makes filter/find expressions very concise. Use test: keyword to override the equality comparator.",
    "related": [
      "chain-advanced-pipeline",
      "destructure-hash-tables-with-let-hash"
    ]
  },
  {
    "id": "custom-iterator-protocol",
    "title": "Implement custom :iter protocol for any type",
    "tags": [
      "iterator",
      "iter",
      "custom",
      "protocol",
      "for",
      "iterable",
      "defmethod",
      "generator",
      "make-iterator"
    ],
    "imports": [
      ":std/iter"
    ],
    "code": "(import :std/iter)\n\n;; To make any type iterable with for/for-collect/for-fold,\n;; implement the :iter method that returns a make-iterator object.\n\n;; Example: make a \"range-set\" iterable\n(defstruct range-set (ranges) transparent: #t)  ;; list of (lo . hi) pairs\n\n(defmethod (:iter (rs range-set))\n  (let (all-ranges (range-set-ranges rs))\n    ;; State: (current-value . remaining-ranges)\n    (def (next it)\n      (using (it :- iterator)\n        (match it.e\n          ([(? (lambda (p) (< (car p) (cdr p)))) . rest]\n           (let* ((current (caar it.e))\n                  (lo (caar it.e))\n                  (hi (cdar it.e)))\n             (if (< lo hi)\n               (begin\n                 (set! (caar it.e) (+ lo 1))\n                 lo)\n               ;; Move to next range\n               (if (pair? rest)\n                 (begin\n                   (set! it.e rest)\n                   (next it))\n                 iter-end))))\n          (_ iter-end))))\n    (if (pair? all-ranges)\n      (make-iterator all-ranges next)\n      (make-iterator '() (lambda (it) iter-end)))))\n\n;; Now it works with all for forms:\n(def rs (make-range-set '((0 . 3) (10 . 12))))\n(for/collect (x rs) x)  ;; => (0 1 2 10 11)\n\n;; Simpler example: iterator from a thunk (generator-style)\n(def (in-producer thunk)\n  (def (next it)\n    (let (v (thunk))\n      (if (eof-object? v) iter-end v)))\n  (make-iterator #f next))\n\n;; Iterator with cleanup (e.g., file handle)\n(def (in-file-lines path)\n  (let (port (open-input-file path))\n    (def (next it)\n      (let (line (read-line port))\n        (if (eof-object? line) iter-end line)))\n    (def (fini it)\n      (close-input-port port))\n    (make-iterator port next fini)))\n\n;; With cleanup, resources are freed even if loop exits early\n(for (line (in-file-lines \"/etc/hostname\"))\n  (displayln line))",
    "notes": "The iterator protocol requires: (1) define a :iter method on your type via defmethod, (2) return a make-iterator with state, next-fn, and optional fini-fn. The next function receives the iterator itself — access state via it.e (using (it :- iterator) for typed access). Return iter-end to signal completion. The fini function is called when iteration completes (even early exit). Register fini with make-will for GC cleanup of abandoned iterators. iter-end is a singleton — use iter-end? to test.",
    "related": [
      "collect-results-with-for-collect",
      "reduce-with-for-fold"
    ]
  },
  {
    "id": "coroutine-generator-pattern",
    "title": "Coroutine generators with yield for lazy sequences",
    "tags": [
      "coroutine",
      "generator",
      "yield",
      "lazy",
      "sequence",
      "continue",
      "producer",
      "stream"
    ],
    "imports": [
      ":std/coroutine"
    ],
    "code": "(import :std/coroutine)\n\n;; Basic generator with yield\n(def gen (coroutine (lambda ()\n  (yield 1)\n  (yield 2)\n  (yield 3)\n  'done)))\n\n(continue gen)  ;; => 1\n(continue gen)  ;; => 2\n(continue gen)  ;; => 3\n(continue gen)  ;; => done (return value)\n\n;; Generator with arguments\n(def (fibonacci)\n  (let loop ((a 0) (b 1))\n    (yield a)\n    (loop b (+ a b))))\n\n(def fib (coroutine fibonacci))\n(continue fib)  ;; => 0\n(continue fib)  ;; => 1\n(continue fib)  ;; => 1\n(continue fib)  ;; => 2\n(continue fib)  ;; => 3\n\n;; Iterate a coroutine with for (via :iter protocol)\n(import :std/iter)\n(def (range-gen start end)\n  (let loop ((i start))\n    (when (< i end)\n      (yield i)\n      (loop (+ i 1)))))\n\n(for/collect (x (in-coroutine range-gen 0 5))\n  (* x x))\n;; => (0 1 4 9 16)\n\n;; Cothread: thread-safe coroutine (heavier but concurrent)\n(def ct (cothread (lambda ()\n  (yield \"from thread 1\")\n  (yield \"from thread 2\"))))\n(continue ct)  ;; => \"from thread 1\"\n(cothread-stop! ct)  ;; clean shutdown\n\n;; Two-way communication: continue can pass values back to yield\n(def echo (coroutine (lambda ()\n  (let loop ()\n    (let (msg (yield 'ready))\n      (yield (string-append \"echo: \" msg))\n      (loop))))))\n(continue echo)           ;; => ready\n(continue echo \"hello\")   ;; => echo: hello\n(continue echo \"world\")   ;; => ready (next yield)\n(continue echo \"!\")        ;; => echo: !",
    "notes": "Coroutines are lightweight (single-threaded, continuation-based). yield suspends execution and returns a value to the caller. continue resumes the coroutine and optionally passes a value back into yield. Coroutines are NOT thread-safe — use cothreads for cross-thread generators. in-coroutine wraps a procedure into an iterator that terminates when the procedure returns. The return value of the procedure becomes the final iter-end signal.",
    "related": [
      "custom-iterator-protocol",
      "channel-based-communication"
    ]
  },
  {
    "id": "event-sync-select",
    "title": "Event system: sync and select for waiting on multiple sources",
    "tags": [
      "event",
      "sync",
      "select",
      "wait",
      "timeout",
      "concurrency",
      "multiplex",
      "condition-variable"
    ],
    "imports": [
      ":std/event"
    ],
    "code": "(import :std/event)\n\n;; wait: block on a single selector with optional timeout (seconds)\n(def t (spawn (lambda () (thread-sleep! 1) 'done)))\n(wait t 2)       ;; => t (thread completed within 2 seconds)\n\n;; select: race multiple selectors, return first ready\n(def t1 (spawn (lambda () (thread-sleep! 0.1) 'fast)))\n(def t2 (spawn (lambda () (thread-sleep! 1.0) 'slow)))\n(select [t1 t2] 2)  ;; => t1 (ready first)\n\n;; Wait on a condition variable (mutex+condvar pair)\n(def mx (make-mutex))\n(def cv (make-condition-variable))\n(spawn (lambda ()\n  (thread-sleep! 0.5)\n  (mutex-lock! mx)\n  (condition-variable-signal! cv)\n  (mutex-unlock! mx)))\n(mutex-lock! mx)\n(wait (cons mx cv) 2)  ;; blocks until signaled\n\n;; High-level events with handlers\n;; handle-evt: attach a handler to an event\n(sync (handle-evt always-evt (lambda (_) 'immediate)))  ;; => immediate\n\n;; choice-evt: first-ready-wins among multiple events\n(def result\n  (sync (choice-evt\n          (handle-evt (wrap-evt t1) (lambda (_) 'thread-done))\n          (handle-evt 2 (lambda (_) 'timeout)))))\n\n;; Timeout as event (number = seconds until ready)\n(sync (handle-evt 0.5 (lambda (_) 'timed-out)))  ;; => timed-out after 0.5s\n\n;; never-evt: never fires (useful as default in choice-evt)\n(sync never-evt 0)  ;; => #f (immediate timeout)\n\n;; Pattern: multiplexed I/O + timeout\n(def (read-with-timeout port seconds)\n  (let (ready (sync (choice-evt\n                      (wrap-evt port)\n                      (handle-evt seconds (lambda (_) #f)))))\n    (if ready\n      (read-line port)\n      'timeout)))",
    "notes": "The event system unifies threads, condition variables, and I/O readiness under one API. wait/select are low-level selectors. sync works with high-level events (wrap-evt, handle-evt, choice-evt). Selectors: threads (ready when terminated), (cons mutex condvar) pairs, I/O ports. Events: always-evt, never-evt, time values (seconds), wrap-evt (raw selector -> event), handle-evt (event + handler fn), choice-evt (OR of events). sync spawns internal threads to race selectors and cleans up after first fires.",
    "related": [
      "channel-based-communication",
      "barrier-synchronization"
    ]
  },
  {
    "id": "syntax-eval-compile-time",
    "title": "Compile-time computation with syntax-eval",
    "tags": [
      "syntax-eval",
      "compile-time",
      "macro",
      "constant",
      "precompute",
      "optimization",
      "begin-syntax"
    ],
    "imports": [
      ":std/sugar",
      ":std/misc/list-builder"
    ],
    "code": "(import :std/sugar :std/misc/list-builder)\n\n;; syntax-eval computes a value at compile time and embeds it as a constant\n;; The expression is evaluated during macro expansion, not at runtime\n\n;; Precompute a lookup table at compile time\n(def fibonacci-table\n  (syntax-eval\n    (list->vector\n      (with-list-builder (push!)\n        (let loop ((a 0) (b 1) (n 0))\n          (when (< n 20)\n            (push! a)\n            (loop b (+ a b) (+ n 1))))))))\n;; fibonacci-table is a vector literal in the compiled code\n;; No computation at runtime!\n\n(vector-ref fibonacci-table 10)  ;; => 55\n\n;; Precompute character classification tables\n(def digit-chars\n  (syntax-eval\n    (let (v (make-vector 128 #f))\n      (for-each (lambda (c) (vector-set! v (char->integer c) #t))\n                (string->list \"0123456789\"))\n      v)))\n\n;; begin-syntax: run arbitrary code at compile time\n(begin-syntax\n  (def (make-accessor-name prefix field)\n    (string->symbol\n      (string-append (symbol->string prefix) \"-\" (symbol->string field)))))\n\n;; syntax-call: call a compile-time function with syntax context\n;; Useful for generating identifiers based on macro expansion context\n(defsyntax (define-accessors stx)\n  (syntax-case stx ()\n    ((_ name field ...)\n     (with-syntax (((getter ...) (map (lambda (f)\n                                         (stx-identifier #'name\n                                           (symbol->string (stx-e #'name)) \"-\"\n                                           (symbol->string (stx-e f))))\n                                       #'(field ...))))\n       #'(begin\n           (def (getter obj) (slot-ref obj 'field)) ...)))))",
    "notes": "syntax-eval is from :std/sugar. The expression runs at compile time (macro expansion phase), so it can use any Scheme computation but NOT runtime values or side effects. The result must be a datum that can be embedded in compiled code (numbers, strings, vectors, lists, symbols, booleans). begin-syntax runs code in the compile-time environment for use by subsequent macros. syntax-call passes the macro's syntax context to a compile-time function.",
    "related": [
      "chain-advanced-pipeline"
    ]
  },
  {
    "id": "with-destroy-raii",
    "title": "RAII resource cleanup with with-destroy",
    "tags": [
      "with-destroy",
      "destroy",
      "raii",
      "cleanup",
      "resource",
      "finally",
      "unwind",
      "close"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": "(import :std/sugar)\n\n;; with-destroy ensures {destroy obj} is called on exit, even on exception\n;; The object must have a 'destroy' method\n\n(defclass connection (handle)\n  constructor: :init!)\n\n(defmethod {:init! connection}\n  (lambda (self handle:)\n    (set! self.handle handle)\n    (displayln \"opened connection \" handle)))\n\n(defmethod {destroy connection}\n  (lambda (self)\n    (displayln \"closing connection \" self.handle)\n    (set! self.handle #f)))\n\n;; Usage: guaranteed cleanup\n(def conn (make-connection handle: 42))\n(with-destroy conn\n  (displayln \"using connection \" conn.handle)\n  ;; even if this throws, destroy is called\n  (do-something-with conn))\n\n;; Multiple resources (nested)\n(with-destroy (make-connection handle: 1)\n  (lambda (c1)\n    (with-destroy (make-connection handle: 2)\n      (lambda (c2)\n        (use-both c1 c2)))))\n\n;; Equivalent to:\n;; (try (use resource) (finally {destroy resource}))",
    "notes": "with-destroy is from :std/sugar. It calls {destroy obj} in a finally clause. The object must implement a destroy method. This is Gerbil's equivalent of Python's context managers or C++ RAII. Common uses: database connections, file handles, network sockets, FFI resources. The destroy method should be idempotent (safe to call multiple times).",
    "related": [
      "completion-async-value"
    ]
  },
  {
    "id": "function-composition-combinators",
    "title": "Function composition and predicate combinators",
    "tags": [
      "compose",
      "rcompose",
      "every-of",
      "any-of",
      "predicate",
      "combinator",
      "func",
      "higher-order"
    ],
    "imports": [
      ":std/misc/func"
    ],
    "code": "(import :std/misc/func)\n\n;; compose1: right-to-left composition (single-value)\n(def add1-then-double (compose1 (cut * <> 2) 1+))\n(add1-then-double 3)  ;; => 8 ((3+1)*2)\n\n;; rcompose1: left-to-right composition (more readable)\n(def inc-double (rcompose1 1+ (cut * <> 2)))\n(inc-double 3)  ;; => 8\n\n;; compose/values: threads multiple return values\n(def (swap-and-add a b) (values b (+ a b)))\n(def transform (compose/values swap-and-add values))\n\n;; @compose1: macro version (no closure allocation, inlined)\n(def fast-fn (@compose1 string->number 1+ number->string))\n\n;; every-of: all predicates must match (AND combinator)\n(def valid-age? (every-of number? positive? (cut < <> 150)))\n(valid-age? 25)    ;; => #t\n(valid-age? -5)    ;; => #f\n(valid-age? \"hi\")  ;; => #f\n\n;; any-of: at least one predicate must match (OR combinator)\n(def number-like? (any-of number? string->number))\n(number-like? 42)    ;; => #t\n(number-like? \"42\")  ;; => 42 (truthy)\n(number-like? \"hi\")  ;; => #f\n\n;; pred-limit: predicate that matches only N times\n(def first-3-evens (pred-limit even? 3))\n(filter first-3-evens '(1 2 3 4 5 6 7 8 9 10))\n;; => (2 4 6)  -- only first 3 matches\n\n;; pred-sequence: match elements in order\n(def match-seq (pred-sequence '(1 2 3)))\n(match-seq 1)  ;; => #t\n(match-seq 2)  ;; => #t\n(match-seq 2)  ;; => #f (expected 3)\n\n;; repeat: apply function N times\n(repeat string-upcase 1 \"hello\")  ;; => \"HELLO\"",
    "notes": ":std/misc/func provides function composition and predicate combinators. compose1/rcompose1 are for single-value functions. compose/rcompose handle multi-value (values) returns. @compose1/@rcompose1 are macro versions that inline the composition — no closure allocated, better for hot paths. every-of/any-of create compound predicates from lists. pred-limit creates stateful predicates that only match a fixed number of times. pred-sequence matches elements in a specific order across calls.",
    "related": [
      "is-predicate-factory",
      "chain-advanced-pipeline"
    ]
  },
  {
    "id": "lazy-evaluation-delay-force",
    "title": "Lazy evaluation with lazy, force, and delay",
    "tags": [
      "lazy",
      "delay",
      "force",
      "thunk",
      "memoize",
      "deferred",
      "evaluation"
    ],
    "imports": [
      ":std/lazy"
    ],
    "code": "(import :std/lazy)\n\n;; lazy: wrap an expression for deferred evaluation\n(def expensive (lazy (begin (displayln \"computing...\") (* 6 7))))\n\n;; force: evaluate the lazy value (computed only once, then cached)\n(force expensive)  ;; prints \"computing...\" => 42\n(force expensive)  ;; => 42 (no print, cached)\n\n;; delay: alternative form (equivalent to lazy for simple cases)\n(def later (delay (+ 1 2)))\n(force later)  ;; => 3\n\n;; Lazy lists (recursive lazy evaluation)\n(def (lazy-range n)\n  (if (> n 0)\n    (lazy (cons n (lazy-range (- n 1))))\n    (lazy '())))\n\n(def r (lazy-range 5))\n(car (force r))           ;; => 5\n(car (force (cdr (force r)))) ;; => 4\n\n;; Pattern: lazy configuration loading\n(def config\n  (lazy (call-with-input-file \"config.json\" read-json)))\n\n;; Config is only loaded when first accessed\n(def (get-config key)\n  (hash-ref (force config) key))\n\n;; Pattern: memoized expensive computation\n(def (make-lazy-cache compute-fn)\n  (let (cache (make-hash-table))\n    (lambda (key)\n      (unless (hash-key? cache key)\n        (hash-put! cache key (lazy (compute-fn key))))\n      (force (hash-ref cache key)))))",
    "notes": ":std/lazy implements R7RS-style lazy evaluation. lazy wraps an expression — it won't be evaluated until force is called. Results are memoized: subsequent force calls return the cached value. The internal representation uses tagged cons cells: (lazy . thunk), (eager . promise), (resolved . value). delay is syntactic sugar for lazy. Cyclic force detection prevents infinite loops. Lazy values are useful for deferred initialization, infinite data structures, and expensive computations that may not be needed.",
    "related": [
      "coroutine-generator-pattern"
    ]
  },
  {
    "id": "amb-nondeterministic-search",
    "title": "Nondeterministic computation with amb (backtracking search)",
    "tags": [
      "amb",
      "nondeterministic",
      "backtracking",
      "search",
      "constraint",
      "choice",
      "puzzle",
      "solver"
    ],
    "imports": [
      ":std/amb"
    ],
    "code": "(import :std/amb)\n\n;; amb picks one of the choices; backtracks if amb-fail is called\n;; amb-find returns the first solution, amb-collect returns all\n\n;; Basic: find a value satisfying a constraint\n(amb-find\n  (let (x (amb 1 2 3 4 5))\n    (when (even? x) (amb-fail))  ;; reject even numbers\n    x))\n;; => 1 (first odd number)\n\n;; Collect all solutions\n(amb-collect\n  (let (x (amb 1 2 3 4 5))\n    (when (even? x) (amb-fail))\n    x))\n;; => (1 3 5)\n\n;; Constraint satisfaction: find Pythagorean triples\n(amb-collect\n  (let ((a (amb 1 2 3 4 5 6 7 8 9 10))\n        (b (amb 1 2 3 4 5 6 7 8 9 10))\n        (c (amb 1 2 3 4 5 6 7 8 9 10)))\n    (unless (and (<= a b) (= (+ (* a a) (* b b)) (* c c)))\n      (amb-fail))\n    (list a b c)))\n;; => ((3 4 5) (6 8 10))\n\n;; amb-assert: shorthand for (unless test (amb-fail))\n(amb-find\n  (let ((x (amb 1 2 3 4 5))\n        (y (amb 1 2 3 4 5)))\n    (amb-assert (= (+ x y) 6))\n    (amb-assert (> x y))\n    (list x y)))\n;; => (4 2) or (5 1)\n\n;; Custom strategy: shuffle choices for randomized search\n(parameterize ((amb-strategy shuffle))\n  (amb-find\n    (let (x (amb 1 2 3 4 5))\n      (amb-assert (odd? x))\n      x)))\n;; => random odd number from 1,3,5",
    "notes": ":std/amb implements McCarthy's ambiguous operator for nondeterministic programming. amb chooses one value from its arguments. If subsequent computation calls amb-fail, amb backtracks and tries the next choice. amb-find returns the first successful result. amb-collect gathers all solutions. amb-assert is sugar for (unless test (amb-fail)). amb-strategy controls iteration order: identity (default, left-to-right) or shuffle (randomized). Internally uses continuations (let/cc) for backtracking, running in a dedicated thread.",
    "related": [
      "coroutine-generator-pattern"
    ]
  },
  {
    "id": "generic-multi-dispatch",
    "title": "Generic functions with multi-method dispatch",
    "tags": [
      "generic",
      "defgeneric",
      "defmethod",
      "dispatch",
      "polymorphism",
      "multi-method",
      "overload"
    ],
    "imports": [
      ":std/generic"
    ],
    "code": "(import :std/generic)\n\n;; Define a generic function (dispatches on first argument's type)\n(defgeneric stringify)\n\n;; Add methods for different types\n(defmethod {stringify fixnum}\n  (lambda (n) (number->string n)))\n\n(defmethod {stringify string}\n  (lambda (s) (string-append \"\\\"\" s \"\\\"\")))\n\n(defmethod {stringify pair}\n  (lambda (p)\n    (string-append \"(\" (stringify (car p)) \" . \" (stringify (cdr p)) \")\")))\n\n(defmethod {stringify :t}  ;; default (any type)\n  (lambda (obj)\n    (call-with-output-string (lambda (p) (write obj p)))))\n\n;; Usage: dispatches based on argument type\n(stringify 42)            ;; => \"42\"\n(stringify \"hello\")       ;; => \"\\\"hello\\\"\"\n(stringify '(1 . \"a\"))    ;; => \"(1 . \\\"a\\\")\"\n(stringify #t)            ;; => \"#t\" (default method)\n\n;; Works with custom struct/class types\n(defstruct point (x y) transparent: #t)\n\n(defmethod {stringify point}\n  (lambda (p)\n    (format \"Point(~a, ~a)\" (point-x p) (point-y p))))\n\n(stringify (make-point 3 4))  ;; => \"Point(3, 4)\"\n\n;; Multi-arity generic\n(defgeneric combine)\n\n(defmethod {combine fixnum}\n  (lambda (a b) (+ a b)))\n\n(defmethod {combine string}\n  (lambda (a b) (string-append a b)))\n\n(combine 1 2)        ;; => 3\n(combine \"hi\" \" lo\") ;; => \"hi lo\"",
    "notes": ":std/generic provides CLOS-style generic functions that dispatch on the type of the first argument. defgeneric declares the function. defmethod adds a type-specialized implementation. Type names: fixnum, flonum, string, pair, vector, symbol, boolean, :t (default/any). For structs/classes, use the struct name directly. Methods are resolved using the type hierarchy — more specific types take priority. Use :t as a catch-all default method.",
    "related": [
      "custom-iterator-protocol"
    ]
  },
  {
    "id": "deque-double-ended-queue",
    "title": "Double-ended queue (deque) with O(1) front/back operations",
    "tags": [
      "deque",
      "double-ended",
      "queue",
      "push",
      "pop",
      "front",
      "back",
      "data-structure"
    ],
    "imports": [
      ":std/misc/deque"
    ],
    "code": "(import :std/misc/deque)\n\n;; Create a double-ended queue\n(def dq (make-deque))\n\n;; Push to front or back\n(push-front! dq 'a)\n(push-front! dq 'b)\n(push-back! dq 'c)\n;; deque is now: [b a c]\n\n;; Peek without removing\n(peek-front dq)   ;; => b\n(peek-back dq)    ;; => c\n\n;; Pop from front or back\n(pop-front! dq)   ;; => b\n(pop-back! dq)    ;; => c\n;; deque is now: [a]\n\n;; Pop with default (when empty)\n(pop-front! dq)        ;; => a\n(pop-front! dq 'empty) ;; => empty\n\n;; Check emptiness\n(deque-empty? dq)  ;; => #t\n(deque-length dq)  ;; => 0\n\n;; Convert to list\n(push-back! dq 1)\n(push-back! dq 2)\n(push-back! dq 3)\n(deque->list dq)   ;; => (1 2 3)\n\n;; Pattern: sliding window\n(def window (make-deque))\n(def window-size 3)\n(def (add-to-window! val)\n  (push-back! window val)\n  (when (> (deque-length window) window-size)\n    (pop-front! window)))\n\n(for-each add-to-window! '(1 2 3 4 5))\n(deque->list window)  ;; => (3 4 5)",
    "notes": "Deque from :std/misc/deque uses a doubly-linked list internally. All operations (push-front!, push-back!, pop-front!, pop-back!, peek-front, peek-back) are O(1). Nodes have prev/next pointers; #f indicates unlinked boundaries. NOT thread-safe — wrap with mutex for concurrent access. Useful for sliding windows, BFS, and work-stealing patterns.",
    "related": [
      "priority-queue-heap",
      "list-builder-efficient-append"
    ]
  },
  {
    "id": "run-process-subprocess",
    "title": "Run external processes and capture output",
    "tags": [
      "process",
      "subprocess",
      "exec",
      "command",
      "shell",
      "capture",
      "output",
      "pipe",
      "run"
    ],
    "imports": [
      ":std/misc/process"
    ],
    "code": "(import :std/misc/process)\n\n;; Run a command and capture stdout as string\n(run-process [\"ls\" \"-la\"] stdout-redirection: #t\n             coprocess: read-all-as-string)\n;; => \"total 42\\ndrwxr-xr-x ...\"\n\n;; Run with check-status (raises on non-zero exit)\n(run-process [\"grep\" \"-r\" \"pattern\" \"src/\"]\n             stdout-redirection: #t\n             coprocess: read-all-as-string\n             check-status: #t)\n\n;; Run a batch command (inherits stdin/stdout/stderr)\n(run-process/batch [\"make\" \"build\"])\n\n;; Filter: pipe input string through a command\n(filter-with-process [\"sort\" \"-n\"] \"3\\n1\\n2\\n\")\n;; => \"1\\n2\\n3\\n\"\n\n;; Custom coprocess: process output line by line\n(run-process [\"find\" \".\" \"-name\" \"*.ss\"]\n             stdout-redirection: #t\n             coprocess: (lambda (port)\n               (let loop ((lines []))\n                 (let (line (read-line port))\n                   (if (eof-object? line)\n                     (reverse lines)\n                     (loop (cons line lines)))))))\n\n;; Pass environment variables\n(run-process [\"env\"]\n             stdout-redirection: #t\n             coprocess: read-all-as-string\n             environment: (cons \"MY_VAR=hello\"\n                                (##command-line)))\n\n;; Invoke: simplified API for fire-and-forget\n(invoke \"echo\" [\"hello\" \"world\"])\n\n;; Getting exit status without exception\n(def proc (open-process [path: \"grep\" arguments: [\"-q\" \"pattern\" \"file.txt\"]]))\n(process-status proc)  ;; => 0 or 1",
    "notes": ":std/misc/process wraps Gambit's open-process. run-process is the main entry point: pass the command as a list [program arg ...]. stdout-redirection: #t captures stdout. coprocess receives the process port and returns a value (default: read-all-as-string). check-status: #t raises an exception on non-zero exit. run-process/batch inherits all I/O (for interactive or build commands). filter-with-process feeds a string to stdin and captures stdout. For Gambit-level control, use open-process directly with path: and arguments: keywords.",
    "related": [
      "read-file-to-string"
    ]
  },
  {
    "id": "repr-evaluable-printing",
    "title": "Evaluable object printing with repr (Python-style repr)",
    "tags": [
      "repr",
      "print",
      "display",
      "debug",
      "representation",
      "pr",
      "prn",
      "inspect"
    ],
    "imports": [
      ":std/misc/repr"
    ],
    "code": "(import :std/misc/repr)\n\n;; repr: convert any object to a string representation\n(repr 42)          ;; => \"42\"\n(repr \"hello\")     ;; => \"\\\"hello\\\"\"\n(repr '(1 2 3))    ;; => \"(1 2 3)\"\n(repr (hash (\"a\" 1) (\"b\" 2)))  ;; => \"(hash (\\\"a\\\" 1) (\\\"b\\\" 2))\"\n\n;; pr: print representation to a port (default: current-output-port)\n(pr 42)            ;; prints: 42\n(pr \"hello\")       ;; prints: \"hello\"\n\n;; prn: print representation + newline\n(prn '(1 2 3))     ;; prints: (1 2 3)\\n\n\n;; Custom repr for your structs via :pr method\n(defstruct point (x y) transparent: #t)\n\n(defmethod {:pr point}\n  (lambda (self port options)\n    (fprintf port \"(make-point ~a ~a)\" (point-x self) (point-y self))))\n\n(repr (make-point 3 4))  ;; => \"(make-point 3 4)\"\n\n;; display-separated: format lists with custom delimiters\n(display-separated '(1 2 3)\n  port: (current-output-port)\n  prefix: \"[\"\n  separator: \", \"\n  suffix: \"]\")\n;; prints: [1, 2, 3]\n\n;; Useful for debugging: print and return\n(def (debug-print label value)\n  (display label)\n  (display \": \")\n  (prn value)\n  value)\n\n(debug-print \"result\" (+ 1 2))  ;; prints: result: 3, returns 3",
    "notes": ":std/misc/repr provides Python-style repr for all Gerbil objects. The output is designed to be evaluable Scheme code when possible. For custom types, implement the :pr method (receives self, port, and options hash). Hash tables are printed in (hash ...) literal syntax. display-separated is useful for custom formatting with delimiters. If no :pr method exists, repr uses #<N #;\\\"obj\\\"> syntax with a serial number.",
    "related": [
      "chain-advanced-pipeline"
    ]
  },
  {
    "id": "assert-with-diagnostics",
    "title": "Assert with automatic sub-expression diagnostics",
    "tags": [
      "assert",
      "check",
      "debug",
      "diagnostic",
      "test",
      "invariant",
      "error-message"
    ],
    "imports": [
      ":std/assert"
    ],
    "code": "(import :std/assert)\n\n;; assert! checks a condition and reports sub-expression values on failure\n(def x 5)\n(def y 10)\n(assert! (< x y))  ;; passes silently\n\n;; On failure, reports values of all sub-expressions:\n(def a 10)\n(def b 3)\n;; (assert! (< (* a 2) b))\n;; Error: Assertion failed (< (* a 2) b)\n;;   a => 10\n;;   b => 3\n;;   (* a 2) => 20\n\n;; Custom error message\n;; (assert! (positive? x) \"x must be positive\")\n\n;; Pattern: function preconditions\n(def (divide a b)\n  (assert! (not (zero? b)))  ;; shows b's value on failure\n  (/ a b))\n\n;; Pattern: invariant checking in data structures\n(def (sorted? lst)\n  (or (null? lst) (null? (cdr lst))\n      (and (<= (car lst) (cadr lst))\n           (sorted? (cdr lst)))))\n\n(def (binary-search vec target)\n  (assert! (sorted? (vector->list vec)))\n  ;; ... search implementation\n  )",
    "notes": ":std/assert provides assert! which automatically extracts sub-expressions from the assertion condition and binds them to temporary variables. On failure, it reports each sub-expression and its value, making debugging much easier than a plain assertion. The macro uses compile-time analysis (split-sub-exprs) to identify which expressions to capture. Built-in identifiers are not rebound. Source location is preserved for error reporting.",
    "related": [
      "is-predicate-factory"
    ]
  },
  {
    "id": "actor-message-passing",
    "title": "Actor message passing with send, receive, and reply",
    "tags": [
      "actor",
      "message",
      "send",
      "receive",
      "reply",
      "mailbox",
      "concurrent",
      "defmessage",
      "rpc"
    ],
    "imports": [
      ":std/actor"
    ],
    "code": "(import :std/actor)\n\n;; Define message types\n(defmessage !ping ())\n(defmessage !echo (text))\n(defmessage !shutdown ())\n(defmessage !ok (value))\n\n;; Simple actor with message loop\n(def (my-actor)\n  (let/cc exit\n    (while #t\n      (<-  ;; receive and pattern match on messages\n        ((!ping)\n         (--> (!ok 'pong)))     ;; reply to sender\n\n        ((!echo text)\n         (--> (!ok (string-append \"Echo: \" text))))\n\n        ((!shutdown)\n         (-->? (!ok 'bye))      ;; reply only if expected\n         (exit 'shutdown))\n\n        (unexpected\n         (displayln \"unknown: \" @message))))))\n\n;; Start the actor server and spawn actor\n(def srv (start-actor-server! cookie: (make-random-cookie)))\n(def actor-thread (spawn/name 'my-actor my-actor))\n\n;; One-way send (fire and forget)\n(-> actor-thread (!ping))\n\n;; Request-reply (blocks until response or timeout)\n(def reply (->> actor-thread (!echo \"hello\") timeout: 5))\n;; reply => (!ok \"Echo: hello\")\n\n;; Context variables available inside <- handlers:\n;; @message       - the received message\n;; @source        - sender thread/handle\n;; @nonce         - message ID\n;; @reply-expected? - whether sender expects a reply\n;; @envelope      - full envelope struct\n\n;; Shutdown the actor\n(->> actor-thread (!shutdown) timeout: 5)",
    "notes": "Gerbil actors use thread mailboxes for message passing. defmessage defines a struct type for messages. <- receives and pattern-matches. -> sends one-way (fire-and-forget). ->> sends and waits for reply (RPC-style). --> sends a reply (only works inside <- handler). -->? sends reply only if the sender expects one. Context syntax parameters (@source, @nonce, etc.) are bound inside <- handlers via syntax-parameterize. Actors are just threads — spawn/name creates them. start-actor-server! is needed for remote/ensemble actors.",
    "related": [
      "channel-based-communication",
      "event-sync-select"
    ]
  },
  {
    "id": "port-utilities-file-io",
    "title": "File I/O utilities: read/write files, strings, lines, bytes",
    "tags": [
      "port",
      "file",
      "read",
      "write",
      "string",
      "lines",
      "bytes",
      "io",
      "utility"
    ],
    "imports": [
      ":std/misc/ports"
    ],
    "code": "(import :std/misc/ports)\n\n;; Read entire file as string\n(def content (read-file-string \"path/to/file.txt\"))\n\n;; Read file as list of lines\n(def lines (read-file-lines \"path/to/file.txt\"))\n\n;; Read from port as string\n(def text (call-with-input-file \"file.txt\" read-all-as-string))\n\n;; Read from port as u8vector (binary)\n(def bytes (call-with-input-file \"file.bin\" read-all-as-u8vector))\n\n;; Write string to file\n(write-file-string \"output.txt\" \"hello world\\n\")\n\n;; Write lines to file\n(write-file-lines \"output.txt\" '(\"line 1\" \"line 2\" \"line 3\"))\n\n;; Macro forms with automatic port binding\n(with-input \"file.txt\"\n  (read-line))  ;; reads from file bound to current-input-port\n\n(with-output \"out.txt\"\n  (displayln \"hello\"))  ;; writes to file\n\n;; Copy between ports\n(call-with-input-file \"source.txt\"\n  (lambda (in)\n    (call-with-output-file \"dest.txt\"\n      (lambda (out)\n        (copy-port in out)))))\n\n;; Functional forms\n(call-with-input \"file.txt\" (lambda (port) (read-json port)))\n(call-with-output \"file.txt\" (lambda (port) (write-json data port)))",
    "notes": ":std/misc/ports provides convenience wrappers for common file I/O patterns. read-file-string and read-file-lines are the most commonly needed. write-file-string and write-file-lines handle opening/closing automatically. copy-port auto-detects byte vs character ports. with-input/with-output are macros that parameterize current-input-port/current-output-port. For binary I/O, use read-all-as-u8vector. All functions handle port closing on exceptions.",
    "related": [
      "read-file-to-string",
      "read-file-as-list-of-lines"
    ]
  },
  {
    "id": "interface-contracts",
    "title": "Define and implement interfaces with type contracts",
    "tags": [
      "interface",
      "contract",
      "type",
      "protocol",
      "defmethod",
      "polymorphism",
      "using",
      "typed"
    ],
    "imports": [
      ":std/interface"
    ],
    "code": "(import :std/interface)\n\n;; Define an interface\n(interface Printable\n  (to-string)\n  (display-to port))\n\n(interface Comparable\n  (compare-to other))\n\n;; Implement for a struct\n(defstruct point (x y) transparent: #t)\n\n(defmethod {to-string point}\n  (lambda (self)\n    (format \"Point(~a, ~a)\" (point-x self) (point-y self))))\n\n(defmethod {display-to point}\n  (lambda (self port)\n    (display (to-string self) port)))\n\n(defmethod {compare-to point}\n  (lambda (self other)\n    (let ((d1 (+ (* (point-x self) (point-x self))\n                  (* (point-y self) (point-y self))))\n          (d2 (+ (* (point-x other) (point-x other))\n                  (* (point-y other) (point-y other)))))\n      (- d1 d2))))\n\n;; Use interface as type contract in function signatures\n(def (print-it (obj : Printable))\n  (displayln {obj.to-string}))\n\n(def (sort-items (items : :list))\n  (sort items (lambda (a b)\n    (< {a.compare-to b} 0))))\n\n;; 'using' for typed, optimized access (no dynamic dispatch)\n(def (fast-print (p :- point))\n  (using (p :- point)\n    (displayln \"x=\" p.x \" y=\" p.y)))\n\n;; Multiple typed bindings\n(def (add-points (p1 :- point) (p2 :- point))\n  (using ((p1 :- point) (p2 :- point))\n    (make-point (+ p1.x p2.x) (+ p1.y p2.y))))\n\n(print-it (make-point 3 4))  ;; => Point(3, 4)\n(fast-print (make-point 1 2)) ;; => x=1 y=2",
    "notes": "Interfaces define a protocol (set of methods) that types can implement. Use (obj : InterfaceName) in function signatures for runtime type checking. Use (obj :- StructType) with 'using' for compile-time optimized access without dynamic dispatch — this inlines field accesses. Interface methods are called via {obj.method args} syntax. Interfaces compose: a type can implement multiple interfaces. Type contracts raise errors at call time if the wrong type is passed.",
    "related": [
      "generic-multi-dispatch",
      "with-destroy-raii"
    ]
  },
  {
    "id": "defmethod-alias-multi-name",
    "title": "Create method aliases with defmethod/alias",
    "tags": [
      "defmethod",
      "alias",
      "method",
      "rename",
      "multiple-names",
      "dispatch",
      "oop"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": "(import :std/sugar)\n\n;; defmethod/alias: one implementation, multiple method names\n(defclass animal (name sound) transparent: #t)\n\n(defmethod/alias {speak (talk say) animal}\n  (lambda (self)\n    (string-append (@ self name) \" says \" (@ self sound))))\n\n;; All three names dispatch to the same implementation\n(def dog (make-animal \"Rex\" \"woof\"))\n{speak dog}    ;; => \"Rex says woof\"\n{talk dog}     ;; => \"Rex says woof\"\n{say dog}      ;; => \"Rex says woof\"\n\n;; Useful for API compatibility: provide both short and long names\n(defclass logger (level) transparent: #t)\n\n(defmethod/alias {log (write-log emit) logger}\n  (lambda (self msg)\n    (when (>= (@ self level) 1)\n      (displayln \"[LOG] \" msg))))\n\n(def lg (make-logger 1))\n{log lg \"hello\"}        ;; => [LOG] hello\n{write-log lg \"world\"}  ;; => [LOG] world\n{emit lg \"!\"}           ;; => [LOG] !",
    "notes": "defmethod/alias from :std/sugar maps multiple method names to a single implementation. Syntax: {primary-name (alias1 alias2 ...) ClassName}. All names create separate method entries in the dispatch table, but they all point to the same lambda. Useful for providing backwards-compatible names or short/long variants of the same operation.",
    "related": [
      "generic-multi-dispatch",
      "interface-contracts"
    ]
  },
  {
    "id": "awhen-anaphoric-conditional",
    "title": "Anaphoric when (awhen) for concise null-checking",
    "tags": [
      "awhen",
      "anaphoric",
      "when",
      "null-check",
      "optional",
      "binding",
      "sugar"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": "(import :std/sugar)\n\n;; awhen: bind a value, execute body only if truthy\n;; (awhen (var expr) body ...) => (let (var expr) (when var body ...))\n\n;; Common pattern: lookup and use\n(def table (hash (\"key1\" 42) (\"key2\" \"hello\")))\n\n(awhen (v (hash-get table \"key1\"))\n  (displayln \"found: \" v))  ;; prints: found: 42\n\n(awhen (v (hash-get table \"missing\"))\n  (displayln \"found: \" v))  ;; does nothing (#f from hash-get)\n\n;; Chain of lookups\n(def config (hash (\"db\" (hash (\"host\" \"localhost\") (\"port\" 5432)))))\n\n(awhen (db (hash-get config \"db\"))\n  (awhen (host (hash-get db \"host\"))\n    (displayln \"connecting to \" host)))\n\n;; With side effects\n(awhen (pid (find-process \"myapp\"))\n  (kill-process pid)\n  (displayln \"killed process \" pid))\n\n;; Compare with verbose alternative:\n;; (let (v (hash-get table \"key1\"))\n;;   (when v\n;;     (displayln \"found: \" v)))",
    "notes": "awhen from :std/sugar is shorthand for let + when. The bound variable is available in the body. Returns void if the expression is #f. This is much more concise than the let+when pattern for optional value handling. Works well with hash-get (returns #f on missing keys), find (returns #f if not found), and other functions that return #f for absence.",
    "related": [
      "destructure-hash-tables-with-let-hash",
      "is-predicate-factory"
    ]
  },
  {
    "id": "shuffle-random-permutation",
    "title": "Fisher-Yates shuffle for random permutations",
    "tags": [
      "shuffle",
      "random",
      "permutation",
      "randomize",
      "vector",
      "list",
      "sample"
    ],
    "imports": [
      ":std/misc/shuffle"
    ],
    "code": "(import :std/misc/shuffle)\n\n;; Shuffle a list (returns new list)\n(shuffle '(1 2 3 4 5))  ;; => (3 1 5 2 4) (random order)\n\n;; Shuffle a vector (returns new vector)\n(vector-shuffle #(a b c d e))  ;; => #(c a e b d)\n\n;; Shuffle vector in-place (mutates)\n(def v #(1 2 3 4 5))\n(vector-shuffle! v)  ;; v is now randomly permuted\n\n;; Custom random number generator\n(import :std/crypto)\n(shuffle '(1 2 3 4 5) random-integer)\n\n;; Pattern: random sampling (take first N after shuffle)\n(def (random-sample lst n)\n  (take (shuffle lst) (min n (length lst))))\n\n(random-sample '(a b c d e f g) 3)  ;; => e.g. (d a f)",
    "notes": ":std/misc/shuffle implements Fisher-Yates (Knuth) shuffle, which produces uniformly distributed random permutations. shuffle copies the list to a vector, shuffles in-place, then converts back. vector-shuffle returns a new vector; vector-shuffle! mutates. An optional second argument provides a custom RNG: (lambda (n) -> integer in [0, n)). Default uses Gambit's random-integer.",
    "related": [
      "amb-nondeterministic-search"
    ]
  },
  {
    "id": "with-id-identifier-generation",
    "title": "Generate identifiers at macro time with with-id",
    "tags": [
      "with-id",
      "macro",
      "identifier",
      "generate",
      "metaprogramming",
      "syntax",
      "defsyntax",
      "hygiene"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": "(import :std/sugar)\n\n;; with-id generates new identifiers by concatenating strings/symbols\n;; at macro expansion time. Useful for defining families of related functions.\n\n;; Example: generate getter/setter pairs from a name\n(defrules define-property ()\n  ((_ name initial)\n   (with-id name ((getter #'name)\n                  (setter #'name \"-set!\"))\n     (begin\n       (def getter initial)\n       (def (setter v) (set! getter v))))))\n\n(define-property my-counter 0)\nmy-counter          ;; => 0\n(my-counter-set! 5)\nmy-counter          ;; => 5\n\n;; with-id syntax: (with-id context-id ((new-id parts ...) ...) body)\n;; parts can be: #'identifier, \"string\", or 'symbol\n;; They're concatenated to form the new identifier name\n\n;; Example: defvar macro for indexed memory access\n(defrules defvar ()\n  ((_ name n vec)\n   (with-id name ((idx #'name \"@\")\n                  (get #'name \"-get\")\n                  (set! #'name \"-set!\"))\n     (begin\n       (def idx n)\n       (def (get) (vector-ref vec idx))\n       (def (set! v) (vector-set! vec idx v))))))\n\n(def mem (make-vector 10 0))\n(defvar x 0 mem)\n(defvar y 1 mem)\n(x-set! 42)\n(y-set! 99)\n(x-get)   ;; => 42\nx@        ;; => 0 (the index)\n\n;; with-id/expr: same but wraps body in (let () ...) for expression context\n;; Use when you need the result as a value, not at top level",
    "notes": "with-id from :std/sugar is for advanced macro writing where you need to create related identifier names programmatically. The context identifier determines the hygiene scope — new identifiers are created in the same scope as the context. Parts are concatenated as strings to form the new name: #'id extracts the symbol name, \"string\" is literal, 'symbol converts to string. with-id/expr wraps in (let () ...) so it can be used in expression position.",
    "related": [
      "syntax-eval-compile-time"
    ]
  },
  {
    "id": "if-let-when-let-conditional-bind",
    "title": "Conditional binding with if-let and when-let (short-circuit on #f)",
    "tags": [
      "if-let",
      "when-let",
      "conditional",
      "binding",
      "optional",
      "short-circuit",
      "sugar",
      "guard"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": "(import :std/sugar)\n\n;; if-let: bind variables, run then-branch if ALL are truthy\n;; If any binding is #f, immediately run else-branch\n(def ht (hash (\"name\" \"Alice\") (\"age\" 30)))\n\n(if-let ((name (hash-get ht \"name\"))\n         (age (hash-get ht \"age\")))\n  (format \"~a is ~a years old\" name age)\n  \"missing data\")\n;; => \"Alice is 30 years old\"\n\n(if-let ((name (hash-get ht \"name\"))\n         (email (hash-get ht \"email\")))  ;; #f — not found\n  (format \"~a: ~a\" name email)\n  \"missing data\")\n;; => \"missing data\" (short-circuited at email)\n\n;; when-let: like if-let but no else branch (returns void if #f)\n(when-let ((name (hash-get ht \"name\")))\n  (displayln \"Hello, \" name \"!\"))\n;; prints: Hello, Alice!\n\n(when-let ((email (hash-get ht \"email\")))\n  (send-notification email))\n;; does nothing (email is #f)\n\n;; Single binding form\n(if-let (x (find even? '(1 3 5 7)))\n  (displayln \"found even: \" x)\n  (displayln \"no even numbers\"))\n\n;; Chaining lookups\n(if-let ((config (load-config))\n         (db (hash-get config \"database\"))\n         (host (hash-get db \"host\")))\n  (connect host)\n  (error \"incomplete configuration\"))",
    "notes": "if-let and when-let from :std/sugar provide conditional binding that short-circuits on #f. Each binding is tested in order — if any evaluates to #f, the else branch (for if-let) runs immediately without evaluating subsequent bindings. This is implemented using let/cc for early exit. Perfect for chaining optional lookups (hash-get, find, etc.) where any step might fail. when-let returns void when the condition is false.",
    "related": [
      "awhen-anaphoric-conditional",
      "destructure-hash-tables-with-let-hash"
    ]
  },
  {
    "id": "alet-star-anaphoric-let",
    "title": "alet/alet* — anaphoric let that short-circuits on #f",
    "tags": [
      "alet",
      "alet*",
      "and-let",
      "short-circuit",
      "pipeline",
      "optional",
      "binding",
      "chained"
    ],
    "imports": [],
    "code": ";; alet* is a built-in (no import needed) that works like let*\n;; but short-circuits to #f if any binding evaluates to #f\n\n;; Chained lookups — returns #f if any step fails\n(def config (hash (\"db\" (hash (\"host\" \"localhost\") (\"port\" 5432)))))\n\n(alet* ((db (hash-get config \"db\"))\n        (host (hash-get db \"host\"))\n        (port (hash-get db \"port\")))\n  (string-append host \":\" (number->string port)))\n;; => \"localhost:5432\"\n\n(alet* ((db (hash-get config \"db\"))\n        (ssl (hash-get db \"ssl\")))  ;; #f - not found\n  (displayln \"SSL: \" ssl))\n;; => #f (short-circuited, body never runs)\n\n;; Works like a null-safe navigation chain (?.operator in other langs)\n(alet* ((user (find-user id))\n        (address (user-address user))\n        (city (address-city address)))\n  city)\n;; Returns city or #f if any step fails\n\n;; alet (non-star): bindings are independent (like let, not let*)\n(alet ((x (hash-get ht \"x\"))\n       (y (hash-get ht \"y\")))\n  (+ x y))\n\n;; and-let* is the SRFI-2 equivalent\n;; (and-let* ((x expr1) (y expr2)) body)\n;; Same semantics: short-circuit on #f",
    "notes": "alet* is built into Gerbil core (no import needed). It behaves like let* but returns #f immediately if any binding evaluates to #f, without evaluating subsequent bindings or the body. This is Gerbil's answer to null-safe navigation (like ?. in Kotlin/Swift). alet is the parallel binding version (like let). and-let* from SRFI-2 has similar semantics. Use alet* for chaining operations that may return #f (hash-get, find, assoc, etc.).",
    "related": [
      "if-let-when-let-conditional-bind",
      "awhen-anaphoric-conditional"
    ]
  },
  {
    "id": "logger-per-source-config",
    "title": "Structured logging with per-source level configuration",
    "tags": [
      "logger",
      "logging",
      "debug",
      "info",
      "warn",
      "error",
      "verbose",
      "level",
      "source"
    ],
    "imports": [
      ":std/logger"
    ],
    "code": "(import :std/logger)\n\n;; Basic logging (uses current-logger-options)\n(errorf \"critical: ~a\" \"disk full\")     ;; ERROR level\n(warnf \"caution: ~a\" \"low memory\")      ;; WARN level\n(infof \"status: ~a\" \"running\")          ;; INFO level\n(debugf \"detail: ~a\" \"processing x\")    ;; DEBUG level\n(verbosef \"trace: ~a\" \"entered fn\")     ;; VERBOSE level\n\n;; Set global log level (0=ERROR, 1=WARN, 2=INFO, 3=DEBUG, 4=VERBOSE)\n(current-logger-options (make-logger-options 2))  ;; INFO and above\n\n;; Per-source log levels\n(def opts (make-logger-options\n            2  ;; default: INFO\n            (hash ('network 4)    ;; network: VERBOSE\n                  ('database 1)))) ;; database: WARN only\n\n(current-logger-options opts)\n\n;; Now logging uses source-specific levels:\n(debugf \"~a\" \"general debug\")          ;; suppressed (default=INFO)\n(verbosef source: 'network \"~a\" \"x\")   ;; printed (network=VERBOSE)\n(debugf source: 'database \"~a\" \"y\")    ;; suppressed (database=WARN)\n(warnf source: 'database \"~a\" \"z\")     ;; printed\n\n;; Log level names to numbers\n;; (log-level 'ERROR)   => 0\n;; (log-level 'WARN)    => 1\n;; (log-level 'INFO)    => 2\n;; (log-level 'DEBUG)   => 3\n;; (log-level 'VERBOSE) => 4\n\n;; Pattern: per-module logger\n(def (my-module-log msg . args)\n  (apply debugf source: 'my-module msg args))",
    "notes": ":std/logger provides printf-style logging with five levels. current-logger-options is a parameter holding the logger configuration. make-logger-options takes a default level and optional hash of source-specific overrides. Source is a symbol identifying the subsystem. All log functions (errorf, warnf, infof, debugf, verbosef) accept an optional source: keyword. Messages below the configured level are suppressed. Thread-local caching is used for performance.",
    "related": [
      "repr-evaluable-printing"
    ]
  },
  {
    "id": "getopt-cli-parsing",
    "title": "Command-line argument parsing with getopt",
    "tags": [
      "getopt",
      "cli",
      "command-line",
      "argument",
      "option",
      "flag",
      "subcommand",
      "parse"
    ],
    "imports": [
      ":std/getopt"
    ],
    "code": "(import :std/getopt)\n\n;; Define CLI options\n(def my-opts\n  (getopt\n    (flag 'verbose \"-v\" \"--verbose\"\n      help: \"Enable verbose output\")\n    (option 'output \"-o\" \"--output\"\n      help: \"Output file path\"\n      default: \"out.txt\")\n    (option 'count \"-n\" \"--count\"\n      help: \"Number of iterations\"\n      value: string->number\n      default: 1)\n    (argument 'input\n      help: \"Input file\")\n    (optional-argument 'extra\n      help: \"Optional extra file\"\n      default: #f)))\n\n;; Parse arguments\n(def args (call-with-getopt \"myapp\" my-opts\n            (lambda (opt) opt)   ;; handler receives parsed options hash\n            args: '(\"-v\" \"-n\" \"5\" \"-o\" \"result.txt\" \"input.txt\")))\n;; args => hash with: verbose=#t, output=\"result.txt\", count=5, input=\"input.txt\"\n\n;; With subcommands\n(def cli\n  (getopt\n    (command 'build\n      help: \"Build the project\"\n      (flag 'release \"--release\" help: \"Release build\")\n      (option 'target \"-t\" help: \"Target platform\"))\n    (command 'test\n      help: \"Run tests\"\n      (flag 'verbose \"-v\" help: \"Verbose output\")\n      (rest-arguments 'files help: \"Test files\"))))\n\n;; call-with-getopt handles help display and error reporting\n(def (main . args)\n  (call-with-getopt \"myapp\" cli\n    (lambda (cmd opt)\n      (case cmd\n        ((build) (do-build opt))\n        ((test) (do-test opt))))\n    args: args))\n\n;; Access parsed options\n(def (do-build opt)\n  (let-hash opt\n    (when .?release (displayln \"Release mode\"))\n    (displayln \"Target: \" (or .?target \"default\"))))",
    "notes": ":std/getopt provides declarative CLI argument parsing. flag creates boolean switches. option creates key-value options (value: provides a converter function). argument is a required positional arg. optional-argument is optional. rest-arguments collects remaining args as a list. command creates subcommands. call-with-getopt invokes the handler with parsed results and handles --help display and error messages automatically. Results are returned as a hash table — use let-hash for convenient access.",
    "related": [
      "destructure-hash-tables-with-let-hash"
    ]
  },
  {
    "id": "csv-parsing-options",
    "title": "CSV parsing with configurable options and predefined standards",
    "tags": [
      "csv",
      "parse",
      "read",
      "write",
      "text",
      "delimiter",
      "rfc4180",
      "options"
    ],
    "imports": [
      ":std/text/csv"
    ],
    "code": "(import :std/text/csv)\n\n;; Read CSV from a file (returns list of lists)\n(def rows\n  (call-with-input-file \"data.csv\"\n    (lambda (port)\n      (read-csv-records port))))\n\n;; Write CSV records\n(call-with-output-file \"output.csv\"\n  (lambda (port)\n    (for-each (lambda (row) (write-csv-record row port))\n              '((\"name\" \"age\" \"city\")\n                (\"Alice\" \"30\" \"NYC\")\n                (\"Bob\" \"25\" \"LA\")))))\n\n;; Custom CSV options\n(def my-opts\n  (make-csv-options\n    separator: #\\tab       ;; tab-separated\n    quote-char: #\\\"        ;; quote character\n    unquoted-quotequote?: #f\n    loose-quote?: #f\n    newline: 'lf))\n\n;; Use custom options via parameterize\n(parameterize ((current-csv-options my-opts))\n  (call-with-input-file \"data.tsv\" read-csv-records))\n\n;; Or with call-with-csv-options\n(call-with-csv-options my-opts\n  (lambda ()\n    (call-with-input-file \"data.tsv\" read-csv-records)))\n\n;; Predefined option sets\n;; csv-options/rfc4180           - strict RFC 4180\n;; csv-options/rfc4180-strict    - stricter variant\n;; csv-options/creativyst        - Creativyst CSV standard\n\n;; Read a single record at a time\n(call-with-input-file \"data.csv\"\n  (lambda (port)\n    (let loop ()\n      (let (record (read-csv-record port))\n        (unless (eof-object? record)\n          (displayln record)\n          (loop))))))\n\n;; Convert CSV to hash tables (first row as headers)\n(def (csv->hashes port)\n  (let* ((headers (read-csv-record port))\n         (records (read-csv-records port)))\n    (map (lambda (row)\n           (let (ht (make-hash-table))\n             (for-each (lambda (h v) (hash-put! ht h v))\n                       headers row)\n             ht))\n         records)))",
    "notes": ":std/text/csv provides RFC 4180 compliant CSV parsing. read-csv-records reads all records from a port. read-csv-record reads one record. write-csv-record writes one record. CSV options are configured via make-csv-options with: separator (default #\\,), quote-char, newline ('lf, 'cr, 'crlf, 'lax). Use current-csv-options parameter or call-with-csv-options for custom settings. Predefined: csv-options/rfc4180 for standard CSV.",
    "related": [
      "port-utilities-file-io"
    ]
  },
  {
    "id": "in-range-iota-naturals-iterators",
    "title": "Numeric iterators: in-range, in-iota, in-naturals",
    "tags": [
      "in-range",
      "in-iota",
      "in-naturals",
      "iterator",
      "numeric",
      "sequence",
      "loop",
      "range"
    ],
    "imports": [
      ":std/iter"
    ],
    "code": "(import :std/iter)\n\n;; in-range: iterate between bounds (auto-detects step direction)\n(for/collect (x (in-range 5)) x)            ;; => (0 1 2 3 4)\n(for/collect (x (in-range 2 7)) x)          ;; => (2 3 4 5 6)\n(for/collect (x (in-range 0 10 2)) x)       ;; => (0 2 4 6 8)\n(for/collect (x (in-range 5 0)) x)          ;; => (5 4 3 2 1) auto negative step!\n(for/collect (x (in-range 10 0 -3)) x)      ;; => (10 7 4 1)\n\n;; in-iota: fixed count from a start (SRFI-1 iota semantics)\n(for/collect (x (in-iota 5)) x)             ;; => (0 1 2 3 4) — 5 elements from 0\n(for/collect (x (in-iota 3 10)) x)          ;; => (10 11 12) — 3 elements from 10\n(for/collect (x (in-iota 4 0 0.5)) x)       ;; => (0 0.5 1.0 1.5) — step 0.5\n\n;; in-naturals: infinite sequence (must limit with another iterator or when)\n(for/collect ((x (in-naturals))\n              (_ (in-range 5)))  ;; limit to 5\n  x)\n;; => (0 1 2 3 4)\n\n(for/collect (x (in-naturals 10 2) when (< x 20))\n  x)\n;; WARNING: for/collect with in-naturals + when may not terminate!\n;; Use a finite iterator to bound it instead.\n\n;; Combine infinite with finite (stops when shortest ends)\n(for/collect ((i (in-naturals))\n              (ch \"hello\"))\n  (cons i ch))\n;; => ((0 . #\\h) (1 . #\\e) (2 . #\\l) (3 . #\\l) (4 . #\\o))\n\n;; in-indexed: add index to any iterable\n(for/collect ((val idx) (in-indexed '(a b c)))\n  (list idx val))\n;; => ((0 a) (1 b) (2 c))\n\n;; Port iterators\n;; (in-input-lines port)  — iterate lines\n;; (in-input-chars port)  — iterate characters\n;; (in-input-bytes port)  — iterate bytes",
    "notes": "Key differences: in-range takes (end), (start end), or (start end step) and auto-detects direction. in-iota takes (count), (count start), or (count start step) — always count-based. in-naturals is infinite — MUST be bounded by pairing with a finite iterator. When multiple iterators are used in for/collect, iteration stops when the shortest one ends. All three compile to tight loops (no iterator protocol overhead) when used directly in for/for-collect/for-fold.",
    "related": [
      "collect-results-with-for-collect",
      "reduce-with-for-fold"
    ]
  },
  {
    "id": "path-manipulation-utilities",
    "title": "Path manipulation utilities (string-based, no filesystem)",
    "tags": [
      "path",
      "file",
      "directory",
      "extension",
      "join",
      "subpath",
      "normalize",
      "relative"
    ],
    "imports": [
      ":std/misc/path"
    ],
    "code": "(import :std/misc/path)\n\n;; Join path components\n(subpath \"/home\" \"user\" \"docs\" \"file.txt\")\n;; => \"/home/user/docs/file.txt\"\n\n;; Check if path is under a base\n(subpath? \"/home/user/docs/file.txt\" \"/home/user\")\n;; => #t\n(subpath? \"/etc/passwd\" \"/home/user\")\n;; => #f\n\n;; File extension operations\n(path-extension \"file.txt\")                    ;; => \".txt\"\n(path-strip-extension \"file.txt\")              ;; => \"file\"\n(path-force-extension \"file.txt\" \".md\")        ;; => \"file.md\"\n(path-default-extension \"file\" \".txt\")         ;; => \"file.txt\"\n(path-default-extension \"file.md\" \".txt\")      ;; => \"file.md\" (already has ext)\n\n;; Relative path computation\n(path-enough \"/home/user/docs/file.txt\" \"/home/user\")\n;; => \"docs/file.txt\"\n\n;; Simplify path (remove . and ..)\n(path-simplify \"/home/user/../admin/./docs\")\n;; => \"/home/admin/docs\"\n\n;; Absolute path check\n(path-absolute? \"/home/user\")   ;; => #t\n(path-absolute? \"relative/path\") ;; => #f\n\n;; Gambit built-in (no import needed)\n(path-expand \"~/docs\")            ;; expands ~ to home dir\n(path-normalize \"relative/path\")  ;; resolve to absolute\n(path-directory \"/home/user/file.txt\")  ;; => \"/home/user/\"\n(path-strip-directory \"/home/user/file.txt\")  ;; => \"file.txt\"",
    "notes": ":std/misc/path provides pure string manipulation — no filesystem access. subpath joins components with the OS separator. subpath? checks containment. path-extension includes the dot. path-force-extension replaces any existing extension. path-default-extension only adds if none exists. Gambit also provides path-expand, path-normalize (filesystem-aware), path-directory, and path-strip-directory as built-ins. Use Gambit's for real path resolution, :std/misc/path for string manipulation.",
    "related": [
      "port-utilities-file-io"
    ]
  },
  {
    "id": "string-utilities-misc",
    "title": "String utility functions: trim, split, substitute, random",
    "tags": [
      "string",
      "trim",
      "split",
      "substitute",
      "replace",
      "prefix",
      "suffix",
      "eol",
      "utility"
    ],
    "imports": [
      ":std/misc/string"
    ],
    "code": "(import :std/misc/string)\n\n;; Remove prefix/suffix\n(string-trim-prefix \"Hello \" \"Hello World\")   ;; => \"World\"\n(string-trim-suffix \".txt\" \"file.txt\")        ;; => \"file\"\n(string-trim-prefix \"X\" \"Hello\")              ;; => \"Hello\" (no match, unchanged)\n\n;; Split on prefix (returns 2 values)\n(defvalues (rest prefix) (string-split-prefix \"http://\" \"http://example.com\"))\n;; rest => \"example.com\", prefix => \"http://\"\n\n;; Trim end-of-line characters\n(string-trim-eol \"hello\\r\\n\")  ;; => \"hello\"\n(string-trim-eol \"hello\\n\")    ;; => \"hello\"\n(string-trim-eol \"hello\\r\")    ;; => \"hello\"\n\n;; String substitution (replace occurrences)\n(string-subst \"old\" \"new\" \"the old old way\")\n;; => \"the new new way\" (replaces all by default)\n\n(string-subst \"old\" \"new\" \"the old old way\" 1)\n;; => \"the new old way\" (count=1, replace first only)\n\n;; Random string generation\n(random-string 16)  ;; => \"a3f7b2c8e1d9f4a0\" (hex chars)\n\n;; str: convert anything to string (like Python's str())\n(str 42)            ;; => \"42\"\n(str 'hello)        ;; => \"hello\"\n(str \"already\")     ;; => \"already\"\n\n;; Lexicographic comparison\n(as-string<? 'apple 'banana)  ;; => #t (compares as strings)\n\n;; Gambit built-ins (no import needed):\n;; (string-contains s1 s2)        — substring search\n;; (string-prefix? pre s)         — check prefix\n;; (string-suffix? suf s)         — check suffix\n;; (string-upcase s)              — uppercase\n;; (string-downcase s)            — lowercase",
    "notes": ":std/misc/string provides common string manipulation beyond R7RS. string-trim-prefix/suffix return the original string unchanged if the prefix/suffix isn't found. string-subst replaces all occurrences by default; pass a count to limit replacements. string-trim-eol handles CR, LF, and CRLF (tries CRLF first). random-string generates random hex characters. str is a generic to-string converter. Gambit provides additional built-ins like string-contains, string-prefix?, string-suffix?.",
    "related": [
      "csv-parsing-options"
    ]
  },
  {
    "id": "using-typed-access",
    "title": "Optimized typed access with 'using' (no dynamic dispatch)",
    "tags": [
      "using",
      "typed",
      "access",
      "optimization",
      "struct",
      "class",
      "field",
      "slot",
      "inline"
    ],
    "imports": [],
    "code": ";; 'using' tells the compiler the exact type, enabling inlined field access\n;; No import needed — it's a core form\n\n(defstruct point (x y) transparent: #t)\n\n;; Without using: dynamic slot lookup (slower)\n(def (distance-slow p1 p2)\n  (sqrt (+ (expt (- (point-x p1) (point-x p2)) 2)\n           (expt (- (point-y p1) (point-y p2)) 2))))\n\n;; With using: inlined field access (faster, no dispatch)\n(def (distance-fast p1 p2)\n  (using ((p1 :- point) (p2 :- point))\n    (sqrt (+ (expt (- p1.x p2.x) 2)\n             (expt (- p1.y p2.y) 2)))))\n\n;; Dot syntax works with using\n(def (translate p dx dy)\n  (using (p :- point)\n    (make-point (+ p.x dx) (+ p.y dy))))\n\n;; Mutation via set! + using\n(def (move! p dx dy)\n  (using (p :- point)\n    (set! p.x (+ p.x dx))\n    (set! p.y (+ p.y dy))))\n\n;; Using with classes\n(defclass widget (label visible?)\n  transparent: #t)\n\n(def (toggle-visibility! w)\n  (using (w :- widget)\n    (set! w.visible? (not w.visible?))))\n\n;; Using in method bodies for self-access\n(defmethod {area point}\n  (lambda (self)\n    (using (self :- point)\n      (* self.x self.y))))\n\n;; Using with interface types\n(def (print-it (obj : Printable))\n  (using (obj :- Printable)\n    (displayln {obj.to-string})))",
    "notes": "using is a core Gerbil form that provides typed field access. Syntax: (using (var :- Type) body) or (using ((v1 :- T1) (v2 :- T2)) body). Inside using, dot syntax (v.field) compiles to direct struct field access without dynamic dispatch. This is significantly faster in hot loops. set! works with dot syntax inside using for mutation. The type annotation is NOT checked at runtime — it's a promise to the compiler. Wrong types will cause undefined behavior, not errors. Use : (colon) in function signatures for runtime-checked contracts.",
    "related": [
      "interface-contracts"
    ]
  },
  {
    "id": "list-utilities-advanced",
    "title": "Advanced list utilities: slice, group, split, flatten, duplicates",
    "tags": [
      "list",
      "slice",
      "group",
      "split",
      "flatten",
      "duplicates",
      "unique",
      "butlast",
      "take",
      "drop"
    ],
    "imports": [
      ":std/misc/list"
    ],
    "code": "(import :std/misc/list)\n\n;; Slicing\n(slice '(a b c d e) 1 3)       ;; => (b c d) — from index 1, take 3\n(slice-right '(a b c d e) 1 2) ;; => (d c) — from right, index 1, take 2\n(butlast '(a b c d))           ;; => (a b c) — all but last\n\n;; Flatten nested lists\n(flatten '(1 (2 (3 4) 5) 6))  ;; => (1 2 3 4 5 6) — fully recursive\n(flatten1 '(1 (2 (3 4) 5) 6)) ;; => (1 2 (3 4) 5 6) — one level only\n\n;; Split on predicate\n(split '(1 2 0 3 4 0 5) zero?) ;; => ((1 2) (3 4) (5))\n\n;; Group consecutive equal elements\n(group-consecutive '(1 1 2 2 2 3 1 1))\n;; => ((1 1) (2 2 2) (3) (1 1))\n\n;; Group by N elements\n(group-n-consecutive 3 '(a b c d e f g))\n;; => ((a b c) (d e f) (g))\n\n;; Group by key function\n(group-same '(\"apple\" \"avocado\" \"banana\" \"blueberry\")\n  key: (lambda (s) (string-ref s 0)))\n;; => ((\"apple\" \"avocado\") (\"banana\" \"blueberry\"))\n\n;; Take/drop until predicate\n(take-until even? '(1 3 5 6 7 8))  ;; => (1 3 5) — take while odd\n(drop-until even? '(1 3 5 6 7 8))  ;; => (6 7 8) — drop until even\n\n;; Find duplicates\n(duplicates '(a b c a b a))\n;; => ((a . 3) (b . 2)) — items with count > 1\n\n;; Efficient length checks (short-circuit, no full traversal)\n(length=n? '(a b c) 3)    ;; => #t\n(length<n? '(a b) 5)      ;; => #t\n(length<=n? '(a b c) 2)   ;; => #f\n\n;; Unique (remove duplicates)\n(unique '(3 1 2 1 3 4) =)  ;; => (3 1 2 4)\n\n;; Mutation macros\n(def lst '(1 2 3))\n(push! 0 lst)       ;; lst => (0 1 2 3)\n(pop! lst)           ;; => 0, lst => (1 2 3)",
    "notes": ":std/misc/list provides extensive list utilities beyond SRFI-1. slice is 0-indexed and takes (list start limit). flatten is fully recursive; flatten1 is one level. split divides on predicate matches (like string-split for lists). group-consecutive groups runs of equal adjacent elements. group-same groups by a key function (non-adjacent allowed). length=n?/length<n?/length<=n? are O(min(n,len)) instead of O(len) — use these instead of (= (length lst) n). push!/pop! are mutation macros using set!.",
    "related": [
      "list-builder-efficient-append"
    ]
  },
  {
    "id": "def-star-multi-arity",
    "title": "Multi-arity function definition with def*",
    "tags": [
      "def*",
      "multi-arity",
      "case-lambda",
      "overload",
      "dispatch",
      "variadic"
    ],
    "imports": [],
    "code": ";; def* defines a function with multiple arities (like case-lambda)\n;; No import needed — it's a core form\n\n(def* my-add\n  ((x) x)                    ;; 1 arg: identity\n  ((x y) (+ x y))            ;; 2 args: add\n  ((x y z) (+ x y z))        ;; 3 args: add three\n  (args (apply + args)))      ;; variadic: add all\n\n(my-add 1)       ;; => 1\n(my-add 1 2)     ;; => 3\n(my-add 1 2 3)   ;; => 6\n(my-add 1 2 3 4) ;; => 10\n\n;; Pattern: optional arguments with different behavior\n(def* connect\n  ((host) (connect host 80))              ;; default port\n  ((host port) (connect host port #f))    ;; default no-ssl\n  ((host port ssl?)\n   (displayln \"Connecting to \" host \":\" port\n              (if ssl? \" (SSL)\" \"\"))))\n\n(connect \"example.com\")          ;; => Connecting to example.com:80\n(connect \"example.com\" 443 #t)   ;; => Connecting to example.com:443 (SSL)\n\n;; Pattern: recursive with base case by arity\n(def* my-map\n  ((f lst) (my-map f lst []))\n  ((f lst acc)\n   (if (null? lst) (reverse acc)\n       (my-map f (cdr lst) (cons (f (car lst)) acc)))))\n\n(my-map 1+ '(1 2 3))  ;; => (2 3 4)",
    "notes": "def* is a core Gerbil form equivalent to defining with case-lambda. Each clause has a parameter list and body. Clauses are tried in order until one matches the call arity. The last clause can be variadic (args without parens) to catch remaining arities. This is cleaner than using optional arguments with defaults when different arities have fundamentally different behavior. def* generates efficient dispatch code.",
    "related": [
      "function-composition-combinators"
    ]
  },
  {
    "id": "open-process-undocumented-settings",
    "title": "open-process undocumented settings: pseudo-terminal, directory, environment",
    "tags": [
      "open-process",
      "pseudo-terminal",
      "pty",
      "directory",
      "environment",
      "child",
      "process"
    ],
    "imports": [],
    "code": ";; open-process accepts several undocumented/lesser-known settings\n;; beyond the standard path:, arguments:, stdin/stdout/stderr-redirection:\n;; No imports needed — open-process is a Gambit builtin.\n\n;; 1. directory: — set child's working directory\n(let* ((p (open-process (list path: \"/bin/pwd\"\n                              arguments: '()\n                              directory: \"/tmp\"\n                              stdout-redirection: #t)))\n       (cwd (read-line p))\n       (_ (process-status p)))\n  cwd)\n;; => \"/tmp\"\n\n;; 2. environment: — set child's environment (list of \"KEY=val\" strings)\n;; If provided, REPLACES the entire environment (not append!)\n(let* ((p (open-process (list path: \"/usr/bin/env\"\n                              arguments: '()\n                              environment: '(\"FOO=bar\" \"BAZ=quux\")\n                              stdout-redirection: #t)))\n       (lines (let loop ((acc '()))\n                (let ((line (read-line p)))\n                  (if (eof-object? line) (begin (process-status p) (reverse acc))\n                    (loop (cons line acc)))))))\n  lines)\n;; => (\"FOO=bar\" \"BAZ=quux\")\n\n;; 3. pseudo-terminal: #t — allocate a pty for the child\n;; This makes the child think it's running on a real terminal.\n;; Programs that require a tty (less, vim, ssh) will work.\n;; NOTE: Fails with OS exception if no pty is available.\n(with-exception-catcher\n  (lambda (e) (displayln \"pty allocation failed (expected in sandbox)\"))\n  (lambda ()\n    (let ((p (open-process (list path: \"/usr/bin/tty\"\n                                 arguments: '()\n                                 pseudo-terminal: #t\n                                 stdout-redirection: #t))))\n      (let ((tty-name (read-line p)))\n        (process-status p)\n        (displayln \"Child tty: \" tty-name)))))\n;; On real terminal: \"Child tty: /dev/pts/N\"\n\n;; 4. output-width: N — set the port's width (for pretty-printing)\n(let ((p (open-process (list path: \"/bin/echo\" arguments: '(\"ok\")\n                             output-width: 120\n                             stdout-redirection: #t))))\n  (read-line p)\n  (process-status p))",
    "notes": "These settings were verified by testing against Gambit's source code. Key points: (1) environment: REPLACES the entire env, it doesn't merge with the parent's. Pass #f or omit to inherit. (2) pseudo-terminal: #t eliminates the need for FFI openpty/forkpty for most pty use cases — Gambit handles pty allocation internally. (3) directory: lets you avoid cd-ing in the parent just to affect the child. (4) Unknown/misspelled keywords are silently ignored — no error. The child inherits the parent's process group (Gambit does NOT call setpgid).",
    "related": [
      "open-process-stdin-write-read",
      "process-status-decode-waitpid",
      "run-subprocess-custom-env"
    ]
  },
  {
    "id": "output-port-width-terminal-columns",
    "title": "Get terminal column width with output-port-width (no subprocess needed)",
    "tags": [
      "terminal",
      "columns",
      "width",
      "output-port-width",
      "COLUMNS",
      "tty",
      "size"
    ],
    "imports": [],
    "code": ";; output-port-width returns the terminal column width.\n;; No imports needed — it's a Gambit builtin.\n\n;; Basic usage:\n(output-port-width (current-output-port))\n;; => 80 (default, or actual terminal width on a real tty)\n\n;; On a real terminal, Gambit uses ioctl(TIOCGWINSZ) to get the actual width.\n;; On non-tty ports (files, pipes), it returns the default (80).\n\n;; Useful for shell $COLUMNS variable and line editor wrapping:\n(def (get-terminal-columns)\n  (let ((port (current-output-port)))\n    (if (tty? port)\n      (output-port-width port)\n      80)))\n\n;; NOTE: There is NO output-port-height or equivalent for rows.\n;; For terminal rows, you need either:\n;;   - ioctl(TIOCGWINSZ) via FFI\n;;   - (stty size) via subprocess\n;;   - ANSI escape: write ESC[6n, read cursor position response",
    "notes": "output-port-width is a Gambit builtin (no import needed). Returns terminal columns on a real tty, 80 on non-tty. There is NO height/rows equivalent — only width. For the shell's $COLUMNS, this is sufficient. For $LINES, you'll need ioctl TIOCGWINSZ via FFI or stty subprocess. The width updates automatically when the terminal is resized (Gambit handles SIGWINCH internally).",
    "related": [
      "tty-mode-set-raw-cooked",
      "process-status-decode-waitpid"
    ]
  },
  {
    "id": "process-times-cpu-usage",
    "title": "Get process CPU times with process-times (for time/times builtins)",
    "tags": [
      "process-times",
      "cpu",
      "time",
      "user",
      "system",
      "real",
      "builtin",
      "times"
    ],
    "imports": [],
    "code": ";; process-times returns an f64vector of 3 elements: user, system, real time.\n;; No imports needed — it's a Gambit builtin.\n\n(let ((t (process-times)))\n  (list 'user:   (f64vector-ref t 0)   ;; user CPU seconds\n        'system: (f64vector-ref t 1)   ;; system CPU seconds  \n        'real:   (f64vector-ref t 2))) ;; wall-clock seconds\n;; => (user: 0.062071 system: 0.017019 real: 0.076280...)\n\n;; Pattern for shell's `time` builtin:\n(def (time-command thunk)\n  (let ((before (process-times)))\n    (thunk)\n    (let ((after (process-times)))\n      (let ((user (- (f64vector-ref after 0) (f64vector-ref before 0)))\n            (sys  (- (f64vector-ref after 1) (f64vector-ref before 1)))\n            (real (- (f64vector-ref after 2) (f64vector-ref before 2))))\n        (fprintf (current-error-port)\n          \"\\nreal\\t~as\\nuser\\t~as\\nsys\\t~as\\n\"\n          real user sys)))))\n\n(time-command (lambda () (thread-sleep! 0.1)))\n;; real  0.1003s\n;; user  0.0001s\n;; sys   0.0000s\n\n;; For shell's `times` builtin (accumulated shell + children times):\n;; process-times gives shell's own times.\n;; ##process-statistics gives a 21-element f64vector with more detail:\n;;   indices 0-2: user/sys/real for the process itself\n;;   indices 3-5: user/sys/real for terminated children",
    "notes": "process-times is a Gambit builtin (no import needed). Returns f64vector(user, system, real) in seconds as floats. For the `time` builtin, measure before/after and subtract. For the `times` builtin, use ##process-statistics which has child process times at indices 3-5. Note: these are cumulative times, not per-command — you must compute deltas yourself.",
    "related": [
      "process-status-decode-waitpid",
      "open-process-undocumented-settings"
    ]
  },
  {
    "id": "fcntl-f-dupfd-duplicate-fd",
    "title": "Duplicate file descriptor with F_DUPFD via fcntl (partial dup, not dup2)",
    "tags": [
      "fcntl",
      "F_DUPFD",
      "dup",
      "duplicate",
      "fd",
      "file descriptor",
      "redirect"
    ],
    "imports": [
      ":std/os/fcntl",
      ":std/os/fdio",
      ":std/os/pipe"
    ],
    "code": ";; :std/os/fcntl provides F_DUPFD for duplicating file descriptors.\n;; F_DUPFD picks the lowest available fd >= the given minimum.\n;; This is NOT dup2 (which targets a SPECIFIC fd atomically).\n(import :std/os/fcntl :std/os/fdio :std/os/pipe)\n\n;; Create a pipe and duplicate the read end to fd >= 10\n(receive (read-port write-fd) (pipe 'in)\n  (let* ((read-fd 5)  ;; hypothetical; in practice pipe 'none gives raw fds\n         ;; For demo, use the write-fd which IS a raw integer:\n         (new-fd (fcntl write-fd F_DUPFD 10)))\n    ;; new-fd is >= 10, pointing to the same file description as write-fd\n    (displayln \"original: \" write-fd \" new: \" new-fd)\n    ;; Both fds are usable; closing one doesn't affect the other\n    (close new-fd)\n    (close write-fd)\n    (close-port read-port)))\n\n;; Practical example: duplicate a pipe fd to a high range\n(receive (rfd wfd) (pipe 'none)\n  (let ((high-fd (fcntl rfd F_DUPFD 100)))\n    ;; high-fd >= 100, same underlying pipe as rfd\n    (displayln \"low: \" rfd \" high: \" high-fd)\n    ;; => e.g. \"low: 5 high: 100\"\n    (close rfd)\n    (close wfd)\n    (close high-fd)))\n\n;; LIMITATIONS:\n;; - F_DUPFD picks lowest fd >= arg, NOT a specific target fd\n;; - For dup2(old, target) behavior (redirect fd 0/1/2), need FFI\n;; - No F_DUPFD_CLOEXEC available in Gerbil's fcntl exports\n;; - Cannot replace an existing fd atomically (dup2 closes target first)",
    "notes": "F_DUPFD is the only fd duplication available without FFI in Gerbil. It duplicates an fd to the lowest available fd >= the given minimum. This differs from dup2(old, new) which atomically closes 'new' and duplicates 'old' to exactly 'new'. For shell-style redirections (redirecting fd 0, 1, 2 to specific targets), F_DUPFD is insufficient — you need FFI dup2. However, F_DUPFD is useful for moving fds out of the low range (e.g., saving original stdin before redirecting). Missing from Gerbil: F_DUPFD_CLOEXEC (which sets close-on-exec atomically).",
    "related": [
      "os-pipe-create-fd-pair",
      "open-process-undocumented-settings"
    ]
  },
  {
    "id": "concurrency-pattern-guide",
    "title": "Concurrency pattern decision guide — choose the right primitive",
    "tags": [
      "concurrency",
      "pattern",
      "decision",
      "guide",
      "channel",
      "barrier",
      "completion",
      "atom",
      "rwlock",
      "wg",
      "actor",
      "thread"
    ],
    "imports": [],
    "code": ";; Concurrency Pattern Decision Guide for Gerbil Scheme\n;;\n;; Use case                          → Primitive               → Module\n;; ─────────────────────────────────────────────────────────────────────\n;; Fire-and-forget task              → spawn                   → (builtin)\n;; Multiple producers/consumers      → channel                 → :std/misc/channel\n;; One-shot async result (future)    → completion              → :std/misc/completion\n;; Wait for N tasks to finish        → barrier                 → :std/misc/barrier\n;; Thread pool with task queue       → workgroup (wg)          → :std/misc/wg\n;; Shared mutable state (simple)     → atom                    → :std/misc/atom\n;; Read-heavy shared state           → rwlock                  → :std/misc/rwlock\n;; Message passing / RPC             → actor                   → :std/actor\n;; Race multiple events              → sync/select             → :std/event\n;; Exclusive critical section        → mutex + unwind-protect  → (builtin)\n;;\n;; Quick decision tree:\n;; 1. Need to pass data between threads?\n;;    - Stream of values → channel\n;;    - Single result    → completion\n;; 2. Need to coordinate threads?\n;;    - Wait for all    → barrier or wg\n;;    - Wait for first  → sync/select\n;; 3. Need shared mutable state?\n;;    - Read-heavy      → rwlock\n;;    - Read/write even → atom\n;; 4. Need structured message passing?\n;;    - Request/reply   → actor (->>)\n;;    - Fire-and-forget → actor (->)",
    "notes": "This is a reference guide, not executable code. Each primitive listed here has its own cookbook recipe with working examples. Search for the specific pattern name (e.g., \"channel\", \"barrier\", \"workgroup\") to find detailed examples.",
    "related": [
      "channel-pattern",
      "barrier-synchronization",
      "completion-async-value",
      "workgroup-thread-pool",
      "atom-atomic-reference",
      "rwlock-read-write-lock",
      "actor-message-passing",
      "event-sync-select"
    ]
  },
  {
    "id": "gambit-primitives-inventory",
    "title": "Gambit runtime primitives available without imports",
    "tags": [
      "gambit",
      "builtins",
      "primitives",
      "inventory",
      "discovery",
      "no-import",
      "process",
      "file",
      "environment",
      "terminal"
    ],
    "imports": [],
    "code": ";; Gambit runtime primitives — available without any imports.\n;; These are NOT in :std/* modules; they're from the Gambit runtime.\n;;\n;; ── Process Management ──────────────────────────────────────────\n;; open-process      Create a subprocess (returns a port)\n;;   Settings: path:, arguments:, directory:, environment:,\n;;             stdin-redirection:, stdout-redirection:, stderr-redirection:,\n;;             pseudo-terminal:, output-width:\n;; process-status    Get exit status (blocks until exited); raw waitpid value\n;; process-pid       Get PID of a process port\n;; shell-command     Run a shell command string (returns exit status)\n;;\n;; ── Filesystem ──────────────────────────────────────────────────\n;; file-exists?      Check if file/directory exists\n;; file-info         Get file metadata (like stat): type, mode, size, times\n;; file-info-type    Extract type from file-info (:regular, :directory, etc.)\n;; file-info-size    Extract size from file-info\n;; file-info-mode    Extract permission bits from file-info\n;; rename-file       Rename/move a file (atomic on POSIX)\n;; delete-file       Delete a file\n;; create-directory  Create a directory (mkdir)\n;; delete-directory  Delete an empty directory (rmdir)\n;; directory-files   List directory entries (returns list of strings)\n;; current-directory Get/set current working directory\n;;\n;; ── Path Manipulation ───────────────────────────────────────────\n;; path-normalize       Resolve to absolute path (like realpath)\n;; path-directory       Directory portion (like dirname, with trailing /)\n;; path-strip-directory Filename portion (like basename)\n;; path-extension       File extension (includes dot)\n;; path-strip-extension Remove file extension\n;; path-expand          Expand ~ and environment variables\n;;\n;; ── Environment ─────────────────────────────────────────────────\n;; getenv            Get environment variable (returns #f if unset)\n;; setenv            Set environment variable (Gambit extension)\n;;\n;; ── I/O ─────────────────────────────────────────────────────────\n;; open-input-file   Open file for reading (returns port)\n;; open-output-file  Open file for writing\n;; call-with-input-file   Open, call proc with port, close\n;; call-with-output-file  Open, call proc with port, close\n;; with-input-from-file   Set current-input-port from file\n;; with-output-to-file    Set current-output-port to file\n;; read-line         Read a line from port\n;; read-all          Read all data from port\n;; read-u8           Read a byte\n;; write-u8          Write a byte\n;; display / write / newline / displayln\n;;\n;; ── String I/O ──────────────────────────────────────────────────\n;; open-input-string    Create port from string\n;; open-output-string   Create string accumulator port\n;; get-output-string    Extract string from output port\n;; call-with-output-string  Create string port, call proc, return string\n;; with-output-to-string    Capture display/write output as string\n;;\n;; ── Threading ───────────────────────────────────────────────────\n;; make-thread / thread-start! / thread-join! / thread-yield!\n;; thread-sleep!     Sleep for N seconds (accepts real numbers)\n;; thread-terminate! Terminate a thread (use with-catch around it)\n;; make-mutex / mutex-lock! / mutex-unlock!\n;; make-condition-variable / condition-variable-signal! / condition-variable-broadcast!\n;; current-thread    Get the current thread object\n;;\n;; ── Time ────────────────────────────────────────────────────────\n;; ##current-time    Current time (Gambit time object)\n;; time->seconds     Convert Gambit time to seconds since epoch\n;; seconds->time     Convert seconds to Gambit time\n;;\n;; ── System ──────────────────────────────────────────────────────\n;; ##command-line    Command line arguments as list\n;; exit              Exit the process\n;; error             Raise an error exception",
    "notes": "All of these are Gambit builtins available in any Gerbil program without imports. Some (like setenv) are Gambit extensions not in R7RS. For process management, :std/misc/process provides higher-level wrappers (run-process, filter-with-process). For path manipulation, :std/misc/path provides additional utilities. WARNING: (import :std/srfi/19) shadows time->seconds with an incompatible version that returns a date-component, not epoch seconds.",
    "related": [
      "open-process-settings",
      "directory-listing",
      "gambit-path-builtins",
      "run-external-process"
    ]
  },
  {
    "id": "hex-escape-semicolon-terminator",
    "title": "Hex escapes in strings require semicolon terminator (\\xNN;)",
    "tags": [
      "hex",
      "escape",
      "string",
      "R7RS",
      "reader",
      "syntax",
      "gotcha"
    ],
    "imports": [],
    "code": ";; WRONG — causes \"Invalid hexadecimal escape\" reader error:\n;; \"\\x1b[K\"    ;; intended: ESC [ K\n;; \"\\x07\"      ;; intended: BEL character\n;; \"\\x0b\"      ;; intended: vertical tab\n\n;; CORRECT — Gerbil/Gambit uses R7RS hex escape syntax with semicolon terminator:\n\"\\x1b;[K\"     ;; ESC [ K  (ANSI clear to end of line)\n\"\\x07;\"       ;; BEL character\n\"\\x0b;\"       ;; vertical tab\n\n;; The semicolon terminates the hex escape, it is NOT a literal character.\n(string-length \"\\x1b;\")   ;; => 1 (just the ESC character)\n(string-length \"\\x1b;[K\") ;; => 3 (ESC, [, K)\n\n;; For ANSI escapes, an alternative is to use (string #\\escape):\n(def ESC-STR (string #\\escape))\n(string-append ESC-STR \"[K\")  ;; equivalent to \"\\x1b;[K\"\n\n;; Or use the character literal directly:\n(string #\\escape #\\[ #\\K)  ;; => \"\\x1b;[K\"",
    "notes": "This is a common gotcha when porting code from other Scheme implementations or C. Most languages use \\xNN without a terminator, but Gerbil/Gambit follows R7RS which requires \\xNN; with a semicolon. Without the semicolon, the reader tries to consume more hex digits and fails with \"Invalid hexadecimal escape\". The alternative (string #\\escape) approach avoids this issue entirely and is more readable for ANSI escape sequences.",
    "related": [
      "tty-mode-set-raw-cooked"
    ]
  },
  {
    "id": "symbol-reader-special-chars",
    "title": "Symbols with # and , are invalid — use safe names in case/quote",
    "tags": [
      "symbol",
      "reader",
      "quote",
      "hash",
      "comma",
      "unquote",
      "case",
      "gotcha"
    ],
    "imports": [],
    "code": ";; PROBLEM: Some characters are special to the Gerbil reader and cannot\n;; be used in quoted symbols, even inside case clauses.\n\n;; WRONG — these cause reader errors:\n;; '#      ;; # is a reader dispatch character — '# is not a valid datum\n;; '##     ;; same issue\n;; ',      ;; , is unquote — ', becomes (unquote ...)\n;; ',,     ;; double unquote\n\n;; Reader error examples:\n;; (case x ((#) \"hash\"))    ;; Datum expected\n;; (case x ((,) \"comma\"))   ;; reader interprets , as unquote\n;; (case x ((,,) \"dc\"))     ;; Incomplete form, EOF reached\n\n;; CORRECT — use descriptive symbol names instead:\n(case modifier\n  ((prefix-short) \"# — remove shortest prefix\")\n  ((prefix-long)  \"## — remove longest prefix\")\n  ((lc-first)     \", — lowercase first char\")\n  ((lc-all)       \",, — lowercase all chars\")\n  (else \"unknown\"))\n\n;; Characters that WORK fine as symbols:\n'%     ;; => %\n'%%    ;; => %%\n'/     ;; => /\n'//    ;; => //\n'^     ;; => ^\n'^^    ;; => ^^\n':     ;; => :\n':-    ;; => :-\n'+     ;; => +\n'-     ;; => -\n\n;; Characters that DO NOT work as symbols:\n;; '#   — reader dispatch prefix\n;; '##  — Gambit namespace prefix\n;; ',   — unquote\n;; ',,  — double unquote\n;; '`   — quasiquote",
    "notes": "This commonly bites when implementing shell-like DSLs where operators include # and , characters. The workaround is to map these to descriptive symbol names internally (e.g., 'prefix-short for #, 'lc-all for ,,). Character literals (#\\# and #\\,) work fine — the issue is only with quoted symbols.",
    "related": [
      "hex-escape-semicolon-terminator"
    ]
  },
  {
    "id": "dot-syntax-non-self-class-access",
    "title": "Use explicit accessors (not dot syntax) for non-self class instances",
    "tags": [
      "dot",
      "syntax",
      "slot-ref",
      "class",
      "defclass",
      "accessor",
      "parent",
      "gotcha"
    ],
    "imports": [],
    "code": ";; Inside defmethod, self.field works because self is the class instance.\n;; But other-obj.field can fail during compilation.\n\n(defclass animal (name age) transparent: #t constructor: :init!)\n\n(defmethod {:init! animal}\n  (lambda (self parent: (parent #f))\n    ;; WORKS — self.field is special in defmethod:\n    (set! self.name \"default\")\n    (set! self.age 0)\n\n    ;; MAY FAIL at compile time — parent.name uses unsafe slot-ref:\n    ;; (set! self.name (if parent parent.name \"default\"))\n\n    ;; CORRECT — use the generated accessor function:\n    (set! self.name (if parent (animal-name parent) \"default\"))\n    (set! self.age (if parent (animal-age parent) 0))))\n\n;; General rule:\n;; - self.field      → OK inside defmethod (compiler knows the type)\n;; - (@ obj field)   → OK for dynamic slot access (runtime dispatch)\n;; - (TypeName-field obj) → OK always (generated accessor, no dispatch)\n;; - other-var.field → UNRELIABLE (reader macro, may fail at compile time)\n\n;; For safe access on any variable, use the accessor:\n(def (clone-animal a)\n  (make-animal (animal-name a) (animal-age a)))",
    "notes": "The dot syntax obj.field is a reader macro that expands to (##slot-ref obj 'field) or similar. Inside defmethod bodies, self.field is handled specially by the compiler. For other variables, it uses unsafe slot access that can fail during compilation if the compiler can't verify the type. Always use the defclass/defstruct-generated accessor functions (TypeName-field obj) for non-self access. This is especially important when the variable might be #f (e.g., optional parent parameter).",
    "related": [
      "typed-struct-field-access",
      "use-internal-helper-rebind-conflict"
    ]
  },
  {
    "id": "qt-qapplication-argc-by-reference",
    "title": "QApplication argc must use static storage (not stack variables)",
    "tags": [
      "qt",
      "qapplication",
      "argc",
      "argv",
      "segfault",
      "by-reference",
      "ffi",
      "c++",
      "static"
    ],
    "imports": [],
    "code": "// PROBLEM: QApplication(int &argc, char **argv) takes argc BY REFERENCE.\n// If you pass a local variable, Qt stores a dangling reference.\n// This causes SIGSEGV in QCoreApplication::arguments() -> strlen()\n// when a window is shown (not during construction!).\n\n// WRONG — argc is a local that goes out of scope:\n// qt_application_t qt_application_create(int argc, char** argv) {\n//     return new QApplication(argc, argv);  // dangling reference!\n// }\n\n// CORRECT — use static storage for argc:\nstatic int    s_argc = 1;\nstatic char   s_arg0[] = \"gerbil-qt\";\nstatic char*  s_argv[] = { s_arg0, nullptr };\n\nextern \"C\" void* qt_application_create(void) {\n    return new QApplication(s_argc, s_argv);\n}\n\n// The crash is deferred — construction works fine, but showing a window\n// triggers QXcbIntegration::wmClass() -> QCoreApplication::arguments()\n// which reads the dangling argc reference -> SIGSEGV in strlen().",
    "notes": "Qt documentation says: \"argc and argv and must remain valid for the entire lifetime of the QApplication object.\" The reference parameter is stored internally. This is a common C++ FFI pitfall because C wrappers typically pass argc by value, but QApplication expects a reference. The segfault is deferred to window show time, making it hard to diagnose. GDB backtrace shows: strlen -> QCoreApplication::arguments -> QXcbIntegration::wmClass -> QXcbWindow::create -> QWidget::show.",
    "related": [
      "gambit-ffi-pointer-types",
      "build-ffi-with-pkg-config"
    ]
  },
  {
    "id": "ffi-const-char-return-cfun-assign-warning",
    "title": "Fix ___CFUN_ASSIGN warning for const char* return types in FFI",
    "tags": [
      "ffi",
      "const",
      "char",
      "return",
      "CFUN_ASSIGN",
      "warning",
      "c-lambda",
      "UTF-8-string"
    ],
    "imports": [
      ":std/foreign"
    ],
    "code": ";; PROBLEM: When a C function returns const char*, binding it with\n;; UTF-8-string return type causes a compiler warning:\n;;\n;;   warning: assignment discards 'const' qualifier from pointer target type\n;;   ___CFUN_ASSIGN(___result, my_get_text(___arg1))\n;;\n;; This is because Gambit's ___CFUN_ASSIGN macro assigns to a char*\n;; variable, but the function returns const char*.\n\n;; WRONG — compiles but produces warning:\n;; (define-c-lambda my_get_text ((pointer void)) UTF-8-string\n;;   \"my_get_text\")\n\n;; CORRECT — use a C wrapper that casts away const:\n(begin-ffi (my_get_text)\n  (c-declare #<<END-C\n#include \"mylib.h\"\n\n/* Wrapper: cast away const to suppress ___CFUN_ASSIGN warning.\n   Safe because Gambit immediately copies into a Scheme string. */\nstatic char* ffi_my_get_text(void* obj) {\n    return (char*)my_get_text(obj);\n}\nEND-C\n  )\n\n  ;; Bind the wrapper, not the original\n  (define-c-lambda my_get_text ((pointer void)) UTF-8-string\n    \"ffi_my_get_text\")\n)",
    "notes": "The cast is safe because Gambit's UTF-8-string handling immediately copies the C string into a Scheme string object — it never writes through the pointer. Without the wrapper, the code works correctly but produces compiler warnings that clutter build output. This pattern is needed for any C function returning const char* when bound with UTF-8-string or char-string return type. Common in Qt (label text getters), GTK, and other C++ libraries with C wrapper APIs.",
    "related": [
      "c-define-char-string-const-mismatch",
      "gambit-ffi-pointer-types"
    ]
  },
  {
    "id": "hash-literal-symbol-keys-no-quote",
    "title": "Hash literal with symbol keys: do NOT quote keys",
    "tags": [
      "hash",
      "literal",
      "symbol",
      "keys",
      "quote",
      "gotcha",
      "hash-ref"
    ],
    "imports": [],
    "code": ";; GOTCHA: (hash) literal auto-quotes the first element of each pair.\n;; Do NOT add explicit quotes — that creates a LIST key, not a symbol key.\n\n;; WRONG — keys are (quote command) i.e. a 2-element list, not a symbol:\n(def bad (hash ('command #f) ('script #f)))\n(hash-ref bad 'command)  ;; ERROR: UnboundKeyError — key 'command not found!\n;; The actual key is the LIST (quote command), not the SYMBOL command.\n\n;; CORRECT — bare identifiers become symbol keys automatically:\n(def good (hash (command #f) (script #f)))\n(hash-ref good 'command)  ;; => #f — works!\n(hash->list good)  ;; => ((script . #f) (command . #f))\n\n;; For string keys, use string literals:\n(def str-ht (hash (\"name\" \"alice\") (\"age\" 30)))\n(hash-ref str-ht \"name\")  ;; => \"alice\"\n\n;; REMEMBER: hash-put! with symbol keys works fine:\n(hash-put! good 'command \"ls -la\")\n(hash-ref good 'command)  ;; => \"ls -la\"",
    "notes": "The hash literal macro auto-quotes the car of each pair. Writing ('foo val) makes the key (quote foo), a list. Writing (foo val) makes the key 'foo, a symbol. This is a very common source of \"unknown hash key\" errors when initializing hash tables with symbol keys. Use (hash-eq ...) if you specifically want eq? comparison for symbol keys.",
    "related": [
      "hash-table-operations",
      "hash-ref-void-truthy"
    ]
  },
  {
    "id": "fdopen-three-args",
    "title": "fdopen from :std/os/fd takes 3 arguments: fd, direction, close-on-gc",
    "tags": [
      "fdopen",
      "fd",
      "port",
      "pipe",
      "arity",
      "std/os/fd"
    ],
    "imports": [
      ":std/os/fd",
      ":std/os/fdio",
      ":std/os/fcntl"
    ],
    "code": "(import :std/os/fd :std/os/fdio :std/os/fcntl)\n\n;; fdopen wraps a raw integer fd into a Gambit port.\n;; Signature: (fdopen fd direction close-on-gc?)\n;;   fd          — raw integer file descriptor\n;;   direction   — 'in for input port, 'out for output port\n;;   close-on-gc — #t to close fd when port is GC'd\n\n;; WRONG — only 2 args causes arity mismatch at compile time:\n;; (fdopen read-fd 'in)  ;; ERROR: arity mismatch, expected 3 args\n\n;; CORRECT:\n(let ((fd (open \"/dev/null\" O_RDONLY)))\n  (let ((port (fdopen fd 'in #t)))\n    (input-port? port)  ;; => #t\n    (close-port port)))\n\n;; Typical use with pipe 'none for shell pipelines:\n(import :std/os/pipe)\n(receive (rfd wfd) (pipe 'none)\n  (let ((write-port (fdopen wfd 'out #t))\n        (read-port  (fdopen rfd 'in #t)))\n    (display \"hello\" write-port)\n    (force-output write-port)\n    (close-port write-port)\n    (let ((line (read-line read-port)))\n      (close-port read-port)\n      line)))\n;; => \"hello\"",
    "notes": "fdopen is strictly 3-arity. The third argument (close-on-gc?) should almost always be #t so the fd is cleaned up when the port is garbage collected. Passing #f means you're responsible for closing the fd manually. The direction must be 'in or 'out — there is no 'inout mode for fdopen.",
    "related": [
      "os-pipe-create-fd-pair",
      "open-process-undocumented-settings"
    ]
  },
  {
    "id": "ffi-multi-type-callback-trampolines",
    "title": "Multiple callback trampolines for different signal signatures (void, string, int, bool)",
    "tags": [
      "ffi",
      "callback",
      "trampoline",
      "c-define",
      "signal",
      "multi-type",
      "dispatch",
      "Qt",
      "GUI"
    ],
    "imports": [
      ":std/foreign"
    ],
    "code": ";; PATTERN: When a C library has signals/callbacks with DIFFERENT signatures\n;; (e.g., void(id), void(id, string), void(id, int), void(id, bool)),\n;; use separate dispatch tables and trampolines per signature type.\n;; Shares a single callback ID counter across all tables.\n\n;; Inside begin-ffi:\n\n;; 1. Separate dispatch tables per callback signature\n(define *void-handlers* (make-hash-table))\n(define *string-handlers* (make-hash-table))\n(define *int-handlers* (make-hash-table))\n(define *bool-handlers* (make-hash-table))\n(define *next-callback-id* 0)\n\n;; Register functions return a unique ID across all tables\n(define (register-void-handler! proc)\n  (let ((id *next-callback-id*))\n    (set! *next-callback-id* (+ id 1))\n    (hash-put! *void-handlers* id proc)\n    id))\n\n(define (register-string-handler! proc)\n  (let ((id *next-callback-id*))\n    (set! *next-callback-id* (+ id 1))\n    (hash-put! *string-handlers* id proc)\n    id))\n\n(define (register-int-handler! proc)\n  (let ((id *next-callback-id*))\n    (set! *next-callback-id* (+ id 1))\n    (hash-put! *int-handlers* id proc)\n    id))\n\n(define (register-bool-handler! proc)\n  (let ((id *next-callback-id*))\n    (set! *next-callback-id* (+ id 1))\n    (hash-put! *bool-handlers* id proc)\n    id))\n\n;; 2. Four c-define trampolines — each handles one signature\n(c-define (ffi_void_cb id) (long) void \"ffi_void_cb\" \"\"\n  (let ((h (hash-ref *void-handlers* id #f))) (when h (h))))\n\n(c-define (ffi_string_cb id value) (long UTF-8-string) void \"ffi_string_cb\" \"\"\n  (let ((h (hash-ref *string-handlers* id #f))) (when h (h value))))\n\n(c-define (ffi_int_cb id value) (long int) void \"ffi_int_cb\" \"\"\n  (let ((h (hash-ref *int-handlers* id #f))) (when h (h value))))\n\n(c-define (ffi_bool_cb id value) (long int) void \"ffi_bool_cb\" \"\"\n  (let ((h (hash-ref *bool-handlers* id #f)))\n    (when h (h (not (= value 0))))))  ;; convert C int to Scheme boolean\n\n;; 3. Static C trampolines that forward to the c-define'd functions\n;; (c-declare block — must be in same compilation unit)\n(c-declare #<<END-C\nvoid ffi_void_cb(long id);\nvoid ffi_string_cb(long id, char* value);\nvoid ffi_int_cb(long id, int value);\nvoid ffi_bool_cb(long id, int value);\n\nstatic void void_trampoline(long id) { ffi_void_cb(id); }\nstatic void string_trampoline(long id, const char* v) { ffi_string_cb(id, (char*)v); }\nstatic void int_trampoline(long id, int v) { ffi_int_cb(id, v); }\nstatic void bool_trampoline(long id, int v) { ffi_bool_cb(id, v); }\n\n/* C wrapper connects a specific signal to the appropriate trampoline */\n/* Example: button clicked → void trampoline */\nstatic void ffi_connect_clicked(void* btn, long id) {\n    my_button_on_clicked(btn, void_trampoline, id);\n}\n/* Example: text changed → string trampoline */\nstatic void ffi_connect_text_changed(void* edit, long id) {\n    my_edit_on_text_changed(edit, string_trampoline, id);\n}\nEND-C\n)\n\n;; 4. Bind the connection wrappers\n(define-c-lambda raw_connect_clicked ((pointer void) long) void \"ffi_connect_clicked\")\n(define-c-lambda raw_connect_text_changed ((pointer void) long) void \"ffi_connect_text_changed\")\n\n;; === High-level usage ===\n;; (def (on-clicked! button handler)\n;;   (raw_connect_clicked button (register-void-handler! handler)))\n;;\n;; (def (on-text-changed! edit handler)\n;;   (raw_connect_text_changed edit (register-string-handler! handler)))\n;;\n;; (on-clicked! my-btn (lambda () (displayln \"clicked!\")))\n;; (on-text-changed! my-edit (lambda (text) (displayln \"text: \" text)))",
    "notes": "Extends the single-dispatch-table recipe to handle C libraries (like Qt, GTK) where different signals have different callback signatures. Key points: (1) Share one ID counter across all tables so IDs never collide. (2) The bool trampoline takes int from C and converts to Scheme boolean with (not (= value 0)). (3) Forward declarations for c-define use char* not const char* (Gambit generates char*). (4) Static trampolines cast const char* → char* to bridge the C library's const signatures to Gambit's char* c-define. (5) Each signal connection gets its own C wrapper that passes the right trampoline.",
    "related": [
      "ffi-callback-dispatch-table",
      "c-define-char-string-const-mismatch",
      "ffi-cfun-assign-const-char-fix"
    ]
  },
  {
    "id": "tty-mode-set-six-args",
    "title": "tty-mode-set! takes 6 arguments, not 5 (port + 4 bools + speed)",
    "tags": [
      "tty-mode-set!",
      "terminal",
      "raw",
      "cooked",
      "arity",
      "six",
      "speed"
    ],
    "imports": [],
    "code": ";; GOTCHA: tty-mode-set! takes 6 arguments, not 5.\n;; The internal ##tty-mode-set! reveals the true signature:\n;;   (tty-mode-set! port allow-special echo output-raw input-raw speed)\n;; The 6th argument is a speed/flags parameter — use 0 for default.\n;;\n;; Evidence from Gambit source (lib/std/misc/ports~0.scm):\n;;   (##tty-mode-set! port '#f '#f '#t '#t '0)  ;; raw mode\n;;   (##tty-mode-set! port '#t '#t '#f '#f '0)  ;; cooked mode\n\n;; WRONG — only 5 args, will throw arity error or silently fail:\n;; (tty-mode-set! port #t #f #f #t)\n\n;; CORRECT — 6 args including speed=0:\n;; Raw mode (for line editor):\n(tty-mode-set! (current-input-port) #t #f #f #t 0)\n\n;; Cooked mode (restore):\n(tty-mode-set! (current-input-port) #t #t #f #f 0)\n\n;; Fully raw (no signal processing):\n(tty-mode-set! (current-input-port) #f #f #t #t 0)\n\n;; Safe pattern with dynamic-wind:\n(def (with-raw-terminal thunk)\n  (let ((port (current-input-port)))\n    (dynamic-wind\n      (lambda () (tty-mode-set! port #t #f #f #t 0))\n      thunk\n      (lambda () (tty-mode-set! port #t #t #f #f 0)))))",
    "notes": "The existing cookbook recipe \"tty-mode-set-raw-cooked\" shows 5 args — that is WRONG for Gerbil v0.19+. gerbil_doc reports arity:6 for tty-mode-set!. The 6th argument (speed) should be 0 for default. Discovered by examining Gambit's own std/misc/ports module which uses ##tty-mode-set! with 6 args including a trailing '0. Without the 6th arg, the call may silently fail or throw a type exception, leaving the terminal in an unexpected state.",
    "related": [
      "tty-mode-set-raw-cooked"
    ]
  },
  {
    "id": "signal-handler-zero-arity-callback",
    "title": "add-signal-handler! callback takes 0 arguments, not 1",
    "tags": [
      "signal",
      "handler",
      "callback",
      "arity",
      "zero",
      "add-signal-handler!"
    ],
    "imports": [
      ":std/os/signal",
      ":std/os/signal-handler"
    ],
    "code": "(import :std/os/signal :std/os/signal-handler)\n\n;; GOTCHA: The callback passed to add-signal-handler! takes ZERO arguments.\n;; The signal number is NOT passed to the handler.\n;;\n;; The existing cookbook recipe shows (lambda (sig) ...) — that is WRONG\n;; and causes: \"Wrong number of arguments passed to procedure\"\n\n;; WRONG — handler takes 1 arg:\n;; (add-signal-handler! SIGINT (lambda (sig) (displayln \"caught\")))\n;; => ERROR at runtime: Wrong number of arguments passed to procedure\n\n;; CORRECT — handler takes 0 args:\n(add-signal-handler! SIGINT (lambda () (displayln \"caught SIGINT\")))\n\n;; Example: flag signals for later processing\n(def *pending* [])\n\n(add-signal-handler! SIGINT\n  (lambda () (set! *pending* (cons \"INT\" *pending*))))\n\n(add-signal-handler! SIGTERM\n  (lambda () (set! *pending* (cons \"TERM\" *pending*))))\n\n;; Ignore a signal:\n(add-signal-handler! SIGPIPE (lambda () #!void))\n\n;; Remove handler:\n(remove-signal-handler! SIGINT)",
    "notes": "The existing recipe \"signal-handler-register-remove\" shows (lambda (sig) ...) with 1 arg — that is WRONG. The signal dispatcher in :std/os/signal-handler calls the callback with zero arguments. The error message is: \"Wrong number of arguments passed to procedure (#<procedure>)\" and appears asynchronously in the signal-handler-wait thread. Discovered by debugging gsh shell where all signal handlers were failing at runtime.",
    "related": [
      "signal-handler-register-remove"
    ]
  },
  {
    "id": "c-ffi-isatty-returns-int-not-bool",
    "title": "C FFI isatty returns int (1=true, 0=false); 0 is truthy in Gerbil",
    "tags": [
      "ffi",
      "isatty",
      "truthy",
      "zero",
      "int",
      "boolean",
      "C"
    ],
    "imports": [],
    "code": ";; GOTCHA: C functions bound via c-lambda that return int for boolean\n;; values return 0/1 integers, not #f/#t. In Gerbil, 0 is TRUTHY!\n;; Only #f is falsy.\n\n;; Example FFI binding:\n;; (define-c-lambda ffi-isatty (int) int \"isatty\")\n\n;; WRONG — 0 is truthy, so this is always true:\n;; (if (ffi-isatty 0)\n;;   (displayln \"is a tty\")     ;; ALWAYS taken, even for pipes!\n;;   (displayln \"not a tty\"))\n\n;; CORRECT — compare against 1 explicitly:\n;; (if (= (ffi-isatty 0) 1)\n;;   (displayln \"is a tty\")\n;;   (displayln \"not a tty\"))\n\n;; General pattern for C boolean results:\n;; (def (isatty? fd) (= (ffi-isatty fd) 1))\n\n;; This applies to ALL C functions returning int as boolean:\n;;   isatty(), access(), tcsetattr(), etc.\n;; Always compare with = 1 or wrap in a Scheme predicate.",
    "notes": "This is a subtle but critical bug source. In C, 0 is false and non-zero is true. In Gerbil, only #f is false — 0 is truthy. When binding C functions that return int-as-boolean via c-lambda, you MUST explicitly check (= result 1) or (not (zero? result)). Discovered while debugging gsh: ffi-isatty returned 0 for a pipe, but the shell still entered interactive mode because 0 is truthy.",
    "related": [
      "hash-ref-void-truthy"
    ]
  },
  {
    "id": "fd-e-extract-raw-fd-from-port",
    "title": "Extract raw integer fd from a Gambit port using fd-e from :std/os/fd",
    "tags": [
      "fd",
      "fd-e",
      "port",
      "file-descriptor",
      "raw-fd",
      "extract",
      "integer"
    ],
    "imports": [
      ":std/os/fd",
      ":std/os/fdio",
      ":std/os/fcntl"
    ],
    "code": ";; fd-e from :std/os/fd extracts the raw integer file descriptor from a Gambit port.\n;; This is essential when you need to pass fds to FFI functions like dup2.\n(import :std/os/fd :std/os/fdio :std/os/fcntl)\n\n;; open from :std/os/fdio returns a Gambit PORT (not a raw integer fd):\n(let ((port (open \"/dev/null\" O_RDONLY)))\n  (list (input-port? port)    ;; => #t  (it's a port!)\n        (fd-e port)           ;; => 5   (the raw integer fd)\n        (fd-type port)))      ;; => file\n;; => (#t 5 file)\n\n;; Typical use case: open a file, get its raw fd for dup2\n(let* ((port (open \"/tmp/output.txt\" (bitwise-ior O_WRONLY O_CREAT O_TRUNC) #o644))\n       (raw-fd (fd-e port)))\n  ;; raw-fd is an integer, usable with FFI dup2\n  (list raw-fd (integer? raw-fd)))\n;; => (5 #t)\n\n;; CAUTION: Gambit still owns the port.\n;; - close-port will close the underlying fd\n;; - If port is GC'd and close-on-gc is set, the fd gets closed\n;; - After dup2(raw-fd, target-fd), closing raw-fd via the port\n;;   does NOT affect the dup'd target-fd\n\n;; Pattern for shell redirections (redirect stdout to a file):\n;; 1. Open file → get port → extract raw fd\n;; 2. dup2(raw-fd, 1) to redirect stdout\n;; 3. close-port the original port (fd 1 still points to the file)\n;; 4. (Gambit builtins: also set current-output-port)",
    "notes": "fd-e is exported from :std/os/fd alongside fdopen, fd-type, and fd-io. fd-type returns a symbol like 'file, 'pipe, 'socket. The open function from :std/os/fdio accepts 2 or 3 args: (open path flags) or (open path flags mode). It always returns a Gambit port, not a raw fd. This is different from C's open() which returns an int. Use fd-e to bridge from Gambit's port world to the raw fd world needed for FFI calls like dup2, dup, close, etc.",
    "related": [
      "fdopen-3-arity",
      "os-pipe-create-fd-pair",
      "fcntl-f-dupfd-partial-dup"
    ]
  },
  {
    "id": "qt-offscreen-headless-testing",
    "title": "Run Qt FFI tests headless with QT_QPA_PLATFORM=offscreen",
    "tags": [
      "qt",
      "test",
      "headless",
      "offscreen",
      "makefile",
      "segfault",
      "QT_QPA_PLATFORM"
    ],
    "imports": [],
    "code": ";; Qt6 requires a display to create widgets. For headless testing,\n;; set QT_QPA_PLATFORM=offscreen to use Qt's offscreen plugin.\n;; No xvfb-run needed.\n;;\n;; IMPORTANT: The offscreen plugin causes a benign SIGSEGV at process exit\n;; (after all tests complete and results are reported). This means the\n;; process exits with code 139 even though all tests passed.\n;;\n;; Makefile pattern to handle this:\n;;\n;; test: build\n;; \t@QT_QPA_PLATFORM=offscreen LD_LIBRARY_PATH=$(CURDIR)/vendor:$$LD_LIBRARY_PATH \\\n;; \t\tgerbil test ./... > /tmp/gerbil-qt-test.log 2>&1 || true; \\\n;; \tcat /tmp/gerbil-qt-test.log; \\\n;; \tif grep -q \"FAILURE\" /tmp/gerbil-qt-test.log; then \\\n;; \t\texit 1; \\\n;; \tfi\n;;\n;; This captures output, ignores the exit code, displays results,\n;; and only fails if gerbil test actually reported FAILURE.\n;;\n;; Test file pattern — create QApplication once, share across tests:\n\n(import :std/test :my-project/qt)\n(export qt-test)\n\n(def test-app #f)\n(def (ensure-app!)\n  (unless test-app\n    (set! test-app (qt-app-create))))\n\n(def qt-test\n  (test-suite \"qt\"\n    (test-case \"app create\"\n      (ensure-app!)\n      (check (not (eq? test-app #f)) => #t))\n\n    (test-case \"label round-trip\"\n      (let ((l (qt-label-create \"hello\")))\n        (check (qt-label-text l) => \"hello\")\n        (qt-widget-destroy! l)))\n\n    ;; Do NOT destroy app — let process exit handle it.\n    ;; Explicit qt-app-destroy! can cause double-free with offscreen.\n  ))",
    "notes": "Qt's offscreen platform plugin (qt6-base-dev includes it on Ubuntu) creates a minimal rendering backend without a display server. The SIGSEGV at exit is a known Qt issue with the offscreen plugin during QApplication destruction — it happens after all test reporting is complete. Do NOT explicitly call qt-app-destroy! in test cleanup when using offscreen — it can cause the segfault to happen mid-test instead of at exit. The Makefile pattern checks for the string \"FAILURE\" in gerbil test output rather than relying on exit code, which elegantly handles the benign crash.",
    "related": [
      "write-tests-with-std-test",
      "ffi-callback-dispatch-table",
      "qt-application-argc-static"
    ]
  },
  {
    "id": "ffi-signal-wrapper-returns-void",
    "title": "FFI signal connection wrappers return void — don't test return value",
    "tags": [
      "ffi",
      "callback",
      "signal",
      "void",
      "return",
      "test",
      "qt",
      "gtk"
    ],
    "imports": [],
    "code": ";; GOTCHA: When wrapping C signal-connection functions, the high-level\n;; wrapper typically calls a void C function as its last expression.\n;; In Scheme, this returns #!void — NOT the callback ID.\n;;\n;; Example:\n;; (def (qt-on-clicked! button handler)\n;;   (let ((id (register-qt-void-handler! handler)))\n;;     (raw_qt_push_button_on_clicked button id)))\n;;     ;; ^^^ this is a void c-lambda — returns #!void, not id\n;;\n;; WRONG in tests:\n;; (let ((id (qt-on-clicked! btn (lambda () #t))))\n;;   (check (number? id) => #t))   ;; FAILS: id is #!void\n;;\n;; CORRECT — just verify no crash:\n;; (qt-on-clicked! btn (lambda () #t))\n;; ;; no assertion on return value\n;;\n;; If you NEED the callback ID returned, restructure:\n;; (def (qt-on-clicked! button handler)\n;;   (let ((id (register-qt-void-handler! handler)))\n;;     (raw_qt_push_button_on_clicked button id)\n;;     id))  ;; <-- explicitly return id",
    "notes": "This bites you when writing tests for FFI callback registration. The register-*-handler! function returns an integer ID, but the void c-lambda called after it returns #!void, which becomes the return value of the let form. (number? #!void) => #f. Fix either by adding an explicit return of id, or by not asserting on the return value in tests. The pattern affects any wrapper where register → connect is done in a let body.",
    "related": [
      "ffi-callback-dispatch-table",
      "multiple-callback-trampolines",
      "write-tests-with-std-test"
    ]
  },
  {
    "id": "character-port-from-raw-fd-via-dev-fd",
    "title": "Create Gambit character port from raw fd via /dev/fd/N",
    "tags": [
      "fd",
      "port",
      "character",
      "raw",
      "dev",
      "redirect",
      "pipe",
      "display",
      "write"
    ],
    "imports": [],
    "code": ";; fdopen from :std/os/fd creates BYTE ports, which CANNOT be used with\n;; display, write-char, read-char, read-line, etc. (causes type-exception).\n;; Instead, use /dev/fd/N to create proper Gambit character ports from raw fds.\n;; This works on Linux (and most Unix systems).\n\n;; Example: create read/write character ports from pipe fds\n;; (Assuming ffi-pipe-raw returns two raw integer fds)\n(import :gsh/ffi)  ;; for ffi-pipe-raw\n\n(let-values (((read-fd write-fd) (ffi-pipe-raw)))\n  ;; Create a character output port for the write end\n  (let ((out (open-output-file (string-append \"/dev/fd/\" (number->string write-fd)))))\n    (display \"hello from pipe\" out)  ;; display works!\n    (newline out)\n    (force-output out)\n    (close-port out))\n  (ffi-close-fd write-fd)  ;; close raw fd too\n\n  ;; Create a character input port for the read end\n  (let ((in (open-input-file (string-append \"/dev/fd/\" (number->string read-fd)))))\n    (let ((line (read-line in)))  ;; read-line works!\n      (close-port in)\n      (ffi-close-fd read-fd)\n      line)))\n;; => \"hello from pipe\"\n\n;; WRONG — fdopen creates byte ports that fail with display:\n;; (let ((p (fdopen write-fd 'out #t)))\n;;   (display \"hello\" p))  ;; ERROR: Character OUTPUT PORT expected\n\n;; This pattern is essential for:\n;; - Shell command substitution (capture stdout via pipe)\n;; - Shell pipeline builtins (set current-output-port to pipe)\n;; - Any case where Gambit's display/read-line needs to use a raw fd",
    "notes": "fdopen from :std/os/fd creates Gerbil byte ports (raw I/O), but Gambit's standard I/O functions (display, write, read-char, read-line) require character ports. The /dev/fd/N virtual filesystem on Linux lets you create a proper Gambit character port from any open raw fd. Always close both the Gambit port AND the raw fd when done. This pattern was discovered while implementing shell command substitution and pipeline support.",
    "related": [
      "fd-e-extract-raw-fd-from-port",
      "fdopen-3-arity",
      "os-pipe-create-fd-pair"
    ]
  },
  {
    "id": "break-circular-import-with-make-parameter",
    "title": "Break circular imports with make-parameter callback",
    "tags": [
      "circular",
      "import",
      "dependency",
      "parameter",
      "callback",
      "module"
    ],
    "imports": [],
    "code": ";; Problem: module A needs to call a function from module B,\n;; but module B imports module A — circular dependency.\n;;\n;; Solution: use make-parameter as a callback slot in a shared module.\n;; The \"upper\" module sets the parameter at startup.\n\n;; --- shared.ss (imported by both) ---\n;; (export #t)\n;; (def *execute-fn* (make-parameter #f))\n\n;; --- lower.ss (needs to call the function) ---\n;; (import :mypackage/shared)\n;; (def (do-eval input env)\n;;   (let ((exec-fn (*execute-fn*)))\n;;     (if exec-fn\n;;       (exec-fn input env)\n;;       (error \"executor not initialized\"))))\n\n;; --- upper.ss (defines the function, imports lower.ss) ---\n;; (import :mypackage/shared :mypackage/lower)\n;; (def (execute-input input env)\n;;   ... uses lower.ss functions ...)\n;;\n;; ;; At startup, wire the callback:\n;; (*execute-fn* (lambda (input env) (execute-input input env)))\n\n;; This pattern is essential for shells, REPLs, and plugin systems\n;; where eval/source/command-substitution need to call back into\n;; the main executor without creating circular imports.",
    "notes": "The key insight is that make-parameter creates a thread-local mutable binding that can be set at runtime, breaking the compile-time circular dependency. The parameter starts as #f and gets set during initialization. Always check for #f before calling to handle the case where init hasn't run yet. This is the standard Scheme pattern for dependency inversion."
  },
  {
    "id": "ffi-posix-syscall-begin-ffi",
    "title": "Wrap POSIX syscalls (dup, dup2, open, close, pipe) via begin-ffi",
    "tags": [
      "ffi",
      "begin-ffi",
      "posix",
      "syscall",
      "dup2",
      "open",
      "close",
      "pipe",
      "c-lambda",
      "c-declare"
    ],
    "imports": [
      ":std/foreign"
    ],
    "code": ";; Gerbil lacks built-in dup2, raw open(), and waitpid with WUNTRACED.\n;; Use begin-ffi + c-declare + define-c-lambda to wrap POSIX libc calls.\n\n(import :std/foreign)\n\n(begin-ffi (ffi-dup ffi-dup2 ffi-close-fd ffi-open-raw ffi-isatty)\n\n  ;; Include required C headers in c-declare with heredoc syntax\n  (c-declare #<<END-C\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\nEND-C\n  )\n\n  ;; Simple 1:1 wrappers — just name the C function\n  (define-c-lambda ffi-dup (int) int \"dup\")\n  (define-c-lambda ffi-dup2 (int int) int \"dup2\")\n  (define-c-lambda ffi-close-fd (int) int \"close\")\n  (define-c-lambda ffi-isatty (int) int \"isatty\")\n\n  ;; C's open() — returns raw integer fd (not a Gambit port!)\n  ;; flags: O_RDONLY=0, O_WRONLY=1, O_RDWR=2\n  ;;        O_CREAT=64, O_TRUNC=512, O_APPEND=1024 (Linux)\n  ;; mode: file permission bits e.g. #o666\n  (define-c-lambda ffi-open-raw (char-string int int) int \"open\")\n)\n\n;; Usage: open a file, dup2 onto stdout, then restore\n;; (let ((saved (ffi-dup 1)))          ;; save real fd 1\n;;   (let ((fd (ffi-open-raw \"/tmp/out.txt\"\n;;               (bitwise-ior 1 64 512)  ;; O_WRONLY|O_CREAT|O_TRUNC\n;;               #o666)))\n;;     (ffi-dup2 fd 1)                  ;; redirect stdout to file\n;;     (ffi-close-fd fd))               ;; close extra fd\n;;   ;; ... run command (inherits redirected fd 1) ...\n;;   (ffi-dup2 saved 1)                 ;; restore stdout\n;;   (ffi-close-fd saved))              ;; close saved copy\n\n;; For multi-value returns (e.g. waitpid), use static vars + helper:\n;; (c-declare \"static int _status; ...\")\n;; (define-c-lambda _do_waitpid (int int) int \"ffi_do_waitpid\")\n;; (define-c-lambda _get_status () int \"ffi_get_status\")",
    "notes": "Key points: (1) begin-ffi's first arg is the list of Scheme symbols to export from the FFI block. (2) c-declare uses Gambit's heredoc syntax #<<TAG ... TAG for multi-line C code. (3) define-c-lambda maps Scheme types to C: int↔int, char-string↔const char*. (4) For functions returning multiple values (like waitpid with status), use C static vars and multiple c-lambda getters. (5) MUST include <fcntl.h> for open(), otherwise you get 'implicit declaration' warnings. (6) O_* flag values are Linux-specific — for portability, define them in C code using the actual macros.",
    "related": [
      "fd-e-extract-raw-fd-from-port",
      "character-port-from-raw-fd-via-dev-fd",
      "fcntl-f-dupfd-partial-dup"
    ]
  },
  {
    "id": "pipeline-fd-closing-pattern",
    "title": "Pipeline fd management: close write-end in parent to avoid hangs",
    "tags": [
      "pipeline",
      "pipe",
      "fd",
      "close",
      "hang",
      "EOF",
      "dup2",
      "parent",
      "child"
    ],
    "imports": [],
    "code": ";; CRITICAL PATTERN: When implementing cmd1 | cmd2, the parent process\n;; must close its copy of the pipe write-end IMMEDIATELY after launching\n;; the producer (cmd1). Otherwise cmd2 never sees EOF and hangs forever.\n;;\n;; WRONG — hangs:\n;; (let-values (((rfd wfd) (pipe-raw)))\n;;   (launch cmd1 with stdout→wfd)\n;;   (launch cmd2 with stdin→rfd)\n;;   ;; Parent still holds wfd open!\n;;   ;; cmd2 reads from rfd, never gets EOF, HANGS\n;;   (close wfd)   ;; too late — cmd2 is already blocking\n;;   (close rfd))\n;;\n;; CORRECT — works:\n;; (let-values (((rfd wfd) (pipe-raw)))\n;;   ;; Save original fds\n;;   (let ((saved-stdout (ffi-dup 1)))\n;;     ;; Redirect stdout to pipe write-end\n;;     (ffi-dup2 wfd 1)\n;;     (ffi-close-fd wfd)           ;; close original wfd in parent\n;;     ;; Launch cmd1 (inherits redirected fd 1)\n;;     (launch-cmd1)\n;;     ;; Restore stdout\n;;     (ffi-dup2 saved-stdout 1)\n;;     (ffi-close-fd saved-stdout))\n;;   ;; Now only cmd1 holds the write-end — when cmd1 exits, cmd2 gets EOF\n;;   (let ((saved-stdin (ffi-dup 0)))\n;;     (ffi-dup2 rfd 0)\n;;     (ffi-close-fd rfd)           ;; close original rfd in parent\n;;     (launch-cmd2)\n;;     (ffi-dup2 saved-stdin 0)\n;;     (ffi-close-fd saved-stdin))\n;;   (wait-for-both))\n;;\n;; The key insight: after dup2(wfd, 1), the pipe write-end is now fd 1.\n;; Closing the original wfd means only the child process (cmd1) holds\n;; the write-end. When cmd1 exits, its fd 1 closes, and cmd2 gets EOF.\n;;\n;; For N-command pipelines: create N-1 pipes upfront, close each pipe's\n;; write-end right after launching the command that writes to it, and\n;; close each pipe's read-end right after launching the command that\n;; reads from it. Use set-car!/set-cdr! or similar to track which fds\n;; have been closed to avoid double-close.",
    "notes": "This is the #1 cause of pipeline hangs in shell implementations. The POSIX rule: a pipe read returns EOF only when ALL write-end file descriptors are closed. If the parent process forks a child and doesn't close its own copy of the write-end, the pipe has 2 writers (parent + child), so closing just the child's copy on exit still leaves the parent's copy open. The reader blocks forever. The dup2 approach (dup2 pipe-fd onto 0/1, then close the original) is cleaner than trying to pass extra fds to children, especially since Gambit's open-process closes all fds > 2 in the child.",
    "related": [
      "os-pipe-create-fd-pair",
      "ffi-posix-syscall-begin-ffi",
      "character-port-from-raw-fd-via-dev-fd"
    ]
  },
  {
    "id": "unix-timestamp-to-formatted-date",
    "title": "Convert Unix timestamp to formatted date string via SRFI-19",
    "tags": [
      "srfi-19",
      "unix",
      "timestamp",
      "date",
      "format",
      "make-time",
      "time-utc->date"
    ],
    "imports": [
      ":std/srfi/19"
    ],
    "code": "(import :std/srfi/19)\n\n;; Convert a Unix timestamp (integer seconds) to a formatted date string.\n;; Three steps: make-time -> time-utc->date -> date->string\n\n;; Basic pattern:\n(def (format-unix-timestamp unix-ts fmt)\n  (let* ((secs (inexact->exact (floor unix-ts)))\n         (t (make-time time-utc 0 secs))       ;; make-time takes: type nanoseconds seconds\n         (d (time-utc->date t 0)))              ;; 0 = UTC offset\n    (date->string d fmt)))\n\n;; Examples:\n(format-unix-timestamp 1609459200 \"~H:~M\")        ;; => \"00:00\"\n(format-unix-timestamp 1609459200 \"~b ~d\")         ;; => \"Jan 01\"\n(format-unix-timestamp 1609459200 \"~m/~d ~H:~M\")  ;; => \"01/01 00:00\"\n(format-unix-timestamp 1609459200 \"~Y-~m-~d\")      ;; => \"2021-01-01\"\n\n;; Adaptive time axis formatter (choose format based on data range):\n(def (make-time-format-fn range-seconds)\n  (let ((fmt (cond\n               ((>= range-seconds (* 365 86400)) \"~b ~d\")       ;; >= 1 year\n               ((>= range-seconds (* 30 86400))  \"~b ~d\")       ;; >= 30 days\n               ((>= range-seconds (* 7 86400))   \"~m/~d\")       ;; >= 7 days\n               ((>= range-seconds 86400)          \"~m/~d ~H:~M\") ;; >= 1 day\n               (else                              \"~H:~M\"))))    ;; < 1 day\n    (lambda (unix-ts)\n      (format-unix-timestamp unix-ts fmt))))",
    "notes": "make-time arity is 3: (make-time type nanoseconds seconds). time-utc->date arity is 2: (time-utc->date time tz-offset). The tz-offset 0 means UTC. If SRFI-19 is imported and you also need Gambit's current-time, use ##current-time to bypass the shadow. Common format directives: ~Y (4-digit year), ~m (2-digit month), ~d (2-digit day), ~H (24h hour), ~M (minute), ~b (abbreviated month name like \"Jan\").",
    "related": [
      "date-time-formatting-srfi-19",
      "srfi-19-current-time-shadows-gambit",
      "current-time-seconds"
    ]
  },
  {
    "id": "format-tilde-escape-pitfall",
    "title": "std/format uses tilde as escape — avoid tilde in dynamic strings",
    "tags": [
      "format",
      "tilde",
      "escape",
      "string-append",
      "promql",
      "hang",
      "freeze"
    ],
    "imports": [
      ":std/format"
    ],
    "code": "(import :std/format)\n\n;; Gerbil's (format) from :std/format uses ~ as the escape character.\n;; If your format string contains literal tildes, format will try to\n;; interpret them as directives and may HANG or crash.\n\n;; WRONG — hangs/crashes because ~\" is interpreted as a format directive:\n;; (format \"{__name__=~\\\"~a.*\\\"}\" \"node_\")  ;; HANGS!\n\n;; WRONG — even ~~ (literal tilde) before a quote can cause issues:\n;; (format \"{__name__=~~\\\"~a.*\\\"}\" \"node_\")  ;; may still hang\n\n;; CORRECT — use string-append instead when the template contains tildes:\n(string-append \"{__name__=~\\\"\" \"node_\" \".*\\\"}\")\n;; => \"{__name__=~\\\"node_.*\\\"}\"\n\n;; RULE OF THUMB:\n;; - Use (format \"~a ~a\" x y) for simple value interpolation\n;; - Use string-append when the template itself contains ~ characters\n;;   (common in PromQL regex match syntax: =~ )\n;; - ~~ produces a literal tilde, but mixing with quotes can confuse the parser\n\n;; Safe format usage:\n(format \"value: ~a, count: ~a\" 42 10)  ;; => \"value: 42, count: 10\"\n(format \"~aK\" 1.5)                      ;; => \"1.5K\"\n(format \"~ae~a\" 1.2 6)                  ;; => \"1.2e6\"",
    "notes": "This is especially dangerous because format may silently hang rather than error, making it hard to diagnose. PromQL queries commonly use =~ for regex matching, which conflicts with format's ~ escape. Always prefer string-append for building query strings that may contain special characters.",
    "related": [
      "string-subst-argument-order"
    ]
  },
  {
    "id": "sort-filter-not-builtin",
    "title": "sort, filter, delete-duplicates require imports — not builtins",
    "tags": [
      "sort",
      "filter",
      "delete-duplicates",
      "import",
      "builtin",
      "srfi-1",
      "std/sort"
    ],
    "imports": [
      ":std/sort",
      ":std/srfi/1"
    ],
    "code": ";; Common list operations that are NOT builtins and require explicit imports:\n\n;; sort — requires :std/sort\n(import :std/sort)\n(sort '(3 1 2) <)                       ;; => (1 2 3)\n(sort '(\"c\" \"a\" \"b\") string<?)          ;; => (\"a\" \"b\" \"c\")\n\n;; filter — requires :std/srfi/1\n(import :std/srfi/1)\n(filter odd? '(1 2 3 4 5))             ;; => (1 3 5)\n(delete-duplicates '(\"a\" \"b\" \"a\") equal?)  ;; => (\"a\" \"b\")\n\n;; If you want to avoid importing :std/srfi/1 for a one-off dedup,\n;; use a hash-table-based manual approach:\n(def (dedup-strings lst)\n  (let ((seen (make-hash-table)))\n    (let loop ((rest lst) (acc []))\n      (cond\n        ((null? rest) (reverse acc))\n        ((hash-get seen (car rest))\n         (loop (cdr rest) acc))\n        (else\n         (hash-put! seen (car rest) #t)\n         (loop (cdr rest) (cons (car rest) acc)))))))\n(dedup-strings '(\"a\" \"b\" \"a\" \"c\"))  ;; => (\"a\" \"b\" \"c\")\n\n;; THESE ARE builtins (no import needed):\n;; map, for-each, append, reverse, length, assoc, member,\n;; list->vector, vector->list, string->list, list->string,\n;; apply, values, call-with-values, make-hash-table, hash-put!, hash-get,\n;; iota, create-directory*",
    "notes": "This is a common gotcha — sort and filter feel like they should be builtins but aren't. sort is in :std/sort, filter and delete-duplicates are in :std/srfi/1. The error message is \"Unbound variable: sort\" (or filter). Also note: iota IS a builtin in Gerbil (from Gambit), and create-directory* is also a builtin.",
    "related": [
      "sort-a-list",
      "advanced-list-utilities"
    ]
  },
  {
    "id": "when-returns-void-in-boolean-context",
    "title": "Never use (when ...) as a boolean-returning function — use (if ... #t #f)",
    "tags": [
      "when",
      "void",
      "truthy",
      "boolean",
      "bug",
      "gotcha",
      "cond",
      "predicate"
    ],
    "imports": [],
    "code": ";; GOTCHA: (when cond body) returns #!void when cond is false.\n;; #!void is TRUTHY in Gerbil! Only #f is falsy.\n;;\n;; This commonly causes infinite loops or wrong branches in cond:\n\n;; WRONG — this function always returns truthy:\n(def (try-consume! state expected)\n  (when (match? state expected)  ;; returns #!void when false = truthy!\n    (advance! state)\n    #t))\n\n;; Used in cond, the wrong branch is always taken:\n(cond\n  ((try-consume! state \"+\") (handle-plus))  ;; ALWAYS taken!\n  ((try-consume! state \"-\") (handle-minus))\n  (else (handle-default)))\n\n;; CORRECT — use if with explicit #f:\n(def (try-consume! state expected)\n  (if (match? state expected)\n    (begin (advance! state) #t)\n    #f))",
    "notes": "This caused an infinite loop in gsh's arithmetic parser: arith-consume-op! used (when ...) and always returned truthy, causing parse-unary to infinitely recurse on the \"+\" branch. The fix was changing (when ...) to (if ... #t #f). Rule: any function whose return value will be tested for truthiness must NEVER use (when ...) — always use (if ... ... #f).",
    "related": [
      "hash-ref-void-truthy",
      "ffi-isatty-int-truthy"
    ]
  },
  {
    "id": "qt-modal-dialog-offscreen-hang",
    "title": "Qt modal dialogs (QFontDialog, QColorDialog) hang in offscreen mode",
    "tags": [
      "qt",
      "modal",
      "dialog",
      "offscreen",
      "hang",
      "blocking",
      "QFontDialog",
      "QColorDialog",
      "test"
    ],
    "imports": [],
    "code": ";; GOTCHA: Qt blocking modal dialogs hang forever in offscreen mode.\n;; QFontDialog::getFont() and QColorDialog::getColor() use exec()\n;; which blocks waiting for user interaction. With QT_QPA_PLATFORM=offscreen,\n;; there is no user — the dialog blocks forever, hanging your test suite.\n;;\n;; AFFECTED METHODS:\n;;   QFontDialog::getFont(bool *ok, QWidget *parent)\n;;   QColorDialog::getColor(QColor initial, QWidget *parent)\n;;   QInputDialog::getText/getInt/getDouble/getItem\n;;   QFileDialog::getOpenFileName/getSaveFileName (sometimes)\n;;   QMessageBox::exec() (sometimes — static methods may work)\n;;\n;; DO NOT test these in offscreen mode:\n;; (test-case \"font dialog\"           ;; HANGS FOREVER\n;;   (let ((font (qt-font-dialog app win)))\n;;     (check (eq? font #f) => #t)))\n;;\n;; CORRECT — skip modal dialog tests in offscreen mode:\n;; ;; Comment explaining why these tests are excluded:\n;; ;; QFontDialog/QColorDialog use blocking exec() — cannot be tested\n;; ;; in offscreen mode (no user to accept/cancel). Test via examples instead.\n;;\n;; WORKAROUND for CI: Test the non-blocking parts separately:\n;; - Test QFont creation, property access, round-trips (non-modal)\n;; - Test QColor creation, channel queries, hex output (non-modal)\n;; - Test the C shim functions directly (create/destroy/query)\n;; - Leave the actual dialog popup for manual example programs\n;;\n;; The API wrappers are typically simple pass-throughs:\n;; (def (qt-font-dialog app parent)\n;;   (let ((result (raw_qt_font_dialog_get_font parent)))\n;;     (if (not result) #f result)))  ;; returns QFont or #f if cancelled",
    "notes": "This applies to ANY Qt static dialog method that calls exec() internally. The root cause is that exec() enters a modal event loop that processes events until the dialog is accepted or rejected. In offscreen mode, no user can interact with the dialog, so exec() never returns. This is not a bug — it's inherent to blocking dialogs. The only safe approach is to skip these tests in headless/offscreen CI environments and test them manually via example programs.",
    "related": [
      "qt-offscreen-headless-testing",
      "qt-application-argc-static"
    ]
  },
  {
    "id": "qt-event-filter-no-moc",
    "title": "Qt event filter pattern without MOC (QObject::eventFilter override)",
    "tags": [
      "qt",
      "event",
      "filter",
      "eventFilter",
      "QObject",
      "MOC",
      "keyboard",
      "drag",
      "drop"
    ],
    "imports": [],
    "code": "// PATTERN: Intercept Qt events via QObject::eventFilter — no MOC needed.\n// This avoids Q_OBJECT macro, moc compilation, and signal/slot overhead.\n// Used for: keyboard events, drag-and-drop, mouse events, focus events.\n//\n// C++ shim pattern (in qt_shim.cpp):\n\nclass KeyPressFilter : public QObject {\n    // No Q_OBJECT macro — pure C++ virtual override\n    qt_callback_void m_callback;\n    long m_callback_id;\n    int m_last_key;\n    int m_last_modifiers;\n    char m_last_text[256];\n\npublic:\n    KeyPressFilter(QObject* parent, qt_callback_void cb, long id)\n        : QObject(parent), m_callback(cb), m_callback_id(id),\n          m_last_key(0), m_last_modifiers(0) {\n        m_last_text[0] = '\\0';\n    }\n\n    // Override eventFilter — this is a normal virtual method, no MOC\n    bool eventFilter(QObject* obj, QEvent* event) override {\n        if (event->type() == QEvent::KeyPress) {\n            QKeyEvent* ke = static_cast<QKeyEvent*>(event);\n            m_last_key = ke->key();\n            m_last_modifiers = static_cast<int>(ke->modifiers());\n            QByteArray utf8 = ke->text().toUtf8();\n            strncpy(m_last_text, utf8.constData(), sizeof(m_last_text) - 1);\n            m_last_text[sizeof(m_last_text) - 1] = '\\0';\n            if (m_callback) m_callback(m_callback_id);\n        }\n        return QObject::eventFilter(obj, event);  // pass to default\n    }\n\n    int lastKey() const { return m_last_key; }\n    int lastModifiers() const { return m_last_modifiers; }\n    const char* lastText() const { return m_last_text; }\n};\n\n// Install on a widget:\n// auto* filter = new KeyPressFilter(widget, callback, id);\n// widget->installEventFilter(filter);\n\n// SAME PATTERN works for DragEnter/Drop events:\n// class DropFilter : public QObject {\n//     bool eventFilter(QObject*, QEvent* event) override {\n//         if (event->type() == QEvent::DragEnter) { ... acceptProposedAction(); }\n//         if (event->type() == QEvent::Drop) { ... get mimeData()->text(); }\n//     }\n// };\n\n// KEY POINTS:\n// 1. No Q_OBJECT macro → no MOC step in build\n// 2. eventFilter is a normal C++ virtual method on QObject\n// 3. Store last event data in member variables → query from Scheme later\n// 4. Fire callback to notify Scheme, then Scheme queries the stored data\n// 5. Return false from eventFilter to let the event propagate normally",
    "notes": "This pattern is used in gerbil-qt for both keyboard events (KeyPressFilter) and drag-and-drop (DropFilter). The key insight is that QObject::eventFilter is a regular C++ virtual method override — it does NOT require the MOC (Meta-Object Compiler) or the Q_OBJECT macro. This makes it perfect for FFI bindings where running MOC is impractical. The \"fire callback + query\" pattern (instead of passing event data directly in the callback) avoids complex multi-argument callbacks and works with the simple void trampoline.",
    "related": [
      "multiple-callback-trampolines",
      "qt-application-argc-static",
      "qt-offscreen-headless-testing"
    ]
  },
  {
    "id": "qt-painter-onto-pixmap",
    "title": "QPainter draw onto QPixmap then display on QLabel (no paintEvent override)",
    "tags": [
      "qt",
      "QPainter",
      "QPixmap",
      "draw",
      "canvas",
      "paint",
      "label",
      "FFI",
      "graphics"
    ],
    "imports": [],
    "code": ";; PATTERN: Use QPainter to draw onto a QPixmap, then display via QLabel.\n;; This avoids needing to override QWidget::paintEvent (which requires\n;; a C++ subclass + virtual method override — very complex from FFI).\n;;\n;; Steps:\n;; 1. Create a blank QPixmap (canvas)\n;; 2. Create QPainter targeting that pixmap\n;; 3. Draw shapes, text, etc.\n;; 4. Call painter-end to flush\n;; 5. Set pixmap on a QLabel for display\n;; 6. Destroy painter (separate from pixmap)\n\n;; Example (using gerbil-qt high-level API):\n(let* ((canvas (qt-pixmap-create-blank 400 300))\n       (p (qt-painter-create canvas)))\n\n  ;; Fill background\n  (qt-pixmap-fill! canvas 30 30 30)  ;; dark gray\n\n  ;; Enable antialiasing\n  (qt-painter-set-antialiasing! p #t)\n\n  ;; Draw shapes\n  (qt-painter-set-pen-color! p 255 0 0)\n  (qt-painter-set-pen-width! p 2)\n  (qt-painter-draw-rect! p 10 10 100 80)\n\n  (qt-painter-set-brush-color! p 0 0 255 alpha: 128)\n  (qt-painter-fill-rect! p 50 50 100 80 0 0 255)\n\n  (qt-painter-set-pen-color! p 255 255 255)\n  (qt-painter-draw-text! p 20 180 \"Hello from QPainter!\")\n\n  ;; Save/restore for transforms\n  (qt-painter-save! p)\n  (qt-painter-translate! p 200 150)\n  (qt-painter-rotate! p 45.0)   ;; NOTE: takes double, not int\n  (qt-painter-draw-rect! p -30 -20 60 40)\n  (qt-painter-restore! p)\n\n  ;; CRITICAL: end painting BEFORE using the pixmap elsewhere\n  (qt-painter-end! p)\n  (qt-painter-destroy! p)\n\n  ;; Display on label\n  (qt-label-set-pixmap! label canvas)\n\n  ;; ... later cleanup:\n  ;; (qt-pixmap-destroy! canvas)\n  )\n\n;; C++ shim side (qt_shim.cpp):\n;; QPainter paints onto QPixmap:\n;;   QPainter* painter = new QPainter(pixmap);\n;; QPainter::end() must be called before pixmap is used:\n;;   painter->end();\n;; Safety: qt_painter_destroy calls end() if still active:\n;;   void qt_painter_destroy(QPainter* p) {\n;;       if (p->isActive()) p->end();\n;;       delete p;\n;;   }\n\n;; KEY POINTS:\n;; 1. QPainter is NOT a QWidget — needs explicit destroy\n;; 2. QPixmap is NOT a QWidget — needs explicit destroy\n;; 3. painter->end() MUST be called before pixmap is displayed\n;; 4. rotate() and scale() take double, not int\n;; 5. Brush color alpha controls fill transparency\n;; 6. For animation: repaint by creating new QPainter, drawing, end, set-pixmap",
    "notes": "This \"paint onto pixmap\" approach is the practical way to do custom drawing from FFI without overriding virtual methods. For animation, create a QTimer callback that repaints the pixmap each frame. The alternative (overriding QWidget::paintEvent) requires a C++ subclass with a virtual method override, which is significantly more complex to wire through FFI. Both QPainter and QPixmap need explicit cleanup since they are not Qt-parented widgets.",
    "related": [
      "qt-event-filter-no-moc",
      "qt-modal-dialog-offscreen-hang",
      "qt-application-argc-static"
    ]
  },
  {
    "id": "gxc-exe-in-makefile",
    "title": "Link executable via gxc -exe in Makefile (workaround for defbuild-script exe deadlock)",
    "tags": [
      "exe",
      "gxc",
      "makefile",
      "build",
      "link",
      "rpath",
      "defbuild-script",
      "deadlock",
      "workaround"
    ],
    "imports": [],
    "code": ";; PROBLEM: defbuild-script exe target deadlocks in the build worker\n;; with \"Completion has already been posted\" error.\n;;\n;; SOLUTION: Remove exe from build.ss, link separately in Makefile.\n;;\n;; ---- build.ss ----\n;; #!/usr/bin/env gxi\n;; (import :std/build-script)\n;; (defbuild-script\n;;   '(\"module-a\"\n;;     \"module-b\"\n;;     \"main\"))  ;; NO exe target here\n;;\n;; ---- Makefile ----\n;; LOCAL_LIB := $(CURDIR)/.gerbil/lib\n;; DEP_LIB ?= $(HOME)/mine/my-dep/.gerbil/lib\n;; export GERBIL_LOADPATH := $(LOCAL_LIB):$(DEP_LIB)\n;;\n;; CAIRO_LDFLAGS := $(shell pkg-config --libs cairo libpng16)\n;; OPENSSL_LDFLAGS := $(shell pkg-config --libs openssl)\n;; OPENSSL_LIBDIR := $(shell pkg-config --variable=libdir openssl)\n;; CAIRO_LIBDIR := $(shell pkg-config --variable=libdir cairo)\n;;\n;; build:\n;; \tgerbil build\n;; \tmkdir -p .gerbil/bin\n;; \tgxc -exe -o .gerbil/bin/my-app \\\n;; \t  -ld-options \"$(CAIRO_LDFLAGS) $(OPENSSL_LDFLAGS) -Wl,-rpath,$(OPENSSL_LIBDIR) -Wl,-rpath,$(CAIRO_LIBDIR)\" \\\n;; \t  main.ss\n;;\n;; KEY POINTS:\n;; 1. LOCAL_LIB must be in GERBIL_LOADPATH so gxc can find same-package modules\n;; 2. -Wl,-rpath,<libdir> embeds library path in binary (no LD_LIBRARY_PATH needed)\n;; 3. Use pkg-config --variable=libdir to get the library directory for rpath\n;; 4. build.ss must be chmod +x",
    "notes": "The defbuild-script exe target uses a build worker that can deadlock with a \"Completion has already been posted\" error. This workaround compiles modules normally via `gerbil build` then links the exe separately via `gxc -exe` in the Makefile. Critical: the project's own .gerbil/lib must be in GERBIL_LOADPATH for gxc to resolve same-package imports like :mypackage/module.",
    "related": [
      "static-exe-with-deps",
      "openssl-version-mismatch-patchelf",
      "gerbil-build-loadpath"
    ]
  },
  {
    "id": "rpath-via-gxc-ld-options",
    "title": "Embed rpath in gxc -exe to avoid LD_LIBRARY_PATH and patchelf",
    "tags": [
      "rpath",
      "gxc",
      "ld-options",
      "openssl",
      "cairo",
      "patchelf",
      "linker",
      "runtime",
      "library",
      "pkg-config"
    ],
    "imports": [],
    "code": ";; PROBLEM: Compiled Gerbil executable can't find Homebrew/Linuxbrew\n;; shared libraries at runtime:\n;;   error: libcrypto.so.3: version `OPENSSL_3.4.0' not found\n;;\n;; SOLUTION: Pass -Wl,-rpath,<libdir> in gxc -exe -ld-options.\n;; This embeds the library search path directly in the binary at link time.\n;; No patchelf or LD_LIBRARY_PATH needed.\n;;\n;; PATTERN (in Makefile):\n;;\n;; CAIRO_LDFLAGS := $(shell pkg-config --libs cairo libpng16)\n;; OPENSSL_LDFLAGS := $(shell pkg-config --libs openssl)\n;; OPENSSL_LIBDIR := $(shell pkg-config --variable=libdir openssl)\n;; CAIRO_LIBDIR := $(shell pkg-config --variable=libdir cairo)\n;;\n;; build:\n;; \tgerbil build\n;; \tgxc -exe -o .gerbil/bin/my-app \\\n;; \t  -ld-options \"$(CAIRO_LDFLAGS) $(OPENSSL_LDFLAGS) \\\n;; \t    -Wl,-rpath,$(OPENSSL_LIBDIR) -Wl,-rpath,$(CAIRO_LIBDIR)\" \\\n;; \t  main.ss\n;;\n;; PATTERN (in build.ss with defbuild-script):\n;;\n;; (import :std/build-script :std/make)\n;; (defbuild-script\n;;   `(\"my-module\"\n;;     \"main\"\n;;     (exe: \"main\" bin: \"my-app\"\n;;           \"-ld-options\" ,(string-append\n;;                            (ldflags \"cairo\" \"-lcairo\") \" \"\n;;                            (ldflags \"openssl\" \"-lssl -lcrypto\") \" \"\n;;                            \"-Wl,-rpath,\" (pkg-config-libs \"openssl\") \" \"\n;;                            \"-Wl,-rpath,\" (pkg-config-libs \"cairo\")))))\n;;\n;; VERIFY with:\n;;   patchelf --print-rpath .gerbil/bin/my-app\n;;   ldd .gerbil/bin/my-app | grep ssl\n;;\n;; KEY: Use pkg-config --variable=libdir (not --libs) to get the\n;; directory path for -Wl,-rpath. --libs returns \"-L/path -lfoo\"\n;; but rpath needs just the directory \"/path\".",
    "notes": "This is the preferred approach over patchelf for Gerbil executables. Pass -Wl,-rpath,<libdir> directly to gxc -exe via -ld-options to embed library paths at link time. Use `pkg-config --variable=libdir <pkg>` to get the directory path (not --libs which returns flags). Works for any library installed via Homebrew/Linuxbrew that differs from the system version (commonly openssl, cairo, libpng). On macOS, use -Wl,-rpath,<libdir> as well (same syntax with Apple's ld).",
    "related": [
      "openssl-version-mismatch-patchelf",
      "gxc-exe-in-makefile",
      "build-ffi-pkg-config",
      "static-exe-with-deps"
    ]
  },
  {
    "id": "ffi-double-via-string-trampoline",
    "title": "Pass double values through string callback trampoline (avoid adding new callback type)",
    "tags": [
      "ffi",
      "double",
      "float",
      "callback",
      "trampoline",
      "string",
      "snprintf",
      "string->number"
    ],
    "imports": [],
    "code": ";; PATTERN: When you have N callback trampoline types (void, string, int, bool)\n;; and need to pass a double/float value, convert to string in C++ and back\n;; in Scheme — avoids adding a 5th trampoline type for a single signal.\n;;\n;; C++ side (in the signal connection wrapper):\n;; void qt_double_spin_box_on_value_changed(void* dsb, qt_callback_string cb, long id) {\n;;     QObject::connect(static_cast<QDoubleSpinBox*>(dsb),\n;;         QOverload<double>::of(&QDoubleSpinBox::valueChanged),\n;;         [cb, id](double value) {\n;;             char buf[64];\n;;             snprintf(buf, sizeof(buf), \"%.17g\", value);  // full precision\n;;             cb(id, buf);  // fire the STRING trampoline with stringified double\n;;         });\n;; }\n;;\n;; Scheme high-level wrapper:\n;; (def (qt-on-double-value-changed! dsb handler)\n;;   (let ((id (register-qt-string-handler!\n;;              (lambda (str) (handler (string->number str))))))\n;;     (raw_qt_double_spin_box_on_value_changed dsb id)))\n;;\n;; The handler receives a proper Scheme number (flonum), not a string.\n;; \"%.17g\" preserves full double precision (17 significant digits).\n;;\n;; Same pattern works for date/time signals:\n;; - QDateEdit::dateChanged → convert QDate to ISO string \"2025-06-15\"\n;; - QTimeEdit::timeChanged → convert QTime to ISO string \"14:30:45\"\n;; These naturally produce strings, so handler receives string directly.\n;;\n;; KEY INSIGHT: Adding a new callback type (double trampoline) requires:\n;; - New c-define, new dispatch table, new register function, new C trampoline\n;; - All for ONE signal type. String conversion is 2 lines of C++ and\n;;   1 line of Scheme, reusing the existing string infrastructure.",
    "notes": "snprintf \"%.17g\" is the standard way to round-trip a double through a string without precision loss. 17 significant digits is the maximum needed for IEEE 754 double. The Scheme string->number converts back to an exact or inexact number. This pattern is used in gerbil-qt Phase 9 for QDoubleSpinBox::valueChanged(double). The same approach works for any C callback that passes a double — convert to string in the C lambda, fire the string trampoline, convert back in the Scheme wrapper.",
    "related": [
      "multiple-callback-trampolines",
      "ffi-callback-dispatch-table"
    ]
  },
  {
    "id": "process-status-reaping-race-job-control",
    "title": "Gambit process-status reaps child: ffi-waitpid race in job control",
    "tags": [
      "process-status",
      "waitpid",
      "reap",
      "race",
      "job-control",
      "background",
      "WNOHANG",
      "gambit"
    ],
    "imports": [],
    "code": ";; GOTCHA: Gambit's (process-status port) blocks until the child exits\n;; and then REAPS it internally (via its own SIGCHLD handler / waitpid).\n;; After process-status returns, the child PID no longer exists for waitpid.\n;;\n;; This means: if you call (process-status port) and then try to call\n;; ffi-waitpid with WNOHANG to poll the child's status, waitpid returns 0\n;; (\"no status change\") because Gambit already reaped the child.\n;;\n;; WRONG pattern (job-wait that never marks jobs as done):\n;;   (for-each\n;;     (lambda (proc)\n;;       (when (eq? (job-process-status proc) 'running)\n;;         (let ((port (job-process-port proc)))\n;;           (when port (process-status port)))))   ;; ← reaps child\n;;     (job-processes job))\n;;   (ffi-waitpid-pid pid WNOHANG)  ;; ← returns 0! child already gone\n;;   ;; job-update-status! never transitions from 'running to 'exited\n;;\n;; CORRECT pattern: extract status directly from process-status return value\n;; and set the process status immediately, bypassing ffi-waitpid:\n(for-each\n  (lambda (proc)\n    (when (eq? (job-process-status proc) 'running)\n      (let ((port (job-process-port proc)))\n        (when port\n          (let ((raw (with-catch (lambda (e) 0)\n                       (lambda () (process-status port)))))\n            ;; Set status DIRECTLY — don't rely on ffi-waitpid afterward\n            (cond\n              ((WIFEXITED raw)\n               (set! (job-process-status proc) 'exited))\n              ((WIFSIGNALED raw)\n               (set! (job-process-status proc) 'signaled))\n              (else\n               (set! (job-process-status proc) 'exited))))))))\n  (job-processes job))",
    "notes": "This is critical for implementing job control in Gerbil. The root cause is that Gambit's SIGCHLD handler (or process-status itself) calls waitpid internally, consuming the child's exit status. Any subsequent waitpid call — whether via FFI or otherwise — will find no child to reap. The fix is to treat process-status's return value as the definitive status and update your job table immediately. Also applies to job cleanup: after process-status returns, the job should be marked done/killed so it can be removed from the table. Related pattern: use (close-port proc) after process-status to release the Gambit process port.",
    "related": [
      "process-status-decode-waitpid",
      "open-process-settings"
    ]
  },
  {
    "id": "qt-text-browser-anchor-clicked",
    "title": "QTextBrowser: must disable openLinks before connecting anchorClicked",
    "tags": [
      "qt",
      "QTextBrowser",
      "anchorClicked",
      "setOpenLinks",
      "hyperlink",
      "signal",
      "gotcha"
    ],
    "imports": [],
    "code": ";; GOTCHA: QTextBrowser handles link clicks internally by default.\n;; If you connect anchorClicked WITHOUT calling setOpenLinks(false) first,\n;; the signal never fires — Qt intercepts the click and tries to navigate.\n;;\n;; In the C++ shim, the on_anchor_clicked function must:\n;; 1. Call setOpenLinks(false) BEFORE connecting the signal\n;; 2. Convert QUrl to std::string via url.toString().toStdString()\n;; 3. Use string trampoline (ffi_string_trampoline)\n;;\n;; C++ pattern:\n;; void qt_text_browser_on_anchor_clicked(qt_text_browser_t tb, int id,\n;;                                         qt_callback_string callback) {\n;;   auto *browser = static_cast<QTextBrowser*>(tb);\n;;   browser->setOpenLinks(false);  // CRITICAL — must come first\n;;   QObject::connect(browser, &QTextBrowser::anchorClicked,\n;;     [id, callback](const QUrl &url) {\n;;       callback(id, url.toString().toStdString().c_str());\n;;     });\n;; }\n;;\n;; Scheme usage:\n;; (qt-on-anchor-clicked! browser\n;;   (lambda (url) (displayln \"Clicked: \" url)))",
    "notes": "Without setOpenLinks(false), QTextBrowser silently handles links internally and the anchorClicked signal is never emitted. The QUrl is converted to string via toString().toStdString() in the C++ lambda. If you also want external browser launch, call qt-text-browser-set-open-external-links! separately.",
    "related": [
      "ffi-callback-dispatch-table"
    ]
  },
  {
    "id": "qt-dialog-button-box-bitwise-flags",
    "title": "QDialogButtonBox: combine standard buttons with bitwise-ior",
    "tags": [
      "qt",
      "QDialogButtonBox",
      "bitwise-ior",
      "buttons",
      "dialog",
      "standard-buttons"
    ],
    "imports": [],
    "code": ";; QDialogButtonBox standard button flags are powers of 2 — combine with bitwise-ior.\n;;\n;; Constants (matching Qt::StandardButton enum):\n;; QT_BUTTON_OK       = 0x00000400\n;; QT_BUTTON_CANCEL   = 0x00400000\n;; QT_BUTTON_YES      = 0x00004000\n;; QT_BUTTON_NO       = 0x00010000\n;; QT_BUTTON_APPLY    = 0x02000000\n;; QT_BUTTON_CLOSE    = 0x00200000\n;; QT_BUTTON_RESET    = 0x04000000\n;; QT_BUTTON_HELP     = 0x01000000\n;; QT_BUTTON_SAVE     = 0x00000800\n;; QT_BUTTON_DISCARD  = 0x00800000\n;;\n;; Button roles for custom buttons:\n;; QT_BUTTON_ACCEPT_ROLE = 0, REJECT_ROLE = 1, RESET_ROLE = 7,\n;; APPLY_ROLE = 8, HELP_ROLE = 4\n;;\n;; Create with combined flags:\n;; (qt-button-box-create (bitwise-ior QT_BUTTON_SAVE QT_BUTTON_CANCEL))\n;;\n;; Get individual button handle:\n;; (qt-button-box-button bb QT_BUTTON_SAVE)  ;; returns QPushButton*\n;;\n;; Connect signals:\n;; (qt-on-accepted! bb (lambda () (displayln \"Save clicked\")))\n;; (qt-on-rejected! bb (lambda () (displayln \"Cancel clicked\")))\n;;\n;; The clicked(QAbstractButton*) signal fires for ANY button — use void\n;; trampoline and ignore the button pointer. Query which button was\n;; clicked by checking the button box state in the handler.",
    "notes": "QDialogButtonBox arranges buttons in platform-correct order (e.g. OK/Cancel on Windows vs Cancel/OK on macOS). The button() method takes a StandardButton constant and returns the QPushButton* handle, which can be used with qt-push-button-set-text! etc. The clicked signal passes QAbstractButton* which we ignore — use accepted/rejected for standard behavior.",
    "related": [
      "ffi-callback-dispatch-table"
    ]
  },
  {
    "id": "qt-calendar-date-signals",
    "title": "QCalendarWidget: selectionChanged vs clicked signal patterns",
    "tags": [
      "qt",
      "QCalendarWidget",
      "calendar",
      "date",
      "selectionChanged",
      "clicked",
      "signal"
    ],
    "imports": [],
    "code": ";; QCalendarWidget has TWO date-related signals with different patterns:\n;;\n;; 1. selectionChanged() — NO arguments\n;;    Fires when the selected date changes (keyboard nav, API call, click).\n;;    Use void trampoline, then QUERY the date afterward:\n;;    (qt-on-selection-changed! cal\n;;      (lambda ()\n;;        (let ((date (qt-calendar-selected-date-string cal)))\n;;          (displayln \"Selected: \" date))))\n;;\n;; 2. clicked(QDate) — passes the date\n;;    Fires only on mouse click. C++ lambda converts QDate to ISO string:\n;;    date.toString(Qt::ISODate).toStdString().c_str()\n;;    Uses string trampoline:\n;;    (qt-on-calendar-clicked! cal\n;;      (lambda (iso-date)\n;;        (displayln \"Clicked: \" iso-date)))\n;;\n;; Day-of-week constants for setFirstDayOfWeek:\n;; QT_MONDAY=1 QT_TUESDAY=2 QT_WEDNESDAY=3 QT_THURSDAY=4\n;; QT_FRIDAY=5 QT_SATURDAY=6 QT_SUNDAY=7\n;; (These match Qt::DayOfWeek enum values)",
    "notes": "selectionChanged fires more broadly (any selection change including programmatic), while clicked only fires on user mouse click. For most UIs, selectionChanged + query is the safer pattern. The ISO date string format is \"YYYY-MM-DD\". Individual components available via qt-calendar-selected-year/month/day.",
    "related": [
      "ffi-callback-dispatch-table"
    ]
  },
  {
    "id": "qt-shortcut-explicit-destroy",
    "title": "QShortcut needs explicit destroy — QObject but not QWidget",
    "tags": [
      "qt",
      "QShortcut",
      "shortcut",
      "keyboard",
      "destroy",
      "memory",
      "QObject"
    ],
    "imports": [],
    "code": ";; QShortcut is a QObject (not a QWidget). Like QTimer, QButtonGroup,\n;; and QSystemTrayIcon, it needs explicit destroy.\n;;\n;; Create with key sequence string + parent widget:\n;; (def sc (qt-shortcut-create \"Ctrl+S\" parent-widget))\n;;\n;; Connect activated signal (void trampoline):\n;; (qt-on-shortcut-activated! sc (lambda () (save-file!)))\n;;\n;; Enable/disable:\n;; (qt-shortcut-set-enabled! sc #f)  ;; disable\n;; (qt-shortcut-enabled? sc)         ;; query\n;;\n;; Change key:\n;; (qt-shortcut-set-key! sc \"Ctrl+Shift+S\")\n;;\n;; MUST destroy explicitly when done:\n;; (qt-shortcut-destroy! sc)\n;;\n;; QObjects that need explicit destroy in gerbil-qt:\n;; - QTimer        → qt-timer-destroy!\n;; - QButtonGroup  → qt-button-group-destroy!\n;; - QSystemTrayIcon → qt-system-tray-icon-destroy!\n;; - QShortcut     → qt-shortcut-destroy!",
    "notes": "Key sequence strings use Qt format: \"Ctrl+S\", \"Ctrl+Shift+N\", \"Alt+F4\", \"F5\", etc. QShortcut differs from QAction shortcuts — QAction is tied to menus/toolbars, QShortcut is standalone and can be attached to any widget. The parent widget determines the shortcut's context (which window must be active).",
    "related": [
      "ffi-callback-dispatch-table"
    ]
  },
  {
    "id": "qt-view-signal-thread-local-query",
    "title": "Qt Model/View: avoid QModelIndex in FFI with thread-local query pattern",
    "tags": [
      "qt",
      "model",
      "view",
      "signal",
      "QModelIndex",
      "thread-local",
      "ffi",
      "callback"
    ],
    "imports": [],
    "code": "// PATTERN: Qt view signals pass QModelIndex — a C++ value type that is\n// impractical to expose through FFI. Instead, capture row/col in thread-local\n// storage in the C++ lambda, fire a void callback, then query from Scheme.\n//\n// C++ shim (qt_shim.cpp):\nstatic thread_local int s_last_view_row = -1;\nstatic thread_local int s_last_view_col = -1;\n\nextern \"C\" void qt_view_on_clicked(void* view,\n                                    void (*callback)(long), long id) {\n    auto* v = static_cast<QAbstractItemView*>(static_cast<QWidget*>(view));\n    QObject::connect(v, &QAbstractItemView::clicked,\n        [callback, id](const QModelIndex& idx) {\n            s_last_view_row = idx.row();\n            s_last_view_col = idx.column();\n            callback(id);  // void trampoline\n        });\n}\n\nextern \"C\" int qt_view_last_clicked_row(void) { return s_last_view_row; }\nextern \"C\" int qt_view_last_clicked_col(void) { return s_last_view_col; }\n\n// Scheme high-level usage:\n// (qt-on-view-clicked! table-view\n//   (lambda ()\n//     (let ((row (qt-view-last-clicked-row))\n//           (col (qt-view-last-clicked-col)))\n//       (displayln \"Clicked: row=\" row \" col=\" col))))\n//\n// ALSO works for: doubleClicked, activated signals (same QModelIndex pattern)\n// selectionChanged connects to QItemSelectionModel::selectionChanged instead",
    "notes": "This is the same pattern used for keyboard events (Phase 6) — fire void callback, then query stored data. It avoids exposing QModelIndex (a complex C++ value type with model pointer, internal ID, parent reference) to Scheme. Thread-local ensures thread safety. The -1 initial values indicate \"nothing clicked yet\". For selectionChanged, connect to view->selectionModel()->selectionChanged() instead of a view signal.",
    "related": [
      "multiple-callback-trampolines",
      "qt-event-filter-no-moc",
      "ffi-callback-dispatch-table"
    ]
  },
  {
    "id": "qt-view-sorting-dynamic-cast",
    "title": "Qt: setSortingEnabled requires dynamic_cast — not on QAbstractItemView",
    "tags": [
      "qt",
      "sorting",
      "QTableView",
      "QTreeView",
      "dynamic_cast",
      "QAbstractItemView",
      "ffi"
    ],
    "imports": [],
    "code": "// GOTCHA: QAbstractItemView does NOT have setSortingEnabled().\n// Only QTableView and QTreeView do. If you write a generic \"view\"\n// function that takes QAbstractItemView*, you must dynamic_cast.\n//\n// C++ shim:\nextern \"C\" void qt_view_set_sorting_enabled(void* view, int val) {\n    // Try QTableView first\n    auto* tv = dynamic_cast<QTableView*>(static_cast<QWidget*>(view));\n    if (tv) { tv->setSortingEnabled(val != 0); return; }\n    // Then QTreeView\n    auto* trv = dynamic_cast<QTreeView*>(static_cast<QWidget*>(view));\n    if (trv) { trv->setSortingEnabled(val != 0); }\n    // QListView doesn't support sorting — silently ignored\n}\n\n// This pattern applies to other view-specific methods too.\n// QHeaderView access also needs dynamic_cast to find the right header:\nstatic QHeaderView* get_header(void* view, int horizontal) {\n    if (horizontal) {\n        auto* tv = dynamic_cast<QTableView*>(static_cast<QWidget*>(view));\n        if (tv) return tv->horizontalHeader();\n        auto* trv = dynamic_cast<QTreeView*>(static_cast<QWidget*>(view));\n        if (trv) return trv->header();  // tree only has horizontal header\n    } else {\n        auto* tv = dynamic_cast<QTableView*>(static_cast<QWidget*>(view));\n        if (tv) return tv->verticalHeader();\n        // QTreeView has no vertical header\n    }\n    return nullptr;\n}",
    "notes": "This is a common Qt API asymmetry — many methods that feel like they belong on QAbstractItemView are actually only on concrete subclasses. setSortingEnabled, horizontalHeader, verticalHeader are all examples. The dynamic_cast approach works because our void* handles are still valid QObject pointers with RTTI. Use nullptr return for graceful degradation when a view type doesn't support the operation.",
    "related": [
      "qt-view-signal-thread-local-query",
      "qt-event-filter-no-moc"
    ]
  },
  {
    "id": "lexer-raw-char-bypass-tokenizer",
    "title": "Read raw characters from lexer input bypassing shell tokenization",
    "tags": [
      "lexer",
      "parser",
      "raw",
      "character",
      "bypass",
      "arithmetic",
      "tokenizer"
    ],
    "imports": [],
    "code": ";; When building a shell parser, arithmetic expressions inside (( )) and\n;; for (( )) contain operators like <, >, |, & that the shell lexer would\n;; incorrectly treat as redirection/pipe/background operators.\n;;\n;; Solution: read raw characters directly from the lexer's input string,\n;; bypassing shell tokenization entirely.\n;;\n;; Given a lexer struct with (input pos len) fields:\n\n(defstruct lexer (input pos len ...) transparent: #t)\n\n;; Helper: get current char from lexer, or #f at end\n(def (lexer-raw-char lex)\n  (if (>= (lexer-pos lex) (lexer-len lex))\n    #f\n    (string-ref (lexer-input lex) (lexer-pos lex))))\n\n;; Helper: advance lexer position by 1\n(def (lexer-raw-advance! lex)\n  (set! (lexer-pos lex) (+ 1 (lexer-pos lex))))\n\n;; CRITICAL: clear any peeked tokens from parser AND lexer\n;; before switching to raw reading — stale tokens would cause\n;; the lexer to re-read already-consumed input.\n(def (parser-clear-peeked! ps)\n  (set! (parser-state-peeked ps) #f)\n  (set! (lexer-peeked (parser-state-lexer ps)) #f))\n\n;; Example: read arithmetic expression until )) tracking nested parens\n(def (read-arith-body ps)\n  (parser-clear-peeked! ps)\n  (let ((lex (parser-state-lexer ps))\n        (buf (open-output-string)))\n    (let loop ((depth 0))\n      (let ((ch (lexer-raw-char lex)))\n        (cond\n          ((not ch) (error \"parse error: expected '))\"))\n          ((char=? ch #\\x28)  ;; open paren: (\n           (lexer-raw-advance! lex)\n           (display ch buf)\n           (loop (+ depth 1)))\n          ((char=? ch #\\x29)  ;; close paren: )\n           (if (> depth 0)\n             (begin (lexer-raw-advance! lex)\n                    (display ch buf)\n                    (loop (- depth 1)))\n             ;; depth=0: check for second )\n             (begin\n               (lexer-raw-advance! lex)\n               (let ((ch2 (lexer-raw-char lex)))\n                 (if (and ch2 (char=? ch2 #\\x29))\n                   (begin (lexer-raw-advance! lex)\n                          (get-output-string buf))  ;; done!\n                   (begin (display \")\" buf)\n                          (loop depth)))))))\n          (else\n           (lexer-raw-advance! lex)\n           (display ch buf)\n           (loop depth)))))))",
    "notes": "Key insight: shell lexers treat < > | & as operators, but inside arithmetic expressions these are comparison/bitwise operators. Reading raw chars avoids this conflict. Always clear peeked tokens before switching from token-based to raw reading. After raw reading completes, the lexer position is past the consumed text, so subsequent token reads continue from the right place. Track nested paren depth so (a+b)*(c+d) inside (( )) doesn't prematurely close. Use char->integer hex codes (#\\x28 = '(', #\\x29 = ')') to avoid Gerbil reader issues with #\\\\( and #\\\\) character literals.",
    "related": [
      "avoid-bracket-char-literals"
    ]
  },
  {
    "id": "break-continue-exception-levels-pattern",
    "title": "Handle break/continue exceptions with levels for nested loops",
    "tags": [
      "break",
      "continue",
      "exception",
      "loop",
      "nested",
      "levels",
      "with-catch"
    ],
    "imports": [
      ":std/sugar"
    ],
    "code": ";; Shell-style break/continue with nested loop levels.\n;; \"break 2\" breaks out of 2 enclosing loops, not just 1.\n;;\n;; Define exception types with a 'levels' field:\n(defstruct break-exception (levels) transparent: #t)\n(defstruct continue-exception (levels) transparent: #t)\n\n;; Builtins create exceptions:\n;; (raise (make-break-exception 1))      ;; break (1 level)\n;; (raise (make-break-exception 2))      ;; break 2\n;; (raise (make-continue-exception 1))   ;; continue\n\n;; Each loop catches break/continue and decrements levels.\n;; If levels > 1 after decrement, re-raise for outer loop.\n(def (execute-loop body-fn update-fn test-fn env)\n  (let loop ((status 0))\n    (if (not (test-fn))\n      status\n      (with-catch\n       (lambda (e)\n         (cond\n           ((break-exception? e)\n            (if (> (break-exception-levels e) 1)\n              ;; Decrement and re-raise for outer loop\n              (raise (make-break-exception (- (break-exception-levels e) 1)))\n              ;; levels=1: break THIS loop, return current status\n              status))\n           ((continue-exception? e)\n            (if (> (continue-exception-levels e) 1)\n              ;; Decrement and re-raise for outer loop\n              (raise (make-continue-exception (- (continue-exception-levels e) 1)))\n              ;; levels=1: skip rest of body, run update, continue loop\n              (begin (update-fn) (loop status))))\n           (else (raise e))))\n       (lambda ()\n         (let ((new-status (body-fn)))\n           (update-fn)\n           (loop new-status)))))))\n\n;; WRONG — using (values 'break ...) with with-catch:\n;; with-catch returns the handler's return value, but 'values'\n;; returns a multiple-value object, not a pair. Checking with\n;; (pair? result) won't work. Use the exception levels pattern instead.",
    "notes": "Critical: with-catch returns the handler's return value as a single value. Do NOT use (values 'break status) inside a with-catch handler — the result is a multiple-value object that can't be inspected with pair?. Instead, the handler should either: (1) re-raise a decremented exception, (2) return a status value and loop, or (3) return a status value to exit the loop. The continue handler should run any update expression before looping, since continue skips the rest of the body but the loop update still needs to happen (e.g., i++ in a C-style for loop)."
  },
  {
    "id": "qt-graphics-scene-view-items",
    "title": "QGraphicsScene/View: create scene, add movable items, display in view",
    "tags": [
      "qt",
      "graphics",
      "scene",
      "view",
      "diagram",
      "item",
      "movable",
      "selectable"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; PATTERN: QGraphicsScene is a 2D scene graph. Add shapes as items,\n;; configure their visual properties and interaction flags, then display\n;; the scene in a QGraphicsView widget.\n;;\n;; Scene OWNS items — destroying scene destroys all items.\n;; QGraphicsItem is NOT a QWidget — items live in scene, not widget tree.\n;; QGraphicsScene is NOT a QWidget — needs explicit destroy.\n;; QGraphicsView IS a QWidget — parent-child ownership applies.\n\n(import :gerbil-qt/qt)\n\n(with-qt-app app\n  (let* ((scene (qt-graphics-scene-create 0 0 800 600))\n         (view (qt-graphics-view-create scene)))\n\n    ;; Add shapes — each returns an item handle\n    (let ((rect (qt-graphics-scene-add-rect! scene 50 50 120 80))\n          (circle (qt-graphics-scene-add-ellipse! scene 250 80 100 100))\n          (line (qt-graphics-scene-add-line! scene 170 90 250 130))\n          (text (qt-graphics-scene-add-text! scene \"Hello Scene\")))\n\n      ;; Style items\n      (qt-graphics-item-set-brush! rect 100 150 255)     ;; blue fill\n      (qt-graphics-item-set-pen! rect 40 80 180 2)       ;; dark blue outline, 2px\n      (qt-graphics-item-set-brush! circle 100 220 100)   ;; green fill\n      (qt-graphics-item-set-pen! line 80 80 80 2)        ;; gray line\n\n      ;; Make items movable and selectable (combine flags with bitwise-ior)\n      (qt-graphics-item-set-flags! rect\n        (bitwise-ior QT_ITEM_MOVABLE QT_ITEM_SELECTABLE))\n      (qt-graphics-item-set-flags! circle\n        (bitwise-ior QT_ITEM_MOVABLE QT_ITEM_SELECTABLE))\n\n      ;; Position, z-order, tooltip\n      (qt-graphics-item-set-pos! text 200 20)\n      (qt-graphics-item-set-zvalue! line -1.0)   ;; behind shapes\n      (qt-graphics-item-set-tooltip! rect \"Drag me!\")\n\n      ;; Configure the view\n      (qt-graphics-view-set-render-hint! view QT_RENDER_ANTIALIASING)\n      (qt-graphics-view-set-drag-mode! view QT_DRAG_RUBBER_BAND)\n      (qt-graphics-scene-set-background! scene 245 245 245)\n\n      ;; Zoom and center\n      (qt-graphics-view-scale! view 1.5 1.5)\n      (qt-graphics-view-center-on! view 200 150)\n\n      ;; Remove/clear\n      ;; (qt-graphics-scene-remove-item! scene rect)  ;; removes + deletes\n      ;; (qt-graphics-scene-clear! scene)              ;; removes all items\n      ;; (qt-graphics-scene-items-count scene)         ;; number of items\n\n      ;; View is a QWidget — add to layouts normally\n      ;; (qt-layout-add-widget! layout view)\n\n      (qt-widget-show! view)\n      (qt-app-exec! app)\n\n      ;; Cleanup: destroy view first (QWidget), then scene\n      (qt-widget-destroy! view)\n      (qt-graphics-scene-destroy! scene))))",
    "notes": "QGraphicsScene coordinates use double (exact->inexact conversion in high-level API). Item flag constants: QT_ITEM_MOVABLE (0x1), QT_ITEM_SELECTABLE (0x2), QT_ITEM_FOCUSABLE (0x4). Drag modes: QT_DRAG_NONE (0), QT_DRAG_SCROLL (1), QT_DRAG_RUBBER_BAND (2). Render hints: QT_RENDER_ANTIALIASING (0x01). set_pen uses dynamic_cast to QAbstractGraphicsShapeItem or QGraphicsLineItem. set_brush only works on shape items (not lines). remove_item does both removeItem + delete in C++. Can also add pixmap items via qt-graphics-scene-add-pixmap!.",
    "related": [
      "qt-paint-widget-custom-paintevent",
      "qt-painter-draw-pixmap",
      "qt-event-filter-no-moc"
    ]
  },
  {
    "id": "qt-paint-widget-custom-paintevent",
    "title": "PaintWidget: custom QWidget with paintEvent override for live Scheme-driven painting",
    "tags": [
      "qt",
      "paint",
      "widget",
      "paintEvent",
      "custom",
      "draw",
      "canvas",
      "resize"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; PATTERN: PaintWidget is a custom QWidget subclass that overrides paintEvent()\n;; and fires a Scheme callback. Inside the callback, use qt-paint-widget-painter\n;; to get the active QPainter, then draw with existing QPainter API functions.\n;;\n;; This is BETTER than paint-onto-pixmap for:\n;; - Proper resize handling (repaint at new size)\n;; - Hardware-accelerated rendering\n;; - No intermediate pixmap allocation\n;;\n;; CRITICAL: The painter is only valid INSIDE the paint callback.\n;; Do NOT store it for later use.\n\n(import :gerbil-qt/qt)\n\n(with-qt-app app\n  (let ((canvas (qt-paint-widget-create)))\n    ;; Set minimum size for the paint area\n    (qt-widget-set-minimum-size! canvas 400 300)\n\n    ;; Register paint callback — fires during every paintEvent\n    (qt-paint-widget-on-paint! canvas\n      (lambda ()\n        (let ((painter (qt-paint-widget-painter canvas))\n              (w (qt-paint-widget-width canvas))\n              (h (qt-paint-widget-height canvas)))\n          (when painter  ;; painter is only non-#f inside paintEvent\n            ;; Background (uses actual widget dimensions — responds to resize!)\n            (qt-painter-set-brush-color! painter 30 30 50)\n            (qt-painter-fill-rect! painter 0 0 w h)\n\n            ;; Draw shapes using existing QPainter API\n            (qt-painter-set-antialiasing! painter #t)\n            (qt-painter-set-pen-color! painter 255 100 100)\n            (qt-painter-set-pen-width! painter 2)\n            (qt-painter-draw-ellipse! painter 50 50 (- w 100) (- h 100))\n\n            (qt-painter-set-pen-color! painter 200 200 200)\n            (qt-painter-draw-text! painter 20 30 \"Resize me!\")))))\n\n    ;; Request a repaint (triggers paintEvent → callback)\n    (qt-paint-widget-update! canvas)\n\n    ;; PaintWidget IS a QWidget — add to layouts normally\n    ;; (qt-layout-add-widget! layout canvas)\n\n    (qt-widget-show! canvas)\n    (qt-app-exec! app)\n    (qt-widget-destroy! canvas)))\n\n;; C++ IMPLEMENTATION PATTERN (for reference):\n;; class PaintWidget : public QWidget {\n;;     qt_callback_void m_callback;\n;;     long m_callback_id;\n;;     QPainter* m_painter;  // only valid during paintEvent\n;; protected:\n;;     void paintEvent(QPaintEvent*) override {\n;;         QPainter painter(this);     // stack-allocated, auto end()\n;;         m_painter = &painter;        // temporarily expose to Scheme\n;;         m_callback(m_callback_id);   // fire Scheme callback\n;;         m_painter = nullptr;         // invalidate\n;;     }\n;; };\n;;\n;; NO Q_OBJECT macro or MOC needed — just overrides a virtual method.\n;; ffi_paint_widget_trampoline defined in c-declare (same compilation unit).\n;; In offscreen mode, paint callback may not fire even after update()+processEvents.",
    "notes": "PaintWidget is a QWidget — parent-child ownership applies, no explicit destroy needed if parented. The paint callback is a void trampoline — uses the same callback dispatch system as all other signals. qt-paint-widget-painter returns #f (null pointer) outside of the paint callback. Width/height use integer (int), but scene coordinates use double. For animation, call qt-paint-widget-update! from a QTimer callback. Unlike paint-onto-pixmap, PaintWidget automatically repaints at the correct size when the window is resized. The QPainter is stack-allocated in paintEvent and auto-destroyed — no explicit end()/destroy() needed.",
    "related": [
      "qt-graphics-scene-view-items",
      "qt-painter-draw-pixmap",
      "qt-event-filter-no-moc",
      "multiple-callback-trampolines"
    ]
  },
  {
    "id": "qt-graphics-item-dynamic-cast-pen-brush",
    "title": "QGraphicsItem set_pen/set_brush uses dynamic_cast for polymorphic item types",
    "tags": [
      "qt",
      "graphics",
      "item",
      "pen",
      "brush",
      "dynamic_cast",
      "shape",
      "line"
    ],
    "imports": [],
    "code": "// C++ PATTERN: QGraphicsItem is the base class, but setPen()/setBrush()\n// are on DIFFERENT subclasses. You must dynamic_cast to the right type.\n//\n// setPen() exists on:\n//   - QAbstractGraphicsShapeItem (covers rect, ellipse, polygon, path)\n//   - QGraphicsLineItem (separate class, not a shape!)\n//\n// setBrush() exists on:\n//   - QAbstractGraphicsShapeItem ONLY (not lines — lines have no fill)\n//\n// QGraphicsTextItem has NEITHER setPen nor setBrush.\n\nextern \"C\" void qt_graphics_item_set_pen(void* item,\n                                          int r, int g, int b, int width) {\n    auto* gi = static_cast<QGraphicsItem*>(item);\n    QPen pen(QColor(r, g, b));\n    pen.setWidth(width);\n    // Try shape item first (covers rect, ellipse, polygon, path)\n    if (auto* shape = dynamic_cast<QAbstractGraphicsShapeItem*>(gi))\n        shape->setPen(pen);\n    else if (auto* line = dynamic_cast<QGraphicsLineItem*>(gi))\n        line->setPen(pen);\n    // Text items: silently ignore (no pen)\n}\n\nextern \"C\" void qt_graphics_item_set_brush(void* item, int r, int g, int b) {\n    auto* gi = static_cast<QGraphicsItem*>(item);\n    if (auto* shape = dynamic_cast<QAbstractGraphicsShapeItem*>(gi))\n        shape->setBrush(QColor(r, g, b));\n    // Lines and text items: silently ignore (no brush)\n}\n\n// Works because:\n// 1. void* handles are still valid QGraphicsItem pointers with RTTI\n// 2. dynamic_cast returns nullptr for wrong types → graceful fallback\n// 3. Covers all items returned by scene->addRect/addEllipse/addLine/addText",
    "notes": "This pattern is used in gerbil-qt's C++ shim for qt_graphics_item_set_pen and qt_graphics_item_set_brush. The same dynamic_cast approach is used for Qt views (setSortingEnabled, header access) where methods exist on subclasses but not the base class. Always use dynamic_cast with nullptr checks for graceful degradation. The #include chain for these classes: QGraphicsRectItem, QGraphicsEllipseItem (both inherit QAbstractGraphicsShapeItem), QGraphicsLineItem (inherits QGraphicsItem directly), QGraphicsTextItem (inherits QGraphicsObject).",
    "related": [
      "qt-graphics-scene-view-items",
      "qt-view-sorting-dynamic-cast"
    ]
  },
  {
    "id": "gambit-sendto-socket-fd-type-caching",
    "title": "Gambit caches fd type at port creation — sendto fails after dup2 changes fd to non-socket",
    "tags": [
      "gambit",
      "sendto",
      "dup2",
      "socket",
      "fd",
      "port",
      "ENOTSOCK",
      "redirect",
      "os-exception"
    ],
    "imports": [],
    "code": ";; CRITICAL GOTCHA: Gambit caches whether a port's underlying fd is a socket\n;; at port creation time. If the port was created on a socket fd, Gambit uses\n;; sendto() for writes. If you later dup2() a regular file fd onto that fd\n;; number, Gambit still uses sendto(), which fails with ENOTSOCK.\n;;\n;; This manifests as: #<os-exception> when writing to stdout after dup2.\n;;\n;; Example scenario: shell running under `timeout` or piped input\n;; - At startup, fd 1 is a socket (from timeout's socketpair)\n;; - Gambit creates stdout port → marks it as \"socket\" → uses sendto(1, ...)\n;; - Shell does: exec 5>file.txt; echo hello >&5\n;;   which does: dup2(5, 1) → fd 1 now points to file\n;; - Gambit still uses sendto(1, ...) → ENOTSOCK!\n;;\n;; STRACE EVIDENCE:\n;;   dup2(5, 1)                      = 1       ;; fd 1 is now a regular file\n;;   sendto(1, \"hello\\n\", 6, 0, NULL, 0) = -1 ENOTSOCK\n;;\n;; FIX: After dup2(source, dest) where dest is 0/1/2 and source is a high fd\n;; (not a standard Gambit port), create a FRESH Gambit port via /dev/fd/N:\n;;\n;;   (ffi-dup2 source-fd dest-fd)\n;;   (when (and (<= 0 dest-fd 2) (> source-fd 2))\n;;     (let ((new-port (open-output-file\n;;                       [path: (string-append \"/dev/fd/\" (number->string dest-fd))\n;;                        append: #t])))\n;;       (current-output-port new-port)))  ;; or current-error-port for fd 2\n;;\n;; The new port opens /dev/fd/1, which creates a NEW internal fd (e.g., fd 7)\n;; pointing to the same file. Gambit detects fd 7 as a regular file and uses\n;; write() instead of sendto().\n;;\n;; IMPORTANT: When restoring the original fd, you MUST:\n;; 1. force-output and close-port the new port FIRST\n;; 2. Then dup2 to restore the original fd\n;; 3. Then restore the original Gambit port\n;; Otherwise the new port's internal fd leaks or flushes at wrong times.",
    "notes": "Discovered via strace while debugging gsh (Gerbil shell). When gsh is run under `timeout` command, fd 0/1/2 are socketpairs. Gambit detects this at startup and uses sendto/recvfrom for I/O instead of read/write. After dup2(file_fd, 1), sendto fails with ENOTSOCK. The fix requires creating a fresh port so Gambit re-detects the fd type. This issue does NOT occur when fds are files/pipes from the start (e.g., running from a terminal).",
    "related": [
      "character-port-from-raw-fd-via-dev-fd",
      "fd-e-extract-raw-fd-from-port",
      "pipeline-fd-management-close-write-end"
    ]
  },
  {
    "id": "qt-widget-set-font-arity",
    "title": "qt-widget-set-font! takes (widget, font-object) — NOT (widget, family, size)",
    "tags": [
      "qt",
      "font",
      "widget",
      "set-font",
      "arity",
      "gotcha",
      "gerbil-qt"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: qt-widget-set-font! takes exactly 2 arguments:\n;;   (qt-widget-set-font! widget font-object)\n;;\n;; It does NOT take (widget family-string point-size).\n;; You must create a QFont object first, then pass it.\n;;\n;; WRONG — will fail at runtime with wrong number of arguments:\n;; (qt-widget-set-font! my-label \"Monospace\" 10)  ;; ERROR!\n;;\n;; CORRECT — create a QFont object, apply it, then destroy it:\n(import :gerbil-qt/qt)\n\n(let ((mono (qt-font-create \"Monospace\" point-size: 10)))\n  (qt-widget-set-font! my-label mono)\n  (qt-widget-set-font! my-input mono)    ;; reuse for multiple widgets\n  (qt-font-destroy! mono))               ;; cleanup when done\n\n;; qt-font-create signature:\n;;   (qt-font-create family [point-size: N] [weight: W] [italic: BOOL])\n;;\n;; Common font families: \"Monospace\", \"Sans Serif\", \"Serif\"\n;;\n;; After qt-widget-set-font!, Qt copies the font data internally,\n;; so it's safe to destroy the QFont object immediately.",
    "notes": "This is a common mistake because many GUI toolkits allow (set-font widget \"family\" size) as a convenience. In gerbil-qt, fonts are always QFont objects. The qt-font-create function uses keyword arguments for optional properties. After applying to a widget, Qt copies the font internally — the QFont object can be safely destroyed. This applies to ALL widgets: labels, buttons, text edits, plain text edits, line edits, etc.",
    "related": [
      "qt-offscreen-headless-testing",
      "qt-shortcut-explicit-destroy"
    ]
  },
  {
    "id": "qt-progress-dialog-timer-driven",
    "title": "QProgressDialog with QTimer for non-blocking progress updates",
    "tags": [
      "qt",
      "progress",
      "dialog",
      "timer",
      "cancel",
      "gerbil-qt",
      "async"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; PATTERN: Use QTimer to drive QProgressDialog updates without blocking the UI.\n;; QProgressDialog is modal but non-blocking when driven by timer events.\n;;\n;; Key APIs:\n;;   qt-progress-dialog-create label cancel-text min max [parent: widget]\n;;   qt-progress-dialog-set-value! pd value\n;;   qt-progress-dialog-set-label-text! pd text\n;;   qt-progress-dialog-canceled? pd         ;; check if user clicked Cancel\n;;   qt-progress-dialog-set-minimum-duration! pd ms  ;; delay before showing (0 = immediate)\n;;   qt-progress-dialog-set-auto-close! pd bool      ;; auto-close at 100%\n;;   qt-progress-dialog-set-auto-reset! pd bool       ;; auto-reset value at 100%\n;;   qt-progress-dialog-reset! pd                     ;; reset to initial state\n\n(import :gerbil-qt/qt :std/format)\n\n;; Create dialog (range 0-100)\n(let ((pd (qt-progress-dialog-create \"Processing...\" \"Cancel\" 0 100 parent: win)))\n  (qt-progress-dialog-set-minimum-duration! pd 0)  ;; show immediately\n  (qt-progress-dialog-set-auto-close! pd #f)       ;; don't auto-close\n  (qt-progress-dialog-set-auto-reset! pd #f)       ;; don't auto-reset\n  (qt-widget-show! pd)\n\n  ;; Drive with timer\n  (let ((step 0)\n        (timer (qt-timer-create)))\n    (qt-on-timeout! timer\n      (lambda ()\n        (if (or (>= step 100) (qt-progress-dialog-canceled? pd))\n          (begin\n            (qt-timer-stop! timer)\n            (qt-timer-destroy! timer)\n            (if (qt-progress-dialog-canceled? pd)\n              (displayln \"Canceled!\")\n              (displayln \"Done!\"))\n            (qt-progress-dialog-reset! pd)\n            (qt-widget-close! pd))\n          (begin\n            (set! step (+ step 2))\n            (qt-progress-dialog-set-value! pd step)\n            (qt-progress-dialog-set-label-text! pd\n              (format \"Processing item ~a of 100...\" step))))))\n    (qt-timer-start! timer 50)))  ;; 50ms interval",
    "notes": "QProgressDialog is a QWidget — if parented, Qt handles cleanup. auto-close and auto-reset default to #t; set both to #f if you want explicit control. The timer pattern is essential because calling a blocking loop would freeze the GUI. qt-progress-dialog-canceled? checks if the Cancel button was clicked. Always call qt-timer-stop! and qt-timer-destroy! when done. The dialog should be shown with qt-widget-show! after configuration.",
    "related": [
      "qt-offscreen-headless-testing",
      "qt-shortcut-explicit-destroy"
    ]
  },
  {
    "id": "qt-system-tray-icon-pattern",
    "title": "QSystemTrayIcon with custom icon, context menu, and balloon messages",
    "tags": [
      "qt",
      "tray",
      "system-tray",
      "icon",
      "balloon",
      "notification",
      "gerbil-qt",
      "context-menu"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; PATTERN: QSystemTrayIcon — system tray with icon, context menu, and notifications.\n;;\n;; IMPORTANT: Check qt-system-tray-available? before creating!\n;; Not all platforms/desktop environments support system tray.\n;;\n;; QSystemTrayIcon is NOT a QWidget — needs explicit destroy.\n\n(import :gerbil-qt/qt)\n\n;; 1. Check availability\n(when (qt-system-tray-available?)\n\n  ;; 2. Create a custom icon (pixmap → icon)\n  (let* ((pix (qt-pixmap-create-blank 32 32))\n         (_ (qt-pixmap-fill! pix 52 152 219))  ;; blue background\n         (icon (qt-icon-create-from-pixmap pix))\n         (tray (qt-system-tray-icon-create icon)))\n\n    ;; 3. Set tooltip\n    (qt-system-tray-icon-set-tooltip! tray \"My App\")\n\n    ;; 4. Create context menu (right-click menu)\n    ;; Use a QMenu from the menu bar as context menu\n    (let ((ctx-menu (qt-menu-bar-add-menu (qt-main-window-menu-bar win) \"ctx\"))\n          (show-action (qt-action-create \"Show Window\" win))\n          (quit-action (qt-action-create \"Quit\" win)))\n      (qt-on-triggered! show-action\n        (lambda () (qt-widget-show-normal! win)))\n      (qt-on-triggered! quit-action\n        (lambda ()\n          (qt-system-tray-icon-hide! tray)\n          (qt-app-quit! app)))\n      (qt-menu-add-action! ctx-menu show-action)\n      (qt-menu-add-separator! ctx-menu)\n      (qt-menu-add-action! ctx-menu quit-action)\n      (qt-system-tray-icon-set-context-menu! tray ctx-menu))\n\n    ;; 5. Handle tray activation (click events)\n    (qt-on-tray-activated! tray\n      (lambda (reason)\n        (cond\n          ((= reason QT_TRAY_TRIGGER) (qt-widget-show-normal! win))\n          ((= reason QT_TRAY_DOUBLE_CLICK) (displayln \"double click\"))\n          ((= reason QT_TRAY_CONTEXT) (displayln \"right click\"))\n          ((= reason QT_TRAY_MIDDLE_CLICK) (displayln \"middle click\")))))\n\n    ;; 6. Show balloon notification\n    (qt-system-tray-icon-show-message! tray\n      \"Title\" \"Message body\"\n      icon-type: QT_TRAY_INFO   ;; QT_TRAY_INFO, QT_TRAY_WARNING, QT_TRAY_CRITICAL\n      timeout: 3000)             ;; milliseconds\n\n    ;; 7. Show/hide tray icon\n    (qt-system-tray-icon-show! tray)\n    ;; (qt-system-tray-icon-hide! tray)\n\n    ;; 8. Cleanup — MUST destroy explicitly\n    ;; (qt-system-tray-icon-destroy! tray)\n    ;; (qt-icon-destroy! icon)\n    ;; (qt-pixmap-destroy! pix)\n    ))",
    "notes": "QSystemTrayIcon activation reason constants: QT_TRAY_TRIGGER (single click), QT_TRAY_DOUBLE_CLICK, QT_TRAY_CONTEXT (right-click), QT_TRAY_MIDDLE_CLICK. Balloon icon types: QT_TRAY_INFO, QT_TRAY_WARNING, QT_TRAY_CRITICAL, QT_TRAY_NO_ICON. Always check qt-system-tray-available? first — Wayland/some Linux DEs don't support it. The tray icon, underlying QIcon, and QPixmap all need explicit destroy since they're not QWidgets. qt-widget-show-normal! restores a minimized window.",
    "related": [
      "qt-shortcut-explicit-destroy",
      "qt-widget-set-font-arity"
    ]
  },
  {
    "id": "qt-input-dialog-all-types",
    "title": "QInputDialog: get-text, get-int, get-double, get-item (all return #f on cancel)",
    "tags": [
      "qt",
      "input",
      "dialog",
      "get-text",
      "get-int",
      "get-double",
      "get-item",
      "gerbil-qt"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; PATTERN: QInputDialog static methods — all return #f if user cancels.\n;;\n;; All four variants use keyword arguments for optional parameters.\n;; parent: is optional but recommended (centers dialog over parent window).\n\n(import :gerbil-qt/qt)\n\n;; Text input\n(let ((result (qt-input-dialog-get-text \"Title\" \"Prompt:\"\n                default: \"initial value\" parent: win)))\n  (if result\n    (displayln \"Got: \" result)\n    (displayln \"Cancelled\")))\n\n;; Integer input (with range and step)\n(let ((result (qt-input-dialog-get-int \"Title\" \"Pick a number:\"\n                value: 42 min: 0 max: 100 step: 5 parent: win)))\n  (if result\n    (displayln \"Got: \" result)   ;; result is an integer\n    (displayln \"Cancelled\")))\n\n;; Double input (with range and decimal places)\n(let ((result (qt-input-dialog-get-double \"Title\" \"Temperature:\"\n                value: 98.6 min: -100.0 max: 200.0 decimals: 2 parent: win)))\n  (if result\n    (displayln \"Got: \" result)   ;; result is a flonum\n    (displayln \"Cancelled\")))\n\n;; Item selection (dropdown list)\n(let ((result (qt-input-dialog-get-item \"Title\" \"Choose:\"\n                [\"Option A\" \"Option B\" \"Option C\"]\n                current: 0 parent: win)))\n  (if result\n    (displayln \"Got: \" result)   ;; result is the selected string\n    (displayln \"Cancelled\")))",
    "notes": "All QInputDialog methods are blocking/modal — they hang in offscreen mode (QT_QPA_PLATFORM=offscreen). Only test these in interactive example programs, not in CI tests. The return value is the actual typed/selected value on accept, or #f on cancel. get-item takes a list of strings and returns the selected string (not the index). get-double uses the string trampoline internally (snprintf \"%.17g\") to pass double values through FFI.",
    "related": [
      "qt-offscreen-headless-testing",
      "qt-progress-dialog-timer-driven"
    ]
  },
  {
    "id": "github-actions-ci-gerbil-ffi",
    "title": "GitHub Actions CI workflow for Gerbil FFI projects",
    "tags": [
      "github",
      "actions",
      "CI",
      "workflow",
      "build",
      "test",
      "FFI",
      "gerbil"
    ],
    "imports": [],
    "code": ";; .github/workflows/ci.yml — GitHub Actions CI for a Gerbil FFI project\n;;\n;; This YAML workflow builds Gerbil from source, installs system C library\n;; dependencies, builds the project, and runs tests.\n;;\n;; Key points:\n;; - Gerbil must be built from source (no apt package)\n;; - Cache the Gerbil installation to speed up subsequent runs\n;; - Set GERBIL_HOME, GERBIL_LOADPATH, and PATH for gerbil/gxi/gxc\n;; - For Qt projects: QT_QPA_PLATFORM=offscreen for headless testing\n;; - For FFI projects: PKG_CONFIG_PATH must include system pkgconfig dir\n;;\n;; name: CI\n;; on:\n;;   push:\n;;     branches: [master]\n;;   pull_request:\n;;     branches: [master]\n;;\n;; jobs:\n;;   build-and-test:\n;;     runs-on: ubuntu-24.04\n;;     steps:\n;;       - uses: actions/checkout@v4\n;;\n;;       - name: Install system dependencies\n;;         run: |\n;;           sudo apt-get update\n;;           sudo apt-get install -y \\\n;;             libgambit \\       # Gambit Scheme runtime\n;;             autoconf git \\    # needed to build Gerbil\n;;             pkg-config g++ \\  # needed for FFI compilation\n;;             <your-c-library-dev-package>\n;;\n;;       - name: Cache Gerbil installation\n;;         uses: actions/cache@v4\n;;         id: cache-gerbil\n;;         with:\n;;           path: ~/gerbil\n;;           key: gerbil-v0.19-${{ runner.os }}-${{ hashFiles('.github/workflows/ci.yml') }}\n;;\n;;       - name: Install Gerbil\n;;         if: steps.cache-gerbil.outputs.cache-hit != 'true'\n;;         run: |\n;;           cd /tmp\n;;           git clone https://github.com/mighty-gerbils/gerbil.git\n;;           cd gerbil/src\n;;           ./configure --prefix=$HOME/gerbil\n;;           make -j$(nproc)\n;;           make install\n;;\n;;       - name: Set up environment\n;;         run: |\n;;           echo \"$HOME/gerbil/bin\" >> $GITHUB_PATH\n;;           echo \"GERBIL_HOME=$HOME/gerbil\" >> $GITHUB_ENV\n;;           echo \"GERBIL_LOADPATH=$HOME/.gerbil/lib\" >> $GITHUB_ENV\n;;\n;;       - name: Build\n;;         run: make build\n;;\n;;       - name: Test\n;;         run: make test",
    "notes": "Gerbil is not available as an apt package — must be built from source. The libgambit package provides the Gambit runtime that Gerbil compiles against. Cache the ~/gerbil directory to avoid rebuilding on every CI run (saves ~3-5 minutes). For Qt FFI projects, add `env: QT_QPA_PLATFORM: offscreen` to the Test step and `qt6-base-dev` to system dependencies. For other C libraries, add the appropriate `-dev` package. The cache key includes the workflow file hash so cache invalidates when CI config changes.",
    "related": [
      "qt-offscreen-headless-testing",
      "build-ffi-module-with-pkg-config"
    ]
  },
  {
    "id": "lsp-handler-test-pattern",
    "title": "LSP handler integration test pattern with state setup and validation",
    "tags": [
      "lsp",
      "test",
      "handler",
      "integration",
      "validate-response",
      "make-document",
      "state"
    ],
    "imports": [
      ":std/test",
      ":lsp/lsp/types",
      ":lsp/lsp/state",
      ":lsp/lsp/analysis/document",
      ":lsp/lsp/analysis/parser",
      ":lsp/lsp/analysis/symbols",
      ":lsp/lsp/validation"
    ],
    "code": ";; Pattern for testing LSP handlers with proper state setup and cleanup.\n;; 1. Create document + parse + extract symbols + set state\n;; 2. Build LSP params hash\n;; 3. Call handler\n;; 4. Verify response structure + validate against LSP schema\n;; 5. Cleanup state\n\n(test-case \"handle-X: integration test\"\n  (let* ((uri \"file:///test-example.ss\")\n         (text \"(def (add a b) (+ a b))\\n(add 1 2)\")\n         (doc (make-document uri 1 text \"gerbil\"))\n         (forms (parse-source text))\n         (syms (extract-symbols forms)))\n    ;; Setup state\n    (set-document! uri doc)\n    (set-file-symbols! uri syms)\n    ;; Call handler\n    (let* ((params (hash (\"textDocument\" (hash (\"uri\" uri)))\n                         (\"position\" (hash (\"line\" 1) (\"character\" 1)))))\n           (result (handle-hover params)))\n      (check (hash-table? result) => #t)\n      ;; Validate against LSP schema\n      (let ((violations (validate-response \"textDocument/hover\" result)))\n        (check (null? violations) => #t)))\n    ;; Cleanup\n    (remove-document! uri)\n    (remove-file-symbols! uri)))\n\n;; For \"missing document\" tests, handlers return void, empty list, or empty vector:\n(test-case \"handle-X: empty for missing document\"\n  (let* ((params (hash (\"textDocument\" (hash (\"uri\" \"file:///nonexistent.ss\")))\n                       (\"position\" (hash (\"line\" 0) (\"character\" 0)))))\n         (result (handle-some-handler params)))\n    (check (or (void? result)\n               (null? result)\n               (and (vector? result) (= (vector-length result) 0))) => #t)))",
    "notes": "Key points: (1) make-document takes (uri version text language-id). (2) make-sym-info takes 7 args: (name kind line col end-line end-col detail). (3) Handlers for missing documents return void, empty list [], or empty vector — NOT a standardized response, so test for all three. (4) validate-response from :lsp/lsp/validation checks responses against LSP protocol schemas. (5) Always cleanup with remove-document! and remove-file-symbols! to avoid polluting state between tests.",
    "related": [
      "write-tests-with-std-test"
    ]
  },
  {
    "id": "qt-action-create-parent-keyword",
    "title": "qt-action-create requires parent: keyword arg, not positional",
    "tags": [
      "qt",
      "action",
      "create",
      "parent",
      "keyword",
      "menu",
      "toolbar"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: qt-action-create takes parent: as a KEYWORD argument.\n;; Passing parent as a positional arg silently creates a broken action.\n;;\n;; WRONG — parent passed as positional arg:\n;; (qt-action-create \"Open\" win)  ;; BROKEN! \"win\" treated as unknown positional\n;;\n;; CORRECT — use parent: keyword:\n(qt-action-create \"Open\" parent: win)\n(qt-action-create \"&File\" parent: menu-bar)\n(qt-action-create \"Cut\" parent: toolbar)\n\n;; Full signature:\n;;   (qt-action-create text [parent: widget] [checkable: bool])\n;;\n;; Common usage with menu bar:\n(let* ((menu-bar (qt-main-window-menu-bar win))\n       (file-menu (qt-menu-bar-add-menu! menu-bar \"&File\"))\n       (open-action (qt-action-create \"&Open\" parent: win)))\n  (qt-menu-add-action! file-menu open-action)\n  (qt-on-action-triggered! open-action\n    (lambda () (displayln \"Open!\"))))",
    "notes": "This mistake appeared in multiple example files (mdi.ss, dockable.ss, trayapp.ss). The error is silent — the action is created but may not work correctly because the second positional arg is misinterpreted. Always use parent: keyword."
  },
  {
    "id": "qt-layout-requires-parent-widget",
    "title": "qt-hbox-layout-create and qt-vbox-layout-create require a parent widget",
    "tags": [
      "qt",
      "layout",
      "hbox",
      "vbox",
      "parent",
      "widget",
      "create"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: qt-hbox-layout-create and qt-vbox-layout-create require\n;; a parent widget argument. They cannot be called with 0 arguments.\n;;\n;; WRONG — no parent widget:\n;; (qt-hbox-layout-create)  ;; ERROR: wrong number of arguments\n;;\n;; CORRECT — pass a container widget:\n(let* ((container (qt-widget-create))\n       (hbox (qt-hbox-layout-create container)))\n  (qt-layout-add-widget! hbox (qt-label-create \"Left\"))\n  (qt-layout-add-widget! hbox (qt-line-edit-create))\n  ;; Add the container (not the layout) to the parent layout:\n  (qt-layout-add-widget! parent-vbox container))\n\n;; Pattern: filter bar with label + input\n(let* ((filter-row (qt-widget-create))\n       (filter-hbox (qt-hbox-layout-create filter-row))\n       (filter-label (qt-label-create \"Filter:\"))\n       (filter-edit (qt-line-edit-create)))\n  (qt-layout-add-widget! filter-hbox filter-label)\n  (qt-layout-add-widget! filter-hbox filter-edit)\n  ;; Add the container widget to the main layout\n  (qt-layout-add-widget! main-vbox filter-row))",
    "notes": "When adding a sub-layout to a parent layout, you add the CONTAINER WIDGET (not the layout itself) via qt-layout-add-widget!. The layout is associated with the container via the parent arg to qt-hbox-layout-create. This pattern is used whenever you need a horizontal row inside a vertical layout."
  },
  {
    "id": "qt-with-qt-app-syntax",
    "title": "with-qt-app macro syntax: bare symbol, not parenthesized",
    "tags": [
      "qt",
      "with-qt-app",
      "macro",
      "syntax",
      "application",
      "main"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: with-qt-app binds a BARE symbol, not a parenthesized form.\n;;\n;; WRONG — parenthesized binding:\n;; (with-qt-app (app)    ;; ERROR! Syntax error\n;;   (qt-widget-show! win)\n;;   (qt-app-exec! app))\n;;\n;; CORRECT — bare symbol:\n(with-qt-app app\n  (let ((win (qt-main-window-create)))\n    (qt-main-window-set-title! win \"Hello\")\n    (qt-widget-show! win)\n    (qt-app-exec! app)))\n\n;; The macro expands to something like:\n;; (let ((app (qt-app-create)))\n;;   (dynamic-wind void\n;;     (lambda () body ...)\n;;     (lambda () (qt-app-destroy! app))))",
    "notes": "Common mistake when coming from other Scheme macros like with-exception-handler or parameterize that use parenthesized binding forms. The with-qt-app macro takes a single bare identifier followed by body expressions."
  },
  {
    "id": "qt-mutator-bang-convention",
    "title": "All gerbil-qt mutator functions end with ! (bang)",
    "tags": [
      "qt",
      "mutator",
      "bang",
      "convention",
      "set",
      "naming"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; CONVENTION: ALL gerbil-qt functions that modify state end with !\n;; Missing the ! is a common source of \"unbound identifier\" errors.\n;;\n;; WRONG — missing bangs:\n;; (qt-main-window-set-title win \"Hello\")       ;; UNBOUND\n;; (qt-widget-resize win 800 600)                ;; UNBOUND\n;; (qt-main-window-set-central-widget win panel) ;; UNBOUND\n;; (qt-app-exec app)                             ;; UNBOUND\n;;\n;; CORRECT — all mutators have !:\n(qt-main-window-set-title! win \"Hello\")\n(qt-widget-resize! win 800 600)\n(qt-main-window-set-central-widget! win panel)\n(qt-app-exec! app)\n\n;; Pattern: functions WITHOUT ! are pure queries:\n;; (qt-widget-width w)        ;; query — no !\n;; (qt-label-text label)      ;; query — no !\n;; (qt-check-box-checked? cb) ;; predicate — no !\n;;\n;; Functions WITH ! modify state:\n;; (qt-widget-show! w)        ;; side effect — has !\n;; (qt-label-set-text! l t)   ;; mutation — has !\n;; (qt-widget-destroy! w)     ;; destruction — has !",
    "notes": "This Scheme convention (! for side effects) is strictly followed throughout gerbil-qt. When you get an \"unbound identifier\" error for a qt-* function, first check whether you forgot the trailing !. Common offenders: qt-app-exec!, qt-widget-resize!, qt-main-window-set-title!, qt-main-window-set-central-widget!."
  },
  {
    "id": "qt-on-return-pressed-not-line-edit-return",
    "title": "Use qt-on-return-pressed! (not qt-on-line-edit-return!) for Enter key in QLineEdit",
    "tags": [
      "qt",
      "line-edit",
      "return",
      "enter",
      "pressed",
      "callback",
      "signal"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: The signal for Enter key in QLineEdit is qt-on-return-pressed!\n;; There is NO function called qt-on-line-edit-return!\n;;\n;; WRONG — does not exist:\n;; (qt-on-line-edit-return! input (lambda (text) (handle text)))\n;;\n;; CORRECT — void callback (no text argument):\n(qt-on-return-pressed! input\n  (lambda ()\n    (let ((text (qt-line-edit-text input)))\n      (displayln \"User entered: \" text)\n      (qt-line-edit-clear! input))))\n\n;; The callback takes NO arguments (void trampoline).\n;; To get the text, call qt-line-edit-text inside the callback.",
    "notes": "The callback is a void trampoline (no arguments), not a string trampoline. You must explicitly read the line edit's text inside the callback using qt-line-edit-text. This matches Qt's returnPressed() signal which also carries no arguments."
  },
  {
    "id": "qt-status-bar-text-via-main-window",
    "title": "Set status bar text via qt-main-window-set-status-bar-text!, not qt-status-bar-show-message!",
    "tags": [
      "qt",
      "status",
      "bar",
      "message",
      "main-window",
      "text"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: There is no qt-main-window-status-bar function to get a\n;; QStatusBar object. Instead, use qt-main-window-set-status-bar-text!\n;; which operates directly on the main window.\n;;\n;; WRONG — these don't exist:\n;; (def sb (qt-main-window-status-bar win))     ;; UNBOUND\n;; (qt-status-bar-show-message! sb \"Ready\")     ;; UNBOUND\n;;\n;; CORRECT — set status bar text via main window:\n(qt-main-window-set-status-bar-text! win \"Ready\")\n(qt-main-window-set-status-bar-text! win \"File saved successfully\")\n\n;; Use in callbacks:\n(qt-on-action-triggered! save-action\n  (lambda ()\n    (save-file!)\n    (qt-main-window-set-status-bar-text! win \"Saved!\")))",
    "notes": "In gerbil-qt, the status bar is not exposed as a separate object. All status bar operations go through the main window. Qt automatically creates the status bar on first use. The message persists until replaced by another call."
  },
  {
    "id": "qt-patchelf-rpath-install-makefile",
    "title": "Use patchelf --add-rpath in Makefile install for vendored .so libraries",
    "tags": [
      "qt",
      "patchelf",
      "rpath",
      "install",
      "makefile",
      "vendor",
      "shared-library",
      "ffi"
    ],
    "imports": [],
    "code": ";; PROBLEM: gxc/Gambit drops extra -Wl,-rpath options passed via -ld-options.\n;; Only the FIRST rpath survives compilation. If your project has a vendored\n;; .so (e.g. libqt_shim.so) and you want both a local AND install rpath,\n;; the install rpath gets dropped.\n;;\n;; SOLUTION: Use patchelf --add-rpath in the Makefile install target\n;; to patch the compiled .o1 files AFTER build.\n;;\n;; ---- Makefile pattern ----\n;; INSTALL_DIR = $(HOME)/.gerbil/lib/gerbil-qt\n;;\n;; install: build\n;; \t@mkdir -p $(INSTALL_DIR)\n;; \tcp -f .gerbil/lib/gerbil-qt/* $(INSTALL_DIR)/\n;; \tcp -f vendor/libqt_shim.so $(INSTALL_DIR)/\n;; \t@if command -v patchelf >/dev/null 2>&1; then \\\n;; \t\tfor f in $(INSTALL_DIR)/libqt~0.o*; do \\\n;; \t\t\tpatchelf --add-rpath $(INSTALL_DIR) \"$$f\" 2>/dev/null || true; \\\n;; \t\tdone; \\\n;; \tfi\n;; ---- end ----\n;;\n;; KEY DIFFERENCES from --set-rpath:\n;; - --add-rpath APPENDS to existing RUNPATH (preserves build-time paths)\n;; - --set-rpath REPLACES the entire RUNPATH (may break build-time paths)\n;;\n;; Verify with:\n;;   patchelf --print-rpath ~/.gerbil/lib/gerbil-qt/libqt~0.o1\n;;   # Should show: /path/to/vendor:/home/user/.gerbil/lib/gerbil-qt",
    "notes": "The existing patchelf recipes use --set-rpath which replaces the entire RUNPATH. For FFI libraries with vendored .so files, --add-rpath is better because it preserves the build-time rpath (pointing to vendor/) while adding the install location. The `command -v patchelf` guard makes the install target work even without patchelf installed (just won't patch rpath). The libqt~0.o* glob matches Gambit's compiled output naming convention."
  },
  {
    "id": "qt-splitter-create-requires-orientation",
    "title": "qt-splitter-create requires orientation as positional arg",
    "tags": [
      "qt",
      "splitter",
      "create",
      "orientation",
      "QT_VERTICAL",
      "QT_HORIZONTAL",
      "arity"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: qt-splitter-create requires orientation as a mandatory positional arg.\n;; Calling (qt-splitter-create) with 0 args fails with arity mismatch.\n;;\n;; WRONG:\n;; (qt-splitter-create)  ;; ERROR: arity mismatch\n;;\n;; CORRECT — pass orientation constant:\n(qt-splitter-create QT_VERTICAL)     ;; top/bottom split\n(qt-splitter-create QT_HORIZONTAL)   ;; left/right split\n\n;; Full signature:\n;;   (qt-splitter-create orientation [parent: widget])\n;;\n;; Constants: QT_VERTICAL = 2, QT_HORIZONTAL = 1\n;;\n;; Example: table view above, detail panel below\n(let ((splitter (qt-splitter-create QT_VERTICAL)))\n  (qt-splitter-add-widget! splitter table-view)\n  (qt-splitter-add-widget! splitter detail-panel)\n  (qt-splitter-set-sizes! splitter '(500 250))\n  splitter)",
    "notes": "The orientation is positional (not a keyword), and parent: is a keyword. This is unlike most other create functions in gerbil-qt where all args are keywords. The compile error message is cryptic: 'Illegal lambda application; arity mismatch' with detail 3."
  },
  {
    "id": "qt-toolbar-create-requires-title",
    "title": "qt-toolbar-create requires title as positional arg",
    "tags": [
      "qt",
      "toolbar",
      "create",
      "title",
      "arity",
      "main-window"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: qt-toolbar-create requires a title string as positional arg.\n;; Calling (qt-toolbar-create) with 0 args fails with arity mismatch.\n;;\n;; WRONG:\n;; (qt-toolbar-create)  ;; ERROR: arity mismatch\n;;\n;; CORRECT:\n(qt-toolbar-create \"Main\")\n(qt-toolbar-create \"Tools\" parent: win)\n\n;; Full signature:\n;;   (qt-toolbar-create title [parent: widget])\n;;\n;; Example with main window:\n(let ((toolbar (qt-toolbar-create \"Main\")))\n  (qt-toolbar-set-movable! toolbar #f)\n  (let ((action (qt-action-create \"Save\")))\n    (qt-toolbar-add-action! toolbar action))\n  (qt-toolbar-add-separator! toolbar)\n  (qt-toolbar-add-widget! toolbar (qt-line-edit-create))\n  (qt-main-window-add-toolbar! win toolbar))",
    "notes": "Title is positional (not keyword), parent: is keyword. Similar pattern to qt-action-create which also requires text as positional.",
    "related": [
      "qt-action-create-requires-parent-keyword"
    ]
  },
  {
    "id": "qt-file-dialog-open-directory-signature",
    "title": "qt-file-dialog-open-directory takes parent positional, caption/dir as keywords",
    "tags": [
      "qt",
      "file-dialog",
      "directory",
      "open",
      "caption",
      "dialog"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; qt-file-dialog-open-directory signature:\n;;   (qt-file-dialog-open-directory parent [caption: string] [dir: string])\n;;\n;; parent is a required positional arg (the parent window)\n;; caption: defaults to \"Open Directory\"\n;; dir: defaults to \"\" (current directory)\n;;\n;; WRONG — passing caption as positional:\n;; (qt-file-dialog-open-directory win \"Choose Folder\")  ;; ERROR: arity mismatch\n;;\n;; CORRECT — caption as keyword:\n(qt-file-dialog-open-directory win caption: \"Choose Folder\")\n(qt-file-dialog-open-directory win caption: \"Open Database\" dir: \"/home\")\n\n;; Returns a string path, or empty string if canceled\n(let ((path (qt-file-dialog-open-directory win caption: \"Open Database\")))\n  (when (and (string? path) (> (string-length path) 0))\n    (displayln \"Selected: \" path)))",
    "notes": "Similar pattern for qt-file-dialog-open-file and qt-file-dialog-save-file which take parent positional plus keyword args for caption, dir, and filter."
  },
  {
    "id": "qt-form-layout-spanning-widget",
    "title": "Use qt-form-layout-add-spanning-widget! for single-widget rows (not add-row-widget!)",
    "tags": [
      "qt",
      "form-layout",
      "spanning",
      "checkbox",
      "widget",
      "row"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; GOTCHA: qt-form-layout-add-row-widget! takes 3 args: (layout label-widget field-widget)\n;; It adds a row with TWO widgets (label + field), not a spanning single widget.\n;;\n;; To add a SINGLE widget that spans the entire row (e.g. a checkbox or button bar),\n;; use qt-form-layout-add-spanning-widget! which takes 2 args: (layout widget)\n;;\n;; WRONG — for adding a checkbox that spans the whole row:\n;; (qt-form-layout-add-row-widget! layout my-checkbox)  ;; ERROR: arity mismatch (expects 3 args)\n;;\n;; CORRECT:\n(qt-form-layout-add-spanning-widget! layout my-checkbox)\n\n;; Example: complete form with labels, fields, and a spanning checkbox\n(let* ((dlg (qt-dialog-create parent: win))\n       (layout (qt-form-layout-create parent: dlg))\n       (name-edit (qt-line-edit-create))\n       (email-edit (qt-line-edit-create))\n       (newsletter-check (qt-check-box-create \"Subscribe to newsletter\")))\n  (qt-form-layout-add-row! layout \"Name:\" name-edit)\n  (qt-form-layout-add-row! layout \"Email:\" email-edit)\n  (qt-form-layout-add-spanning-widget! layout newsletter-check)\n  (qt-dialog-exec! dlg))",
    "notes": "qt-form-layout-add-row! takes (layout label-string field-widget) for string labels. qt-form-layout-add-row-widget! takes (layout label-widget field-widget) for widget labels. qt-form-layout-add-spanning-widget! takes (layout widget) for a widget spanning the full row."
  },
  {
    "id": "qt-standard-model-create-keyword-args",
    "title": "qt-standard-model-create uses rows: cols: parent: keyword args",
    "tags": [
      "qt",
      "model",
      "standard-model",
      "create",
      "rows",
      "cols",
      "table"
    ],
    "imports": [
      ":gerbil-qt/qt"
    ],
    "code": ";; qt-standard-model-create signature:\n;;   (qt-standard-model-create [rows: n] [cols: n] [parent: widget])\n;; All args are KEYWORD (not positional). Defaults: rows: 0, cols: 0, parent: #f\n;;\n;; WRONG — positional args:\n;; (qt-standard-model-create 0 8)  ;; ERROR\n;;\n;; CORRECT — keyword args:\n(qt-standard-model-create rows: 0 cols: 8)\n\n;; Set column headers one at a time:\n;;   (qt-standard-model-set-horizontal-header! model column-index text)\n(let ((model (qt-standard-model-create rows: 0 cols: 3)))\n  (qt-standard-model-set-horizontal-header! model 0 \"Name\")\n  (qt-standard-model-set-horizontal-header! model 1 \"Value\")\n  (qt-standard-model-set-horizontal-header! model 2 \"Type\")\n  model)\n\n;; qt-standard-item-create uses text: keyword:\n;;   (qt-standard-item-create [text: string])\n;; Default: text: \"\"\n(qt-standard-item-create text: \"Hello\")\n\n;; Populate model row by row:\n(qt-standard-model-set-row-count! model 1)\n(qt-standard-model-set-item! model 0 0 (qt-standard-item-create text: \"Alice\"))\n(qt-standard-model-set-item! model 0 1 (qt-standard-item-create text: \"42\"))\n(qt-standard-model-set-item! model 0 2 (qt-standard-item-create text: \"user\"))",
    "notes": "qt-standard-model-set-horizontal-header! takes (model col text) — sets one header at a time, not a list. qt-standard-item-create takes text: keyword (not positional). The text defaults to empty string."
  }
]
